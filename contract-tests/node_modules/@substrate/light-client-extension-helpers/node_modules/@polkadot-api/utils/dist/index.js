"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AbortError: () => AbortError,
  filterObject: () => filterObject,
  fromHex: () => fromHex,
  mapObject: () => mapObject,
  mapStringRecord: () => mapStringRecord,
  mergeUint8: () => mergeUint8,
  noop: () => noop,
  toHex: () => toHex
});
module.exports = __toCommonJS(src_exports);

// src/hex.ts
var HEX_STR = "0123456789abcdef";
function toHex(bytes) {
  const result = new Array(bytes.length + 1);
  result[0] = "0x";
  for (let i = 0; i < bytes.length; ) {
    const b = bytes[i++];
    result[i] = HEX_STR[b >> 4] + HEX_STR[b & 15];
  }
  return result.join("");
}
var HEX_MAP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd)
    bytes[0] = 0 | HEX_MAP[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP[hexString[idx]];
    const b = HEX_MAP[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}

// src/mapObject.ts
function mapObject(input, mapper) {
  return Object.fromEntries(
    Object.entries(input).map(
      ([key, value]) => [key, mapper(value, key)]
    )
  );
}
var mapStringRecord = (input, mapper) => Object.fromEntries(
  Object.entries(input).map(([key, value]) => [key, mapper(value, key)])
);

// src/filterObject.ts
function filterObject(input, filterFn) {
  return Object.fromEntries(
    Object.entries(input).filter(([key, value]) => filterFn(value, key))
  );
}

// src/mergeUint8.ts
var mergeUint8 = (...inputs) => {
  const totalLen = inputs.reduce((acc, a) => acc + a.byteLength, 0);
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < inputs.length; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};

// src/noop.ts
var noop = Function.prototype;

// src/AbortError.ts
var AbortError = class extends Error {
  constructor() {
    super("Abort Error");
    this.name = "AbortError";
  }
};
//# sourceMappingURL=index.js.map