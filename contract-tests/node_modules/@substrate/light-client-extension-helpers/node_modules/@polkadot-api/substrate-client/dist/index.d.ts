import { JsonRpcProvider } from '@polkadot-api/json-rpc-provider';
export * from '@polkadot-api/json-rpc-provider';
export { AbortError } from '@polkadot-api/utils';

interface IRpcError {
    code: number;
    message: string;
    data?: any;
}
declare class RpcError extends Error implements IRpcError {
    code: number;
    data: any;
    constructor(e: IRpcError);
}

type UnsubscribeFn = () => void;
type WithAbortSignal<T extends Array<any>> = [
    ...args: T,
    abortSignal?: AbortSignal
];
type AbortablePromiseFn<A extends Array<any>, T> = (...args: WithAbortSignal<A>) => Promise<T>;

interface Subscriber<T> {
    next: (data: T) => void;
    error: (e: Error) => void;
}

type FollowSubscriptionCb<T> = (subscriptionId: string, cb: Subscriber<T>) => UnsubscribeFn;
type ClientRequestCb<T, TT> = {
    onSuccess: (result: T, followSubscription: FollowSubscriptionCb<TT>) => void;
    onError: (e: Error) => void;
};
type ClientRequest<T, TT> = (method: string, params: Array<any>, cb?: ClientRequestCb<T, TT>) => UnsubscribeFn;
interface Client {
    disconnect: () => void;
    request: ClientRequest<any, any>;
}

declare class DestroyedError extends Error {
    constructor();
}

type FollowInnerSubscriptionCb<T> = (subscriptionId: string, cb: Subscriber<T>) => UnsubscribeFn;
type ClientInnerRequestCb<T, TT> = {
    onSuccess: (result: T, followSubscription: FollowInnerSubscriptionCb<TT>) => void;
    onError: (e: Error) => void;
};
type ClientInnerRequest<T, TT> = (method: string, params: Array<any>, cb?: ClientInnerRequestCb<T, TT>) => UnsubscribeFn;
interface StorageItemInput {
    key: string;
    type: "value" | "hash" | "closestDescendantMerkleValue" | "descendantsValues" | "descendantsHashes";
}
interface StorageItemResponse {
    key: string;
    value?: string;
    hash?: string;
    closestDescendantMerkleValue?: string;
}
interface Runtime {
    specName: string;
    implName: string;
    specVersion: number;
    implVersion: number;
    transactionVersion: number;
    apis: Record<string, number>;
}
interface Initialized {
    type: "initialized";
    finalizedBlockHashes: string[];
}
type InitializedWithRuntime$1 = Initialized & {
    finalizedBlockRuntime: Runtime;
};
interface NewBlock {
    type: "newBlock";
    blockHash: string;
    parentBlockHash: string;
}
type NewBlockWithRuntime$1 = NewBlock & {
    newRuntime: Runtime | null;
};
interface BestBlockChanged {
    type: "bestBlockChanged";
    bestBlockHash: string;
}
interface Finalized {
    type: "finalized";
    finalizedBlockHashes: Array<string>;
    prunedBlockHashes: Array<string>;
}
type CommonFollowEvents = BestBlockChanged | Finalized;
type FollowEventWithRuntime = InitializedWithRuntime$1 | NewBlockWithRuntime$1 | CommonFollowEvents;
type FollowEventWithoutRuntime = Initialized | NewBlock | CommonFollowEvents;
type StorageResult<Input extends StorageItemInput["type"]> = Input extends "descendantsHashes" ? Array<{
    key: string;
    hash: string;
}> : Input extends "descendantsValues" ? Array<{
    key: string;
    value: string;
}> : string | null;
interface FollowResponse {
    unfollow: UnsubscribeFn;
    body: AbortablePromiseFn<[hash: string], Array<string>>;
    call: AbortablePromiseFn<[
        hash: string,
        fnName: string,
        callParameters: string
    ], string>;
    storage: <Type extends StorageItemInput["type"]>(hash: string, type: Type, key: string, childTrie: string | null, abortSignal?: AbortSignal | undefined) => Promise<StorageResult<Type>>;
    storageSubscription: (hash: string, inputs: Array<StorageItemInput>, childTrie: string | null, onItems: (items: Array<StorageItemResponse>) => void, onError: (e: Error) => void, onDone: () => void, onDiscardedItems: (nDiscarded: number) => void) => () => void;
    header: (hash: string) => Promise<string>;
    unpin: (hashes: Array<string>) => Promise<void>;
    _request: <Reply, Notification>(method: string, params: any[], cb?: ClientInnerRequestCb<Reply, Notification>) => UnsubscribeFn;
}
interface ChainHead {
    (withRuntime: false, cb: (event: FollowEventWithoutRuntime) => void, onError: (error: Error) => void): FollowResponse;
    (withRuntime: true, cb: (event: FollowEventWithRuntime) => void, onError: (error: Error) => void): FollowResponse;
    (withRuntime: boolean, cb: (event: FollowEventWithoutRuntime | FollowEventWithRuntime) => void, onError: (error: Error) => void): FollowResponse;
}

declare class StopError extends Error {
    constructor();
}
declare class DisjointError extends Error {
    constructor();
}
declare class OperationLimitError extends Error {
    constructor();
}
declare class OperationError extends Error {
    constructor(error: string);
}
declare class OperationInaccessibleError extends Error {
    constructor();
}

interface RuntimeRpc {
    specName: string;
    implName: string;
    specVersion: number;
    implVersion: number;
    transactionVersion: number;
    apis: Record<string, number>;
}
type InitializedRpc = {
    event: "initialized";
    finalizedBlockHash: string;
} | {
    event: "initialized";
    finalizedBlockHashes: string[];
};
type InitializedWithRuntime = InitializedRpc & {
    finalizedBlockRuntime: RuntimeRpc;
};
interface NewBlockRpc {
    event: "newBlock";
    blockHash: string;
    parentBlockHash: string;
}
type NewBlockWithRuntime = NewBlockRpc & {
    newRuntime: RuntimeRpc | null;
};
interface BestBlockChangedRpc {
    event: "bestBlockChanged";
    bestBlockHash: string;
}
interface FinalizedRpc {
    event: "finalized";
    finalizedBlockHashes: Array<string>;
    prunedBlockHashes: Array<string>;
}
type CommonFollowEventsRpc = BestBlockChangedRpc | FinalizedRpc;
type FollowEventWithRuntimeRpc = InitializedWithRuntime | NewBlockWithRuntime | CommonFollowEventsRpc;
type FollowEventWithoutRuntimeRpc = InitializedRpc | NewBlockRpc | CommonFollowEventsRpc;
interface StopRpc {
    event: "stop";
}
interface OperationEventRpc {
    operationId: string;
}
type OperationWaitingForContinueRpc = OperationEventRpc & {
    event: "operationWaitingForContinue";
};
type OperationInaccessibleRpc = OperationEventRpc & {
    event: "operationInaccessible";
};
type OperationErrorRpc = OperationEventRpc & {
    event: "operationError";
    error: string;
};
type CommonOperationEventsRpc = OperationInaccessibleRpc | OperationErrorRpc;
type OperationBodyDoneRpc = OperationEventRpc & {
    event: "operationBodyDone";
    value: Array<string>;
};
type OperationCallDoneRpc = OperationEventRpc & {
    event: "operationCallDone";
    output: string;
};
interface StorageItemResponseRpc {
    key: string;
    value?: string;
    hash?: string;
    closestDescendantMerkleValue?: string;
}
type OperationStorageItemsRpc = OperationEventRpc & {
    event: "operationStorageItems";
    items: Array<StorageItemResponseRpc>;
};
type OperationStorageDoneRpc = OperationEventRpc & {
    event: "operationStorageDone";
};
type OperationEventsRpc = OperationBodyDoneRpc | OperationCallDoneRpc | OperationStorageItemsRpc | OperationWaitingForContinueRpc | OperationStorageDoneRpc | CommonOperationEventsRpc;

type FollowEventRpc = FollowEventWithRuntimeRpc | FollowEventWithoutRuntimeRpc | OperationEventsRpc | StopRpc;
declare function getChainHead(request: ClientRequest<string, FollowEventRpc>): ChainHead;

type Transaction = (tx: string, error: (e: Error) => void) => UnsubscribeFn;

declare const getTransaction: (request: ClientRequest<string, any>) => (tx: string, error: (e: Error) => void) => () => void;

interface ChainSpecData {
    name: string;
    genesisHash: string;
    properties: any;
}
declare const createGetChainSpec: (clientRequest: ClientRequest<any, any>) => () => Promise<ChainSpecData>;

interface SubstrateClient {
    chainHead: ChainHead;
    transaction: Transaction;
    destroy: UnsubscribeFn;
    getChainSpecData: () => Promise<ChainSpecData>;
    request: <T>(method: string, params: any[], abortSignal?: AbortSignal) => Promise<T>;
    _request: <Reply, Notification>(method: string, params: any[], cb?: ClientRequestCb<Reply, Notification>) => UnsubscribeFn;
}
declare const createClient: (provider: JsonRpcProvider) => SubstrateClient;

export { type AbortablePromiseFn, type BestBlockChanged, type ChainHead, type ChainSpecData, type Client, type ClientInnerRequest, type ClientInnerRequestCb, type ClientRequest, type ClientRequestCb, DestroyedError, DisjointError, type Finalized, type FollowEventWithRuntime, type FollowEventWithoutRuntime, type FollowInnerSubscriptionCb, type FollowResponse, type FollowSubscriptionCb, type IRpcError, type Initialized, type InitializedWithRuntime$1 as InitializedWithRuntime, type NewBlock, type NewBlockWithRuntime$1 as NewBlockWithRuntime, OperationError, OperationInaccessibleError, OperationLimitError, RpcError, type Runtime, StopError, type StorageItemInput, type StorageItemResponse, type StorageResult, type SubstrateClient, type Transaction, type UnsubscribeFn, createClient, createGetChainSpec, getChainHead, getTransaction };
