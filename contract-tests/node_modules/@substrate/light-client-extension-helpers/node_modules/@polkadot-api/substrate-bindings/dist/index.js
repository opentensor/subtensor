"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountId: () => AccountId,
  Bin: () => Bin,
  Binary: () => Binary,
  Blake2128: () => Blake2128,
  Blake2128Concat: () => Blake2128Concat,
  Blake2256: () => Blake2256,
  Blake3256: () => Blake3256,
  Blake3256Concat: () => Blake3256Concat,
  Bytes: () => import_scale_ts8.Bytes,
  Enum: () => Enum2,
  FixedSizeBinary: () => FixedSizeBinary,
  Hex: () => Hex,
  Identity: () => Identity,
  Option: () => import_scale_ts8.Option,
  Result: () => import_scale_ts8.Result,
  ScaleEnum: () => import_scale_ts8.Enum,
  Self: () => Self,
  Storage: () => Storage,
  Struct: () => import_scale_ts8.Struct,
  Tuple: () => import_scale_ts8.Tuple,
  Twox128: () => Twox128,
  Twox256: () => Twox256,
  Twox64Concat: () => Twox64Concat,
  Variant: () => Variant,
  Vector: () => import_scale_ts8.Vector,
  _Enum: () => _Enum,
  _void: () => import_scale_ts8._void,
  bitSequence: () => bitSequence,
  blockHeader: () => blockHeader,
  bool: () => import_scale_ts8.bool,
  char: () => char,
  compact: () => import_scale_ts8.compact,
  compactBn: () => compactBn,
  compactNumber: () => compactNumber,
  createCodec: () => import_scale_ts8.createCodec,
  createDecoder: () => import_scale_ts8.createDecoder,
  enhanceCodec: () => import_scale_ts8.enhanceCodec,
  enhanceDecoder: () => import_scale_ts8.enhanceDecoder,
  enhanceEncoder: () => import_scale_ts8.enhanceEncoder,
  ethAccount: () => ethAccount,
  fixedStr: () => fixedStr,
  fromBufferToBase58: () => fromBufferToBase58,
  getSs58AddressInfo: () => getSs58AddressInfo,
  h64: () => h64,
  i128: () => import_scale_ts8.i128,
  i16: () => import_scale_ts8.i16,
  i256: () => import_scale_ts8.i256,
  i32: () => import_scale_ts8.i32,
  i64: () => import_scale_ts8.i64,
  i8: () => import_scale_ts8.i8,
  metadata: () => metadata,
  selfDecoder: () => selfDecoder,
  selfEncoder: () => selfEncoder,
  str: () => import_scale_ts8.str,
  u128: () => import_scale_ts8.u128,
  u16: () => import_scale_ts8.u16,
  u256: () => import_scale_ts8.u256,
  u32: () => import_scale_ts8.u32,
  u64: () => import_scale_ts8.u64,
  u8: () => import_scale_ts8.u8,
  v14: () => v14,
  v15: () => v15
});
module.exports = __toCommonJS(src_exports);

// src/codecs/scale/AccountId.ts
var import_scale_ts = require("scale-ts");

// src/utils/ss58-util.ts
var import_base = require("@scure/base");
var import_blake2b = require("@noble/hashes/blake2b");
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var getSs58AddressInfo = (address) => {
  try {
    const decoded = import_base.base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = (0, import_blake2b.blake2b)(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    const isChecksumValid = checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1];
    if (!isChecksumValid) return { isValid: false };
    return {
      isValid: true,
      ss58Format: prefixBytesToNumber(prefixBytes),
      publicKey: publicKey.slice()
    };
  } catch (_) {
    return { isValid: false };
  }
};
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = (0, import_blake2b.blake2b)(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return import_base.base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};

// src/codecs/scale/AccountId.ts
function fromBase58ToBuffer(nBytes, _ss58Format) {
  return (address) => {
    const info = getSs58AddressInfo(address);
    if (!info.isValid) throw new Error("Invalid checksum");
    const { publicKey } = info;
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    return publicKey;
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => (0, import_scale_ts.enhanceCodec)(
  (0, import_scale_ts.Bytes)(nBytes),
  fromBase58ToBuffer(nBytes, ss58Format),
  fromBufferToBase58(ss58Format)
);

// src/codecs/scale/Binary.ts
var import_scale_ts2 = require("scale-ts");
var import_utils = require("@polkadot-api/utils");
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var _bytes, _hex, _str;
var _Binary = class _Binary {
  constructor(data) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _str, null);
    __publicField(this, "asText", () => __privateGet(this, _str) === null ? __privateSet(this, _str, textDecoder.decode(__privateGet(this, _bytes))) : __privateGet(this, _str));
    __publicField(this, "asHex", () => __privateGet(this, _hex) === null ? __privateSet(this, _hex, (0, import_utils.toHex)(__privateGet(this, _bytes))) : __privateGet(this, _hex));
    __publicField(this, "asBytes", () => __privateGet(this, _bytes));
    __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new _Binary(textEncoder.encode(input));
  }
  static fromHex(input) {
    return new _Binary((0, import_utils.fromHex)(input));
  }
  static fromBytes(input) {
    return new _Binary(input);
  }
};
_bytes = new WeakMap();
_hex = new WeakMap();
_str = new WeakMap();
var Binary = _Binary;
var FixedSizeBinary = class _FixedSizeBinary extends Binary {
  constructor(data) {
    super(data);
  }
  static fromArray(input) {
    return new _FixedSizeBinary(new Uint8Array(input));
  }
};
var enc = (nBytes) => {
  const _enc = import_scale_ts2.Bytes.enc(nBytes);
  return (value) => _enc(value.asBytes());
};
var dec = (nBytes) => {
  const _dec = import_scale_ts2.Bytes.dec(nBytes);
  return (value) => Binary.fromBytes(_dec(value));
};
var Bin = (nBytes) => (0, import_scale_ts2.createCodec)(enc(nBytes), dec(nBytes));
Bin.enc = enc;
Bin.dec = dec;

// src/codecs/scale/bitSequence.ts
var import_scale_ts4 = require("scale-ts");

// src/codecs/scale/compact.ts
var import_scale_ts3 = require("scale-ts");
var compactNumber = import_scale_ts3.compact;
var compactBn = import_scale_ts3.compact;

// src/codecs/scale/bitSequence.ts
var bitSequenceDecoder = (0, import_scale_ts4.createDecoder)((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = (0, import_scale_ts4.Bytes)(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence = (0, import_scale_ts4.createCodec)(bitSequenceEncoder, bitSequenceDecoder);

// src/codecs/scale/char.ts
var import_scale_ts5 = require("scale-ts");
var char = (0, import_scale_ts5.enhanceCodec)(
  import_scale_ts5.u8,
  (str8) => str8.charCodeAt(0),
  String.fromCharCode
);

// src/codecs/scale/Hex.ts
var import_utils2 = require("@polkadot-api/utils");
var import_scale_ts6 = require("scale-ts");
var enc2 = (nBytes) => {
  const _enc = import_scale_ts6.Bytes.enc(nBytes);
  return (value) => _enc((0, import_utils2.fromHex)(value));
};
var dec2 = (nBytes) => {
  const _dec = import_scale_ts6.Bytes.dec(nBytes);
  return (value) => (0, import_utils2.toHex)(_dec(value));
};
var Hex = (nBytes) => (0, import_scale_ts6.createCodec)(enc2(nBytes), dec2(nBytes));
Hex.enc = enc2;
Hex.dec = dec2;

// src/codecs/scale/fixed-str.ts
var import_scale_ts7 = require("scale-ts");
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var fixedStr = (nBytes) => (0, import_scale_ts7.enhanceCodec)(
  (0, import_scale_ts7.Bytes)(nBytes),
  (str8) => textEncoder2.encode(str8),
  (bytes) => textDecoder2.decode(bytes)
);

// src/codecs/scale/re-exported.ts
var import_scale_ts8 = require("scale-ts");

// src/codecs/scale/Self.ts
var import_scale_ts9 = require("scale-ts");
var selfEncoder = (value) => {
  let cache = (x) => {
    const encoder = value();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value) => (0, import_scale_ts9.createCodec)(
  selfEncoder(() => value().enc),
  selfDecoder(() => value().dec)
);

// src/codecs/scale/Variant.ts
var import_scale_ts10 = require("scale-ts");
var import_utils3 = require("@polkadot-api/utils");

// src/types/enum.ts
var discriminant = {
  is(value, type) {
    return value.type === type;
  },
  as(value, type) {
    if (type !== value.type)
      throw new Error(
        `Enum.as(enum, ${type}) used with actual type ${value.type}`
      );
    return value;
  }
};
var Enum2 = Object.assign((type, value) => {
  return {
    type,
    value
  };
}, discriminant);
var _Enum = new Proxy(
  {},
  {
    get(_, prop) {
      return (value) => Enum2(prop, value);
    }
  }
);

// src/codecs/scale/Variant.ts
var VariantEnc = (...args) => {
  const enc3 = import_scale_ts10.Enum.enc(...args);
  return (v) => enc3({ tag: v.type, value: v.value });
};
var VariantDec = (...args) => {
  const dec3 = import_scale_ts10.Enum.dec(...args);
  return (v) => {
    const { tag, value } = dec3(v);
    return Enum2(tag, value);
  };
};
var Variant = (inner, ...args) => (0, import_scale_ts10.createCodec)(
  VariantEnc(
    (0, import_utils3.mapObject)(inner, ([encoder]) => encoder),
    ...args
  ),
  VariantDec(
    (0, import_utils3.mapObject)(inner, ([, decoder]) => decoder),
    ...args
  )
);
Variant.enc = VariantEnc;
Variant.dec = VariantDec;

// src/codecs/scale/ethAccount.ts
var import_utils4 = require("@polkadot-api/utils");
var import_scale_ts11 = require("scale-ts");
var import_sha3 = require("@noble/hashes/sha3");
var getFormattedAddress = (hexAddress) => {
  const nonChecksum = hexAddress.slice(2);
  const hashedAddress = (0, import_utils4.toHex)((0, import_sha3.keccak_256)(nonChecksum)).slice(2);
  const result = new Array(40);
  for (let i = 0; i < 40; i++) {
    const checksumVal = parseInt(hashedAddress[i], 16);
    const char2 = nonChecksum[i];
    result[i] = checksumVal > 7 ? char2.toUpperCase() : char2;
  }
  return `0x${result.join("")}`;
};
var bytes20Dec = (0, import_scale_ts11.Bytes)(20)[1];
var ethAccount = (0, import_scale_ts11.createCodec)(
  (input) => {
    const bytes = (0, import_utils4.fromHex)(input);
    if (bytes.length !== 20)
      throw new Error(`Invalid length found on EthAddress(${input})`);
    const hexAddress = (0, import_utils4.toHex)(bytes);
    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes;
    if (getFormattedAddress(hexAddress) !== input)
      throw new Error(`Invalid checksum found on EthAddress(${input})`);
    return bytes;
  },
  (0, import_scale_ts11.createDecoder)((bytes) => getFormattedAddress((0, import_utils4.toHex)(bytes20Dec(bytes))))
);

// src/codecs/blockHeader.ts
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var fourChars = (0, import_scale_ts8.enhanceCodec)(
  (0, import_scale_ts8.Bytes)(4),
  textEncoder3.encode.bind(textEncoder3),
  textDecoder3.decode.bind(textDecoder3)
);
var diggestVal = (0, import_scale_ts8.Struct)({
  engine: fourChars,
  payload: Hex()
});
var diggest = Variant(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: import_scale_ts8._void
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = (0, import_scale_ts8.Struct)({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: (0, import_scale_ts8.Vector)(diggest)
});

// src/codecs/metadata/metadata.ts
var import_scale_ts18 = require("scale-ts");

// src/codecs/metadata/v15.ts
var import_scale_ts16 = require("scale-ts");

// src/codecs/metadata/lookup.ts
var import_scale_ts13 = require("scale-ts");

// src/codecs/metadata/docs.ts
var import_scale_ts12 = require("scale-ts");
var docs = (0, import_scale_ts12.Vector)(import_scale_ts12.str);

// src/codecs/metadata/lookup.ts
var oStr = (0, import_scale_ts13.Option)(import_scale_ts13.str);
var primitive = (0, import_scale_ts13.Enum)({
  bool: import_scale_ts13._void,
  char: import_scale_ts13._void,
  str: import_scale_ts13._void,
  u8: import_scale_ts13._void,
  u16: import_scale_ts13._void,
  u32: import_scale_ts13._void,
  u64: import_scale_ts13._void,
  u128: import_scale_ts13._void,
  u256: import_scale_ts13._void,
  i8: import_scale_ts13._void,
  i16: import_scale_ts13._void,
  i32: import_scale_ts13._void,
  i64: import_scale_ts13._void,
  i128: import_scale_ts13._void,
  i256: import_scale_ts13._void
});
var fields = (0, import_scale_ts13.Vector)(
  (0, import_scale_ts13.Struct)({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs
  })
);
var arr = (0, import_scale_ts13.Struct)({
  len: import_scale_ts13.u32,
  type: compactNumber
});
var bitSequence2 = (0, import_scale_ts13.Struct)({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = (0, import_scale_ts13.Vector)(
  (0, import_scale_ts13.Struct)({
    name: import_scale_ts13.str,
    fields,
    index: import_scale_ts13.u8,
    docs
  })
);
var def = (0, import_scale_ts13.Enum)({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: (0, import_scale_ts13.Vector)(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence: bitSequence2
});
var param = (0, import_scale_ts13.Struct)({
  name: import_scale_ts13.str,
  type: (0, import_scale_ts13.Option)(compactNumber)
});
var params = (0, import_scale_ts13.Vector)(param);
var entry = (0, import_scale_ts13.Struct)({
  id: compactNumber,
  path: docs,
  params,
  def,
  docs
});
var lookup = (0, import_scale_ts13.Vector)(entry);

// src/codecs/metadata/pallets.ts
var import_scale_ts14 = require("scale-ts");
var hashType = (0, import_scale_ts14.Enum)({
  Blake2128: import_scale_ts14._void,
  Blake2256: import_scale_ts14._void,
  Blake2128Concat: import_scale_ts14._void,
  Twox128: import_scale_ts14._void,
  Twox256: import_scale_ts14._void,
  Twox64Concat: import_scale_ts14._void,
  Identity: import_scale_ts14._void
});
var hashers = (0, import_scale_ts14.Vector)(hashType);
var storageMap = (0, import_scale_ts14.Struct)({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = (0, import_scale_ts14.Struct)({
  name: import_scale_ts14.str,
  modifier: import_scale_ts14.u8,
  type: (0, import_scale_ts14.Enum)({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs
});
var storage = (0, import_scale_ts14.Option)(
  (0, import_scale_ts14.Struct)({
    prefix: import_scale_ts14.str,
    items: (0, import_scale_ts14.Vector)(storageItem)
  })
);
var v14Pallet = {
  name: import_scale_ts14.str,
  storage,
  calls: (0, import_scale_ts14.Option)(compactNumber),
  events: (0, import_scale_ts14.Option)(compactNumber),
  constants: (0, import_scale_ts14.Vector)(
    (0, import_scale_ts14.Struct)({
      name: import_scale_ts14.str,
      type: compactNumber,
      value: Hex(),
      docs
    })
  ),
  errors: (0, import_scale_ts14.Option)(compactNumber),
  index: import_scale_ts14.u8
};
var v15Pallet = {
  ...v14Pallet,
  docs
};

// src/codecs/metadata/runtime-api.ts
var import_scale_ts15 = require("scale-ts");
var runtimeApi = (0, import_scale_ts15.Struct)({
  name: import_scale_ts15.str,
  methods: (0, import_scale_ts15.Vector)(
    (0, import_scale_ts15.Struct)({
      name: import_scale_ts15.str,
      inputs: (0, import_scale_ts15.Vector)(
        (0, import_scale_ts15.Struct)({
          name: import_scale_ts15.str,
          type: compactNumber
        })
      ),
      output: compactNumber,
      docs
    })
  ),
  docs
});

// src/codecs/metadata/v15.ts
var extrinsic = (0, import_scale_ts16.Struct)({
  version: import_scale_ts16.u8,
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  extra: compactNumber,
  signedExtensions: (0, import_scale_ts16.Vector)(
    (0, import_scale_ts16.Struct)({
      identifier: import_scale_ts16.str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v15 = (0, import_scale_ts16.Struct)({
  lookup,
  pallets: (0, import_scale_ts16.Vector)((0, import_scale_ts16.Struct)(v15Pallet)),
  extrinsic,
  type: compactNumber,
  apis: (0, import_scale_ts16.Vector)(runtimeApi),
  outerEnums: (0, import_scale_ts16.Struct)({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: (0, import_scale_ts16.Vector)((0, import_scale_ts16.Tuple)(import_scale_ts16.str, (0, import_scale_ts16.Struct)({ type: compactNumber, value: Hex() })))
});

// src/codecs/metadata/v14.ts
var import_scale_ts17 = require("scale-ts");
var empty = new Uint8Array();
var Always = (value) => (0, import_scale_ts17.createCodec)(
  () => empty,
  () => value
);
var extrinsic2 = (0, import_scale_ts17.Struct)({
  type: compactNumber,
  version: import_scale_ts17.u8,
  signedExtensions: (0, import_scale_ts17.Vector)(
    (0, import_scale_ts17.Struct)({
      identifier: import_scale_ts17.str,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = (0, import_scale_ts17.Struct)({
  lookup,
  pallets: (0, import_scale_ts17.Vector)((0, import_scale_ts17.Struct)({ ...v14Pallet, docs: Always([]) })),
  extrinsic: extrinsic2,
  type: compactNumber,
  apis: Always([])
});

// src/codecs/metadata/metadata.ts
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = (0, import_scale_ts18.createCodec)(
  unsupportedFn,
  unsupportedFn
);
var metadata = (0, import_scale_ts18.Struct)({
  magicNumber: import_scale_ts18.u32,
  metadata: (0, import_scale_ts18.Enum)({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14,
    v15
  })
});

// src/hashes/blake2.ts
var import_utils5 = require("@polkadot-api/utils");
var import_blake2b2 = require("@noble/hashes/blake2b");
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => (0, import_blake2b2.blake2b)(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => (0, import_blake2b2.blake2b)(encoded, len16);
var Blake2128Concat = (encoded) => (0, import_utils5.mergeUint8)(Blake2128(encoded), encoded);

// src/hashes/blake3.ts
var import_utils6 = require("@polkadot-api/utils");
var import_blake3 = require("@noble/hashes/blake3");
var len322 = { dkLen: 32 };
var Blake3256 = (encoded) => (0, import_blake3.blake3)(encoded, len322);
var Blake3256Concat = (encoded) => (0, import_utils6.mergeUint8)(Blake3256(encoded), encoded);

// src/hashes/identity.ts
var Identity = (encoded) => encoded;

// src/hashes/twoX.ts
var import_utils7 = require("@polkadot-api/utils");
var import_scale_ts19 = require("scale-ts");

// src/hashes/h64.ts
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add(add(seed, PRIME64_1), PRIME64_2);
  let v2 = add(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen) return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add(result, rotl(v2, 7n));
    result = add(result, rotl(v3, 12n));
    result = add(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add(seed, PRIME64_5);
  }
  result = add(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// src/hashes/twoX.ts
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => (0, import_utils7.mergeUint8)(import_scale_ts19.u64.enc(h64(encoded)), encoded);

// src/storage.ts
var import_utils8 = require("@polkadot-api/utils");
var textEncoder4 = new TextEncoder();
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder4.encode(pallet));
  return (name, dec3, ...encoders) => {
    const palletItemEncoded = (0, import_utils8.mergeUint8)(
      palledEncoded,
      Twox128(textEncoder4.encode(name))
    );
    const palletItemEncodedHex = (0, import_utils8.toHex)(palletItemEncoded);
    const bytesToSkip = encoders.map((e) => e[1]).map((x) => {
      if (x === Identity) return 0;
      if (x === Twox64Concat) return 8;
      if (x === Blake2128Concat) return 16;
      return null;
    }).filter(Boolean);
    const keyDecoder = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (bytesToSkip.length !== encoders.length)
        throw new Error("Impossible to decode this key");
      if (encoders.length === 0) return [];
      const argsKey = key.slice(palletItemEncodedHex.length);
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {
        const codec = encoders[i][0];
        cur += bytesToSkip[i];
        result[i] = codec.dec(argsKey.slice(cur * 2));
        cur += codec.enc(result[i]).length;
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc4 }, hash]) => (val) => hash(enc4(val))
    );
    const enc3 = (...args) => (0, import_utils8.toHex)(
      (0, import_utils8.mergeUint8)(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc3,
      dec: dec3,
      keyDecoder
    };
  };
};
//# sourceMappingURL=index.js.map