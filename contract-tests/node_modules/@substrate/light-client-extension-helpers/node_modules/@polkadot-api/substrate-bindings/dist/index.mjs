var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/codecs/scale/AccountId.ts
import { Bytes, enhanceCodec } from "scale-ts";

// src/utils/ss58-util.ts
import { base58 } from "@scure/base";
import { blake2b } from "@noble/hashes/blake2b";
var SS58_PREFIX = new TextEncoder().encode("SS58PRE");
var CHECKSUM_LENGTH = 2;
var getSs58AddressInfo = (address) => {
  try {
    const decoded = base58.decode(address);
    const prefixBytes = decoded.subarray(0, decoded[0] & 64 ? 2 : 1);
    const publicKey = decoded.subarray(
      prefixBytes.length,
      decoded.length - CHECKSUM_LENGTH
    );
    const checksum = decoded.subarray(prefixBytes.length + publicKey.length);
    const expectedChecksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    const isChecksumValid = checksum[0] === expectedChecksum[0] && checksum[1] === expectedChecksum[1];
    if (!isChecksumValid) return { isValid: false };
    return {
      isValid: true,
      ss58Format: prefixBytesToNumber(prefixBytes),
      publicKey: publicKey.slice()
    };
  } catch (_) {
    return { isValid: false };
  }
};
var prefixBytesToNumber = (bytes) => {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  return dv.byteLength === 1 ? dv.getUint8(0) : dv.getUint16(0);
};
var fromBufferToBase58 = (ss58Format) => {
  const prefixBytes = ss58Format < 64 ? Uint8Array.of(ss58Format) : Uint8Array.of(
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  );
  return (publicKey) => {
    const checksum = blake2b(
      Uint8Array.of(...SS58_PREFIX, ...prefixBytes, ...publicKey),
      {
        dkLen: 64
      }
    ).subarray(0, CHECKSUM_LENGTH);
    return base58.encode(
      Uint8Array.of(...prefixBytes, ...publicKey, ...checksum)
    );
  };
};

// src/codecs/scale/AccountId.ts
function fromBase58ToBuffer(nBytes, _ss58Format) {
  return (address) => {
    const info = getSs58AddressInfo(address);
    if (!info.isValid) throw new Error("Invalid checksum");
    const { publicKey } = info;
    if (publicKey.length !== nBytes)
      throw new Error("Invalid public key length");
    return publicKey;
  };
}
var AccountId = (ss58Format = 42, nBytes = 32) => enhanceCodec(
  Bytes(nBytes),
  fromBase58ToBuffer(nBytes, ss58Format),
  fromBufferToBase58(ss58Format)
);

// src/codecs/scale/Binary.ts
import { Bytes as Bytes2, createCodec } from "scale-ts";
import { fromHex, toHex } from "@polkadot-api/utils";
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var _bytes, _hex, _str;
var _Binary = class _Binary {
  constructor(data) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _str, null);
    __publicField(this, "asText", () => __privateGet(this, _str) === null ? __privateSet(this, _str, textDecoder.decode(__privateGet(this, _bytes))) : __privateGet(this, _str));
    __publicField(this, "asHex", () => __privateGet(this, _hex) === null ? __privateSet(this, _hex, toHex(__privateGet(this, _bytes))) : __privateGet(this, _hex));
    __publicField(this, "asBytes", () => __privateGet(this, _bytes));
    __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new _Binary(textEncoder.encode(input));
  }
  static fromHex(input) {
    return new _Binary(fromHex(input));
  }
  static fromBytes(input) {
    return new _Binary(input);
  }
};
_bytes = new WeakMap();
_hex = new WeakMap();
_str = new WeakMap();
var Binary = _Binary;
var FixedSizeBinary = class _FixedSizeBinary extends Binary {
  constructor(data) {
    super(data);
  }
  static fromArray(input) {
    return new _FixedSizeBinary(new Uint8Array(input));
  }
};
var enc = (nBytes) => {
  const _enc = Bytes2.enc(nBytes);
  return (value) => _enc(value.asBytes());
};
var dec = (nBytes) => {
  const _dec = Bytes2.dec(nBytes);
  return (value) => Binary.fromBytes(_dec(value));
};
var Bin = (nBytes) => createCodec(enc(nBytes), dec(nBytes));
Bin.enc = enc;
Bin.dec = dec;

// src/codecs/scale/bitSequence.ts
import { Bytes as Bytes3, createCodec as createCodec2, createDecoder } from "scale-ts";

// src/codecs/scale/compact.ts
import { compact } from "scale-ts";
var compactNumber = compact;
var compactBn = compact;

// src/codecs/scale/bitSequence.ts
var bitSequenceDecoder = createDecoder((data) => {
  const bitsLen = compactNumber.dec(data);
  const bytesLen = Math.ceil(bitsLen / 8);
  const bytes = Bytes3(bytesLen).dec(data);
  return { bytes, bitsLen };
});
var bitSequenceEncoder = (input) => {
  if (input.bitsLen > input.bytes.length * 8)
    throw new Error(
      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`
    );
  const lenEncoded = compactNumber.enc(input.bitsLen);
  const result = new Uint8Array(input.bytes.length + lenEncoded.length);
  result.set(lenEncoded, 0);
  result.set(input.bytes, lenEncoded.length);
  return result;
};
var bitSequence = createCodec2(bitSequenceEncoder, bitSequenceDecoder);

// src/codecs/scale/char.ts
import { enhanceCodec as enhanceCodec2, u8 } from "scale-ts";
var char = enhanceCodec2(
  u8,
  (str8) => str8.charCodeAt(0),
  String.fromCharCode
);

// src/codecs/scale/Hex.ts
import { fromHex as fromHex2, toHex as toHex2 } from "@polkadot-api/utils";
import { Bytes as Bytes4, createCodec as createCodec3 } from "scale-ts";
var enc2 = (nBytes) => {
  const _enc = Bytes4.enc(nBytes);
  return (value) => _enc(fromHex2(value));
};
var dec2 = (nBytes) => {
  const _dec = Bytes4.dec(nBytes);
  return (value) => toHex2(_dec(value));
};
var Hex = (nBytes) => createCodec3(enc2(nBytes), dec2(nBytes));
Hex.enc = enc2;
Hex.dec = dec2;

// src/codecs/scale/fixed-str.ts
import { Bytes as Bytes5, enhanceCodec as enhanceCodec3 } from "scale-ts";
var textEncoder2 = new TextEncoder();
var textDecoder2 = new TextDecoder();
var fixedStr = (nBytes) => enhanceCodec3(
  Bytes5(nBytes),
  (str8) => textEncoder2.encode(str8),
  (bytes) => textDecoder2.decode(bytes)
);

// src/codecs/scale/re-exported.ts
import {
  _void,
  bool,
  compact as compact2,
  str,
  u8 as u82,
  u16,
  u32,
  u64,
  u128,
  u256,
  i8,
  i16,
  i32,
  i64,
  i128,
  i256,
  Option,
  Result,
  Vector,
  Tuple,
  Struct,
  Bytes as Bytes6,
  Enum,
  enhanceCodec as enhanceCodec4,
  enhanceEncoder,
  enhanceDecoder,
  createCodec as createCodec4,
  createDecoder as createDecoder2
} from "scale-ts";

// src/codecs/scale/Self.ts
import { createCodec as createCodec5 } from "scale-ts";
var selfEncoder = (value) => {
  let cache = (x) => {
    const encoder = value();
    cache = encoder;
    return encoder(x);
  };
  return (x) => cache(x);
};
var selfDecoder = (value) => {
  let cache = (x) => {
    const decoder = value();
    const result = decoder;
    cache = decoder;
    return result(x);
  };
  return (x) => cache(x);
};
var Self = (value) => createCodec5(
  selfEncoder(() => value().enc),
  selfDecoder(() => value().dec)
);

// src/codecs/scale/Variant.ts
import {
  Enum as ScaleEnum,
  createCodec as createCodec6
} from "scale-ts";
import { mapObject } from "@polkadot-api/utils";

// src/types/enum.ts
var discriminant = {
  is(value, type) {
    return value.type === type;
  },
  as(value, type) {
    if (type !== value.type)
      throw new Error(
        `Enum.as(enum, ${type}) used with actual type ${value.type}`
      );
    return value;
  }
};
var Enum2 = Object.assign((type, value) => {
  return {
    type,
    value
  };
}, discriminant);
var _Enum = new Proxy(
  {},
  {
    get(_, prop) {
      return (value) => Enum2(prop, value);
    }
  }
);

// src/codecs/scale/Variant.ts
var VariantEnc = (...args) => {
  const enc3 = ScaleEnum.enc(...args);
  return (v) => enc3({ tag: v.type, value: v.value });
};
var VariantDec = (...args) => {
  const dec3 = ScaleEnum.dec(...args);
  return (v) => {
    const { tag, value } = dec3(v);
    return Enum2(tag, value);
  };
};
var Variant = (inner, ...args) => createCodec6(
  VariantEnc(
    mapObject(inner, ([encoder]) => encoder),
    ...args
  ),
  VariantDec(
    mapObject(inner, ([, decoder]) => decoder),
    ...args
  )
);
Variant.enc = VariantEnc;
Variant.dec = VariantDec;

// src/codecs/scale/ethAccount.ts
import { fromHex as fromHex3, toHex as toHex3 } from "@polkadot-api/utils";
import { Bytes as Bytes7, createCodec as createCodec7, createDecoder as createDecoder3 } from "scale-ts";
import { keccak_256 as keccak } from "@noble/hashes/sha3";
var getFormattedAddress = (hexAddress) => {
  const nonChecksum = hexAddress.slice(2);
  const hashedAddress = toHex3(keccak(nonChecksum)).slice(2);
  const result = new Array(40);
  for (let i = 0; i < 40; i++) {
    const checksumVal = parseInt(hashedAddress[i], 16);
    const char2 = nonChecksum[i];
    result[i] = checksumVal > 7 ? char2.toUpperCase() : char2;
  }
  return `0x${result.join("")}`;
};
var bytes20Dec = Bytes7(20)[1];
var ethAccount = createCodec7(
  (input) => {
    const bytes = fromHex3(input);
    if (bytes.length !== 20)
      throw new Error(`Invalid length found on EthAddress(${input})`);
    const hexAddress = toHex3(bytes);
    if (input === hexAddress || input === hexAddress.toUpperCase()) return bytes;
    if (getFormattedAddress(hexAddress) !== input)
      throw new Error(`Invalid checksum found on EthAddress(${input})`);
    return bytes;
  },
  createDecoder3((bytes) => getFormattedAddress(toHex3(bytes20Dec(bytes))))
);

// src/codecs/blockHeader.ts
var textEncoder3 = new TextEncoder();
var textDecoder3 = new TextDecoder();
var fourChars = enhanceCodec4(
  Bytes6(4),
  textEncoder3.encode.bind(textEncoder3),
  textDecoder3.decode.bind(textDecoder3)
);
var diggestVal = Struct({
  engine: fourChars,
  payload: Hex()
});
var diggest = Variant(
  {
    consensus: diggestVal,
    seal: diggestVal,
    preRuntime: diggestVal,
    runtimeUpdated: _void
  },
  [4, 5, 6, 8]
);
var hex32 = Hex(32);
var blockHeader = Struct({
  parentHash: hex32,
  number: compactNumber,
  stateRoot: hex32,
  extrinsicRoot: hex32,
  digests: Vector(diggest)
});

// src/codecs/metadata/metadata.ts
import { Enum as Enum5, Struct as Struct7, u32 as u323, createCodec as createCodec9 } from "scale-ts";

// src/codecs/metadata/v15.ts
import { Struct as Struct5, Tuple as Tuple2, Vector as Vector6, str as str6, u8 as u85 } from "scale-ts";

// src/codecs/metadata/lookup.ts
import {
  Enum as Enum3,
  Option as Option2,
  Struct as Struct2,
  Vector as Vector3,
  _void as _void3,
  str as str3,
  u32 as u322,
  u8 as u83
} from "scale-ts";

// src/codecs/metadata/docs.ts
import { Vector as Vector2, str as str2 } from "scale-ts";
var docs = Vector2(str2);

// src/codecs/metadata/lookup.ts
var oStr = Option2(str3);
var primitive = Enum3({
  bool: _void3,
  char: _void3,
  str: _void3,
  u8: _void3,
  u16: _void3,
  u32: _void3,
  u64: _void3,
  u128: _void3,
  u256: _void3,
  i8: _void3,
  i16: _void3,
  i32: _void3,
  i64: _void3,
  i128: _void3,
  i256: _void3
});
var fields = Vector3(
  Struct2({
    name: oStr,
    type: compactNumber,
    typeName: oStr,
    docs
  })
);
var arr = Struct2({
  len: u322,
  type: compactNumber
});
var bitSequence2 = Struct2({
  bitStoreType: compactNumber,
  bitOrderType: compactNumber
});
var variant = Vector3(
  Struct2({
    name: str3,
    fields,
    index: u83,
    docs
  })
);
var def = Enum3({
  composite: fields,
  variant,
  sequence: compactNumber,
  array: arr,
  tuple: Vector3(compactNumber),
  primitive,
  compact: compactNumber,
  bitSequence: bitSequence2
});
var param = Struct2({
  name: str3,
  type: Option2(compactNumber)
});
var params = Vector3(param);
var entry = Struct2({
  id: compactNumber,
  path: docs,
  params,
  def,
  docs
});
var lookup = Vector3(entry);

// src/codecs/metadata/pallets.ts
import { Struct as Struct3, Option as Option3, Vector as Vector4, u8 as u84, str as str4, Enum as Enum4, _void as _void4 } from "scale-ts";
var hashType = Enum4({
  Blake2128: _void4,
  Blake2256: _void4,
  Blake2128Concat: _void4,
  Twox128: _void4,
  Twox256: _void4,
  Twox64Concat: _void4,
  Identity: _void4
});
var hashers = Vector4(hashType);
var storageMap = Struct3({
  hashers,
  key: compactNumber,
  value: compactNumber
});
var storageItem = Struct3({
  name: str4,
  modifier: u84,
  type: Enum4({
    plain: compactNumber,
    map: storageMap
  }),
  fallback: Hex(),
  docs
});
var storage = Option3(
  Struct3({
    prefix: str4,
    items: Vector4(storageItem)
  })
);
var v14Pallet = {
  name: str4,
  storage,
  calls: Option3(compactNumber),
  events: Option3(compactNumber),
  constants: Vector4(
    Struct3({
      name: str4,
      type: compactNumber,
      value: Hex(),
      docs
    })
  ),
  errors: Option3(compactNumber),
  index: u84
};
var v15Pallet = {
  ...v14Pallet,
  docs
};

// src/codecs/metadata/runtime-api.ts
import { Struct as Struct4, Vector as Vector5, str as str5 } from "scale-ts";
var runtimeApi = Struct4({
  name: str5,
  methods: Vector5(
    Struct4({
      name: str5,
      inputs: Vector5(
        Struct4({
          name: str5,
          type: compactNumber
        })
      ),
      output: compactNumber,
      docs
    })
  ),
  docs
});

// src/codecs/metadata/v15.ts
var extrinsic = Struct5({
  version: u85,
  address: compactNumber,
  call: compactNumber,
  signature: compactNumber,
  extra: compactNumber,
  signedExtensions: Vector6(
    Struct5({
      identifier: str6,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v15 = Struct5({
  lookup,
  pallets: Vector6(Struct5(v15Pallet)),
  extrinsic,
  type: compactNumber,
  apis: Vector6(runtimeApi),
  outerEnums: Struct5({
    call: compactNumber,
    event: compactNumber,
    error: compactNumber
  }),
  custom: Vector6(Tuple2(str6, Struct5({ type: compactNumber, value: Hex() })))
});

// src/codecs/metadata/v14.ts
import { Struct as Struct6, Vector as Vector7, createCodec as createCodec8, str as str7, u8 as u86 } from "scale-ts";
var empty = new Uint8Array();
var Always = (value) => createCodec8(
  () => empty,
  () => value
);
var extrinsic2 = Struct6({
  type: compactNumber,
  version: u86,
  signedExtensions: Vector7(
    Struct6({
      identifier: str7,
      type: compactNumber,
      additionalSigned: compactNumber
    })
  )
});
var v14 = Struct6({
  lookup,
  pallets: Vector7(Struct6({ ...v14Pallet, docs: Always([]) })),
  extrinsic: extrinsic2,
  type: compactNumber,
  apis: Always([])
});

// src/codecs/metadata/metadata.ts
var unsupportedFn = () => {
  throw new Error("Unsupported metadata version!");
};
var unsupported = createCodec9(
  unsupportedFn,
  unsupportedFn
);
var metadata = Struct7({
  magicNumber: u323,
  metadata: Enum5({
    v0: unsupported,
    v1: unsupported,
    v2: unsupported,
    v3: unsupported,
    v4: unsupported,
    v5: unsupported,
    v6: unsupported,
    v7: unsupported,
    v8: unsupported,
    v9: unsupported,
    v10: unsupported,
    v11: unsupported,
    v12: unsupported,
    v13: unsupported,
    v14,
    v15
  })
});

// src/hashes/blake2.ts
import { mergeUint8 } from "@polkadot-api/utils";
import { blake2b as blake2b2 } from "@noble/hashes/blake2b";
var len32 = { dkLen: 32 };
var Blake2256 = (encoded) => blake2b2(encoded, len32);
var len16 = { dkLen: 16 };
var Blake2128 = (encoded) => blake2b2(encoded, len16);
var Blake2128Concat = (encoded) => mergeUint8(Blake2128(encoded), encoded);

// src/hashes/blake3.ts
import { mergeUint8 as mergeUint82 } from "@polkadot-api/utils";
import { blake3 } from "@noble/hashes/blake3";
var len322 = { dkLen: 32 };
var Blake3256 = (encoded) => blake3(encoded, len322);
var Blake3256Concat = (encoded) => mergeUint82(Blake3256(encoded), encoded);

// src/hashes/identity.ts
var Identity = (encoded) => encoded;

// src/hashes/twoX.ts
import { mergeUint8 as mergeUint83 } from "@polkadot-api/utils";
import { u64 as u642 } from "scale-ts";

// src/hashes/h64.ts
var bigintFromU16 = (v0, v1, v2, v3) => new DataView(new Uint16Array([v0, v1, v2, v3]).buffer).getBigUint64(0, true);
var MASK_64 = 2n ** 64n - 1n;
var rotl = (input, nBits) => input << nBits & MASK_64 | input >> 64n - nBits;
var multiply = (a, b) => a * b & MASK_64;
var add = (a, b) => a + b & MASK_64;
var PRIME64_1 = 11400714785074694791n;
var PRIME64_2 = 14029467366897019727n;
var PRIME64_3 = 1609587929392839161n;
var PRIME64_4 = 9650029242287828579n;
var PRIME64_5 = 2870177450012600261n;
function h64(input, seed = 0n) {
  let v1 = add(add(seed, PRIME64_1), PRIME64_2);
  let v2 = add(seed, PRIME64_2);
  let v3 = seed;
  let v4 = seed - PRIME64_1;
  let totalLen = input.length;
  let memsize = 0;
  let memory = null;
  (function update() {
    let p2 = 0;
    let bEnd = p2 + totalLen;
    if (!totalLen) return;
    memory = new Uint8Array(32);
    if (totalLen < 32) {
      memory.set(input.subarray(0, totalLen), memsize);
      memsize += totalLen;
      return;
    }
    if (p2 <= bEnd - 32) {
      const limit = bEnd - 32;
      do {
        let other;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v1 = multiply(rotl(add(v1, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v2 = multiply(rotl(add(v2, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v3 = multiply(rotl(add(v3, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
        other = bigintFromU16(
          input[p2 + 1] << 8 | input[p2],
          input[p2 + 3] << 8 | input[p2 + 2],
          input[p2 + 5] << 8 | input[p2 + 4],
          input[p2 + 7] << 8 | input[p2 + 6]
        );
        v4 = multiply(rotl(add(v4, multiply(other, PRIME64_2)), 31n), PRIME64_1);
        p2 += 8;
      } while (p2 <= limit);
    }
    if (p2 < bEnd) {
      memory.set(input.subarray(p2, bEnd), memsize);
      memsize = bEnd - p2;
    }
  })();
  input = memory || input;
  let result;
  let p = 0;
  if (totalLen >= 32) {
    result = rotl(v1, 1n);
    result = add(result, rotl(v2, 7n));
    result = add(result, rotl(v3, 12n));
    result = add(result, rotl(v4, 18n));
    v1 = multiply(rotl(multiply(v1, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v1;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v2 = multiply(rotl(multiply(v2, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v2;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v3 = multiply(rotl(multiply(v3, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v3;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
    v4 = multiply(rotl(multiply(v4, PRIME64_2), 31n), PRIME64_1);
    result = result ^ v4;
    result = add(multiply(result, PRIME64_1), PRIME64_4);
  } else {
    result = add(seed, PRIME64_5);
  }
  result = add(result, BigInt(totalLen));
  while (p <= memsize - 8) {
    let temp2 = bigintFromU16(
      input[p + 1] << 8 | input[p],
      input[p + 3] << 8 | input[p + 2],
      input[p + 5] << 8 | input[p + 4],
      input[p + 7] << 8 | input[p + 6]
    );
    temp2 = multiply(rotl(multiply(temp2, PRIME64_2), 31n), PRIME64_1);
    result = add(multiply(rotl(result ^ temp2, 27n), PRIME64_1), PRIME64_4);
    p += 8;
  }
  if (p + 4 <= memsize) {
    let temp2 = multiply(
      bigintFromU16(
        input[p + 1] << 8 | input[p],
        input[p + 3] << 8 | input[p + 2],
        0,
        0
      ),
      PRIME64_1
    );
    result = add(multiply(rotl(result ^ temp2, 23n), PRIME64_2), PRIME64_3);
    p += 4;
  }
  while (p < memsize) {
    const temp2 = multiply(bigintFromU16(input[p++], 0, 0, 0), PRIME64_5);
    result = multiply(rotl(result ^ temp2, 11n), PRIME64_1);
  }
  let temp = result >> 33n;
  result = multiply(result ^ temp, PRIME64_2);
  temp = result >> 29n;
  result = multiply(result ^ temp, PRIME64_3);
  temp = result >> 32n;
  result ^= temp;
  return result;
}

// src/hashes/twoX.ts
var Twox128 = (input) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  return result;
};
var Twox256 = (input) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigUint64(0, h64(input), true);
  dv.setBigUint64(8, h64(input, 1n), true);
  dv.setBigUint64(16, h64(input, 2n), true);
  dv.setBigUint64(24, h64(input, 3n), true);
  return result;
};
var Twox64Concat = (encoded) => mergeUint83(u642.enc(h64(encoded)), encoded);

// src/storage.ts
import { mergeUint8 as mergeUint84, toHex as toHex4 } from "@polkadot-api/utils";
var textEncoder4 = new TextEncoder();
var Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder4.encode(pallet));
  return (name, dec3, ...encoders) => {
    const palletItemEncoded = mergeUint84(
      palledEncoded,
      Twox128(textEncoder4.encode(name))
    );
    const palletItemEncodedHex = toHex4(palletItemEncoded);
    const bytesToSkip = encoders.map((e) => e[1]).map((x) => {
      if (x === Identity) return 0;
      if (x === Twox64Concat) return 8;
      if (x === Blake2128Concat) return 16;
      return null;
    }).filter(Boolean);
    const keyDecoder = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (bytesToSkip.length !== encoders.length)
        throw new Error("Impossible to decode this key");
      if (encoders.length === 0) return [];
      const argsKey = key.slice(palletItemEncodedHex.length);
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < bytesToSkip.length; i++) {
        const codec = encoders[i][0];
        cur += bytesToSkip[i];
        result[i] = codec.dec(argsKey.slice(cur * 2));
        cur += codec.enc(result[i]).length;
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc4 }, hash]) => (val) => hash(enc4(val))
    );
    const enc3 = (...args) => toHex4(
      mergeUint84(palletItemEncoded, ...args.map((val, idx) => fns[idx](val)))
    );
    return {
      enc: enc3,
      dec: dec3,
      keyDecoder
    };
  };
};
export {
  AccountId,
  Bin,
  Binary,
  Blake2128,
  Blake2128Concat,
  Blake2256,
  Blake3256,
  Blake3256Concat,
  Bytes6 as Bytes,
  Enum2 as Enum,
  FixedSizeBinary,
  Hex,
  Identity,
  Option,
  Result,
  Enum as ScaleEnum,
  Self,
  Storage,
  Struct,
  Tuple,
  Twox128,
  Twox256,
  Twox64Concat,
  Variant,
  Vector,
  _Enum,
  _void,
  bitSequence,
  blockHeader,
  bool,
  char,
  compact2 as compact,
  compactBn,
  compactNumber,
  createCodec4 as createCodec,
  createDecoder2 as createDecoder,
  enhanceCodec4 as enhanceCodec,
  enhanceDecoder,
  enhanceEncoder,
  ethAccount,
  fixedStr,
  fromBufferToBase58,
  getSs58AddressInfo,
  h64,
  i128,
  i16,
  i256,
  i32,
  i64,
  i8,
  metadata,
  selfDecoder,
  selfEncoder,
  str,
  u128,
  u16,
  u256,
  u32,
  u64,
  u82 as u8,
  v14,
  v15
};
//# sourceMappingURL=index.mjs.map