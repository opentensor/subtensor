import { Var, EnumVar } from '@polkadot-api/metadata-builders';
import * as _polkadot_api_substrate_bindings from '@polkadot-api/substrate-bindings';
import { Enum, Codec, UnifiedMetadata } from '@polkadot-api/substrate-bindings';

interface StructNode {
    type: "struct";
    value: Array<[string, number]>;
}
declare const Primitive: {
    bool: "boolean";
    str: "string";
    num: "number";
    big: "bigint";
    bits: "bitseq";
    void: "void";
};
type PRIMITIVES = (typeof Primitive)[keyof typeof Primitive];
interface TerminalNode {
    type: "terminal";
    value: {
        type: PRIMITIVES;
    };
}
interface EnumNode {
    type: "enum";
    value: Array<[string, Enum<{
        inline: TypedefNode;
        lookup: number;
    }>]>;
}
interface TupleNode {
    type: "tuple";
    value: number[];
}
interface ArrayNode {
    type: "array";
    value: {
        typeRef: number;
        length?: number;
    };
}
interface BinaryNode {
    type: "binary";
    value: number | undefined;
}
interface OptionNode {
    type: "option";
    value: number;
}
interface ResultNode {
    type: "result";
    value: {
        ok: number;
        ko: number;
    };
}
type TypedefNode = StructNode | TerminalNode | EnumNode | TupleNode | ArrayNode | BinaryNode | OptionNode | ResultNode;
declare const TypedefCodec: Codec<TypedefNode>;
declare function mapLookupToTypedef(entry: Var, resolve?: (id: number) => void): TypedefNode;
declare function mapReferences(node: TypedefNode, mapFn: (id: number) => number): TypedefNode;

declare function isCompatible(value: any, destNode: TypedefNode, getNode: (id: number) => TypedefNode): boolean;

declare class DoubleSet<T> {
    private value;
    constructor(values?: Array<[T, T]>);
    has(a: T, b: T): boolean;
    add(a: T, b: T): void;
    addAll(values: Array<[T, T]>): void;
    delete(a: T, b: T): void;
    isEmpty(): boolean;
    get values(): [T, T][];
}

declare enum CompatibilityLevel {
    Incompatible = 0,
    Partial = 1,
    BackwardsCompatible = 2,
    Identical = 3
}
type Change = {
    path: string;
    id: [number | null, number | null];
    level: CompatibilityLevel;
};
type StaticCompatibleResult = {
    level: CompatibilityLevel;
    changes: Array<Change>;
    assumptions: DoubleSet<TypedefNode>;
};
type CompatibilityCache = Map<TypedefNode, Map<TypedefNode, {
    level: CompatibilityLevel;
    changes: Array<Change>;
} | null>>;
declare function isStaticCompatible(originNode: TypedefNode | undefined, getOriginNode: (id: number) => TypedefNode, destNode: TypedefNode | undefined, getDestNode: (id: number) => TypedefNode, cache: CompatibilityCache, deep?: boolean): StaticCompatibleResult;

type EntryPointNode = {
    type: "lookup";
    value: number;
} | {
    type: "typedef";
    value: TypedefNode;
};
declare const voidEntryPointNode: EntryPointNode;
interface EntryPoint {
    args: EntryPointNode;
    values: EntryPointNode;
}
declare const EntryPointCodec: [_polkadot_api_substrate_bindings.Encoder<{
    args: _polkadot_api_substrate_bindings.Enum<{
        lookup: number;
        typedef: TypedefNode;
    }>;
    values: _polkadot_api_substrate_bindings.Enum<{
        lookup: number;
        typedef: TypedefNode;
    }>;
}>, _polkadot_api_substrate_bindings.Decoder<{
    args: _polkadot_api_substrate_bindings.Enum<{
        lookup: number;
        typedef: TypedefNode;
    }>;
    values: _polkadot_api_substrate_bindings.Enum<{
        lookup: number;
        typedef: TypedefNode;
    }>;
}>] & {
    enc: _polkadot_api_substrate_bindings.Encoder<{
        args: _polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>;
        values: _polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>;
    }>;
    dec: _polkadot_api_substrate_bindings.Decoder<{
        args: _polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>;
        values: _polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>;
    }>;
} & {
    inner: {
        args: [_polkadot_api_substrate_bindings.Encoder<_polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>>, _polkadot_api_substrate_bindings.Decoder<_polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>>] & {
            enc: _polkadot_api_substrate_bindings.Encoder<_polkadot_api_substrate_bindings.Enum<{
                lookup: number;
                typedef: TypedefNode;
            }>>;
            dec: _polkadot_api_substrate_bindings.Decoder<_polkadot_api_substrate_bindings.Enum<{
                lookup: number;
                typedef: TypedefNode;
            }>>;
        } & {
            inner: {
                lookup: _polkadot_api_substrate_bindings.Codec<number>;
                typedef: _polkadot_api_substrate_bindings.Codec<TypedefNode>;
            };
        };
        values: [_polkadot_api_substrate_bindings.Encoder<_polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>>, _polkadot_api_substrate_bindings.Decoder<_polkadot_api_substrate_bindings.Enum<{
            lookup: number;
            typedef: TypedefNode;
        }>>] & {
            enc: _polkadot_api_substrate_bindings.Encoder<_polkadot_api_substrate_bindings.Enum<{
                lookup: number;
                typedef: TypedefNode;
            }>>;
            dec: _polkadot_api_substrate_bindings.Decoder<_polkadot_api_substrate_bindings.Enum<{
                lookup: number;
                typedef: TypedefNode;
            }>>;
        } & {
            inner: {
                lookup: _polkadot_api_substrate_bindings.Codec<number>;
                typedef: _polkadot_api_substrate_bindings.Codec<TypedefNode>;
            };
        };
    };
};
declare function storageEntryPoint(storageEntry: Exclude<UnifiedMetadata["pallets"][number]["storage"], undefined>["items"][number]): EntryPoint;
declare function runtimeCallEntryPoint(entry: UnifiedMetadata["apis"][number]["methods"][number]): EntryPoint;
declare function enumValueEntryPointNode(entry: EnumVar["value"][keyof EnumVar["value"]]): EntryPointNode;
declare function singleValueEntryPoint(value: number): EntryPoint;
interface CompatibilityResult {
    level: CompatibilityLevel;
    changes: Array<Change>;
}
declare function entryPointsAreCompatible(descriptorEntry: EntryPoint, getDescriptorNode: (id: number) => TypedefNode, runtimeEntry: EntryPoint, getRuntimeNode: (id: number) => TypedefNode, cache: CompatibilityCache, deep?: boolean): {
    args: CompatibilityResult;
    values: CompatibilityResult;
};
declare function valueIsCompatibleWithDest(dest: EntryPointNode, getDestNode: (id: number) => TypedefNode, value: unknown): boolean;
declare function mapEntryPointReferences(entryPoint: EntryPoint, mapFn: (id: number) => number): EntryPoint;

export { CompatibilityLevel, EntryPointCodec, TypedefCodec, entryPointsAreCompatible, enumValueEntryPointNode, isCompatible, isStaticCompatible, mapEntryPointReferences, mapLookupToTypedef, mapReferences, runtimeCallEntryPoint, singleValueEntryPoint, storageEntryPoint, valueIsCompatibleWithDest, voidEntryPointNode };
export type { CompatibilityCache, CompatibilityResult, EntryPoint, EntryPointNode, StaticCompatibleResult, TypedefNode };
