'use strict';

var substrateBindings = require('@polkadot-api/substrate-bindings');

const smallCompact = substrateBindings.compactNumber;
const StructCodec = substrateBindings.Vector(substrateBindings.Tuple(substrateBindings.str, smallCompact));
const Primitive = {
  bool: "boolean",
  str: "string",
  num: "number",
  big: "bigint",
  bits: "bitseq",
  void: "void"
};
const TerminalCodec = substrateBindings.Variant(
  Object.fromEntries(
    Object.values(Primitive).map((p) => [p, substrateBindings._void])
  )
);
const EnumCodec = substrateBindings.Vector(
  substrateBindings.Tuple(
    substrateBindings.str,
    substrateBindings.Variant({
      inline: substrateBindings.Self(() => TypedefCodec),
      lookup: smallCompact
    })
  )
);
const TupleCodec = substrateBindings.Vector(smallCompact);
const ArrayCodec = substrateBindings.Struct({
  typeRef: smallCompact,
  length: substrateBindings.Option(smallCompact)
});
const BinaryCodec = substrateBindings.Option(smallCompact);
const OptionCodec = smallCompact;
const ResultCodec = substrateBindings.Struct({
  ok: smallCompact,
  ko: smallCompact
});
const TypedefCodec = substrateBindings.Variant({
  struct: StructCodec,
  terminal: TerminalCodec,
  enum: EnumCodec,
  tuple: TupleCodec,
  array: ArrayCodec,
  binary: BinaryCodec,
  option: OptionCodec,
  result: ResultCodec
});
const primitiveToTerminal = {
  i256: Primitive.big,
  i128: Primitive.big,
  i64: Primitive.big,
  i32: Primitive.num,
  i16: Primitive.num,
  i8: Primitive.num,
  u256: Primitive.big,
  u128: Primitive.big,
  u64: Primitive.big,
  u32: Primitive.num,
  u16: Primitive.num,
  u8: Primitive.num,
  bool: Primitive.bool,
  char: Primitive.str,
  str: Primitive.str
};
const terminal = (type) => ({
  type: "terminal",
  value: { type }
});
function mapLookupToTypedef(entry, resolve = () => {
}) {
  switch (entry.type) {
    case "AccountId20":
    case "AccountId32":
      return terminal(Primitive.str);
    case "array":
      if (entry.value.type === "primitive" && entry.value.value === "u8") {
        return { type: "binary", value: entry.len };
      }
      resolve(entry.value.id);
      return {
        type: "array",
        value: {
          typeRef: entry.value.id,
          length: entry.len
        }
      };
    case "bitSequence":
      return terminal(Primitive.bits);
    case "compact":
      return terminal(entry.isBig ? Primitive.big : Primitive.num);
    case "enum":
      return {
        type: "enum",
        value: Object.entries(entry.value).map(
          ([key, params]) => {
            if (params.type !== "lookupEntry")
              return [
                key,
                { type: "inline", value: mapLookupToTypedef(params, resolve) }
              ];
            resolve(params.value.id);
            return [
              key,
              {
                type: "lookup",
                value: params.value.id
              }
            ];
          }
        )
      };
    case "struct": {
      const value = Object.entries(entry.value).map(
        ([key, prop]) => [key, prop.id]
      );
      value.forEach(([, v]) => resolve(v));
      return {
        type: "struct",
        value
      };
    }
    case "tuple": {
      const value = entry.value.map((v) => v.id);
      value.forEach(resolve);
      return {
        type: "tuple",
        value
      };
    }
    case "option":
      resolve(entry.value.id);
      return {
        type: "option",
        value: entry.value.id
      };
    case "primitive":
      return terminal(primitiveToTerminal[entry.value]);
    case "result":
      resolve(entry.value.ok.id);
      resolve(entry.value.ko.id);
      return {
        type: "result",
        value: {
          ok: entry.value.ok.id,
          ko: entry.value.ko.id
        }
      };
    case "sequence":
      if (entry.value.type === "primitive" && entry.value.value === "u8") {
        return { type: "binary", value: void 0 };
      }
      resolve(entry.value.id);
      return {
        type: "array",
        value: { typeRef: entry.value.id }
      };
    case "void":
      return terminal(Primitive.void);
  }
}
function mapReferences(node, mapFn) {
  switch (node.type) {
    case "array":
      return {
        ...node,
        value: {
          ...node.value,
          typeRef: mapFn(node.value.typeRef)
        }
      };
    case "option":
      return { ...node, value: mapFn(node.value) };
    case "result":
      return {
        ...node,
        value: { ok: mapFn(node.value.ok), ko: mapFn(node.value.ko) }
      };
    case "tuple":
      return { ...node, value: node.value.map(mapFn) };
    case "struct":
      return {
        ...node,
        value: node.value.map(([k, v]) => [k, mapFn(v)])
      };
    case "enum": {
      return {
        ...node,
        value: node.value.map(([k, { type, value }]) => [
          k,
          type === "lookup" ? { type, value: mapFn(value) } : { type, value: mapReferences(value, mapFn) }
        ])
      };
    }
    case "binary":
    case "terminal":
      return node;
  }
}

function isCompatible(value, destNode, getNode) {
  if (destNode.type === "option" && value == null) {
    return true;
  }
  const nextCall = (value2, destNode2) => isCompatible(value2, destNode2, getNode);
  const checkTerminal = (terminal) => {
    switch (terminal.value.type) {
      case Primitive.str:
      case Primitive.big:
      case Primitive.bool:
      case Primitive.num:
        return typeof value === terminal.value.type;
      case Primitive.bits:
        return typeof value === "object" && value != null && typeof value.bitsLen === "number" && value.bytes instanceof Uint8Array;
      case Primitive.void:
        return true;
    }
  };
  switch (destNode.type) {
    case "terminal":
      return checkTerminal(destNode);
    case "binary":
      return value instanceof substrateBindings.Binary && (destNode.value == null || value.asBytes().length >= destNode.value);
    case "array":
      if (!Array.isArray(value)) return false;
      const valueArr = value;
      if (destNode.value.length != null && valueArr.length < destNode.value.length) {
        return false;
      }
      return valueArr.slice(0, destNode.value.length).every((value2) => nextCall(value2, getNode(destNode.value.typeRef)));
    case "enum":
      if (!value) return false;
      const valueEnum = value;
      const destVariants = Object.fromEntries(destNode.value);
      if (!(valueEnum.type in destVariants)) {
        return false;
      }
      const variantValue = destVariants[valueEnum.type];
      if (variantValue == null) {
        return true;
      }
      return nextCall(
        valueEnum.value,
        variantValue.type === "inline" ? variantValue.value : getNode(variantValue.value)
      );
    case "option":
      if (value == null) {
        return true;
      }
      return nextCall(value, getNode(destNode.value));
    case "struct":
      if (!value) return false;
      return destNode.value.every(
        ([key, typeRef]) => nextCall(value[key], getNode(typeRef))
      );
    case "tuple":
      if (!value) return false;
      return destNode.value.every(
        (typeRef, idx) => nextCall(value[idx], getNode(typeRef))
      );
    case "result":
      if (!("success" in value && "value" in value)) return false;
      return nextCall(
        value.value,
        getNode(value.success ? destNode.value.ok : destNode.value.ko)
      );
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, key + "" , value);
class DoubleSet {
  constructor(values = []) {
    __publicField(this, "value", /* @__PURE__ */ new Map());
    values.forEach(([a, b]) => this.add(a, b));
  }
  has(a, b) {
    return this.value.get(a)?.has(b) ?? false;
  }
  add(a, b) {
    if (!this.value.has(a)) {
      this.value.set(a, /* @__PURE__ */ new Set());
    }
    this.value.get(a).add(b);
  }
  addAll(values) {
    values.forEach(([a, b]) => this.add(a, b));
  }
  delete(a, b) {
    if (!this.value.has(a)) return;
    const set = this.value.get(a);
    set.delete(b);
    if (!set.size) {
      this.value.delete(a);
    }
  }
  isEmpty() {
    return !this.value.size;
  }
  get values() {
    return Array.from(this.value).flatMap(
      ([a, values]) => Array.from(values).map((b) => [a, b])
    );
  }
}

var CompatibilityLevel = /* @__PURE__ */ ((CompatibilityLevel2) => {
  CompatibilityLevel2[CompatibilityLevel2["Incompatible"] = 0] = "Incompatible";
  CompatibilityLevel2[CompatibilityLevel2["Partial"] = 1] = "Partial";
  CompatibilityLevel2[CompatibilityLevel2["BackwardsCompatible"] = 2] = "BackwardsCompatible";
  CompatibilityLevel2[CompatibilityLevel2["Identical"] = 3] = "Identical";
  return CompatibilityLevel2;
})(CompatibilityLevel || {});
function isStaticCompatible(originNode, getOriginNode, destNode, getDestNode, cache, deep = false) {
  if (!destNode && !originNode) {
    return unconditional(3 /* Identical */, []);
  }
  if (!destNode)
    return unconditional(2 /* BackwardsCompatible */, []);
  if (!originNode)
    return unconditional(
      destNode.type === "option" ? 2 /* BackwardsCompatible */ : 0 /* Incompatible */,
      []
    );
  if (!cache.has(destNode)) {
    cache.set(destNode, /* @__PURE__ */ new Map());
  }
  const destNodeCache = cache.get(destNode);
  if (destNodeCache.has(originNode)) {
    const result2 = destNodeCache.get(originNode);
    if (result2 == null) {
      return {
        level: 3 /* Identical */,
        changes: [],
        assumptions: new DoubleSet([[originNode, destNode]])
      };
    }
    return unconditional(result2.level, result2.changes);
  }
  destNodeCache.set(originNode, null);
  const result = getIsStaticCompatible(
    originNode,
    destNode,
    (originNode2, destNode2) => isStaticCompatible(
      typeof originNode2 === "number" ? getOriginNode(originNode2) : originNode2,
      getOriginNode,
      typeof destNode2 === "number" ? getDestNode(destNode2) : destNode2,
      getDestNode,
      cache
    ),
    deep
  );
  result.assumptions.delete(originNode, destNode);
  if (result.assumptions.isEmpty() || result.level === 0 /* Incompatible */) {
    destNodeCache.set(originNode, result);
  } else {
    destNodeCache.delete(originNode);
  }
  return result;
}
function getIsStaticCompatible(originNode, destNode, next, deep) {
  const nextCall = (originNode2, destNode2, path) => {
    const result = next(originNode2, destNode2);
    return {
      ...result,
      changes: result.level < 3 /* Identical */ ? [
        {
          id: [
            typeof originNode2 === "number" ? originNode2 : null,
            typeof destNode2 === "number" ? destNode2 : null
          ],
          level: result.level,
          path
        }
      ] : []
    };
  };
  if (originNode.type !== destNode.type) {
    if (destNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode, destNode.value, "some"),
        2 /* BackwardsCompatible */
      );
    }
    if (originNode.type === "option") {
      return withMaxLevel(
        nextCall(originNode.value, destNode, "some"),
        1 /* Partial */
      );
    }
    return unconditional(0 /* Incompatible */, []);
  }
  switch (destNode.type) {
    case "terminal":
      return unconditional(
        destNode.value.type === originNode.value.type ? 3 /* Identical */ : 0 /* Incompatible */,
        []
      );
    case "binary":
      const binaryOrigin = originNode;
      return lengthChange(
        compareOptionalLengths(binaryOrigin.value, destNode.value)
      );
    case "array":
      const arrayOrigin = originNode;
      const lengthCheck = lengthChange(
        compareOptionalLengths(arrayOrigin.value.length, destNode.value.length)
      );
      return strictMerge(
        [
          lengthCheck,
          () => nextCall(
            arrayOrigin.value.typeRef,
            destNode.value.typeRef,
            "value"
          )
        ],
        deep
      );
    case "enum": {
      const enumOrigin = originNode;
      const destVariants = Object.fromEntries(
        destNode.value.map(([key, value]) => [key, value.value])
      );
      let enumResults = mergeResults(
        enumOrigin.value.map(
          ([type, value]) => () => type in destVariants ? nextCall(value.value, destVariants[type], type) : unconditional(0 /* Incompatible */, [
            {
              id: [
                typeof value.value === "number" ? value.value : null,
                null
              ],
              level: 0 /* Incompatible */,
              path: type
            }
          ])
        )
      );
      if (enumOrigin.value.length === destNode.value.length) return enumResults;
      enumResults = withMaxLevel(
        enumResults,
        2 /* BackwardsCompatible */
      );
      const enumOriginVariants = new Set(enumOrigin.value.map(([key]) => key));
      enumResults.changes = [
        ...enumResults.changes,
        ...destNode.value.filter(([key]) => !enumOriginVariants.has(key)).map(
          ([key, value]) => ({
            id: [null, typeof value === "number" ? value : null],
            level: 0 /* Incompatible */,
            path: key
          })
        )
      ];
      return enumResults;
    }
    case "option":
      return withMinLevel(
        nextCall(originNode.value, destNode.value, "some"),
        1 /* Partial */
      );
    case "struct":
      const structOrigin = originNode;
      const originProperties = Object.fromEntries(structOrigin.value);
      const maxLevel = structOrigin.value.length === destNode.value.length ? 3 /* Identical */ : 2 /* BackwardsCompatible */;
      return withMaxLevel(
        strictMerge(
          destNode.value.map(
            ([key, value]) => () => nextCall(originProperties[key], value, key)
          ),
          deep
        ),
        maxLevel
      );
    case "tuple": {
      const tupleOrigin = originNode;
      const lengthCheck2 = lengthChange(
        compareArrayLengths(tupleOrigin.value, destNode.value)
      );
      return strictMerge(
        [
          lengthCheck2,
          ...destNode.value.map(
            (value, idx) => () => nextCall(tupleOrigin.value[idx], value, String(idx))
          )
        ],
        deep
      );
    }
    case "result":
      const resultOrigin = originNode;
      return mergeResults([
        nextCall(resultOrigin.value.ok, destNode.value.ok, "ok"),
        nextCall(resultOrigin.value.ko, destNode.value.ko, "ko")
      ]);
  }
}
const withMaxLevel = (result, level) => ({
  // Changes stay the same. Use case: Option<Incompatible>, the option should show up as Partial, but the change should indicate that the inner one is incompatible.
  ...result,
  // Confusing yes, but it's Math.min. If we do withMaxLevel(result, 1), we expect to get at most [1] as a result
  level: Math.min(result.level, level)
});
const withMinLevel = (result, level) => ({
  ...result,
  level: Math.max(result.level, level)
});
const noAssumptions = new DoubleSet();
const unconditional = (level, changes) => ({
  level,
  changes,
  assumptions: noAssumptions
});
const strictMerge = (results, deep) => {
  let merged = unconditional(3 /* Identical */, []);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (!deep && result.level === 0 /* Incompatible */) return result;
    if (result.level !== 3 /* Identical */)
      merged.changes = [...merged.changes, ...result.changes];
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return merged;
};
const mergeResults = (results) => {
  if (!results.length) return unconditional(3 /* Identical */, []);
  let hasCompatibles = false;
  let merged = unconditional(3 /* Identical */, []);
  for (const resultFn of results) {
    const result = typeof resultFn === "function" ? resultFn() : resultFn;
    if (result.level !== 3 /* Identical */)
      merged.changes = [...merged.changes, ...result.changes];
    if (result.level === 0 /* Incompatible */) {
      merged.level = Math.min(merged.level, 1 /* Partial */);
      continue;
    }
    hasCompatibles = true;
    merged.assumptions.addAll(result.assumptions.values);
    merged.level = Math.min(merged.level, result.level);
  }
  return hasCompatibles ? merged : unconditional(0 /* Incompatible */, merged.changes);
};
const lengthChange = (level) => ({
  assumptions: noAssumptions,
  changes: level === 3 /* Identical */ ? [] : [
    {
      id: [null, null],
      level,
      path: "length"
    }
  ],
  level
});
const compareArrayLengths = (origin, dest) => dest.length === origin.length ? 3 /* Identical */ : origin.length >= dest.length ? 2 /* BackwardsCompatible */ : 0 /* Incompatible */;
const compareOptionalLengths = (origin, dest) => dest === origin ? 3 /* Identical */ : dest == null || origin >= dest ? 2 /* BackwardsCompatible */ : origin == null ? 1 /* Partial */ : 0 /* Incompatible */;

const EntryPointNodeCodec = substrateBindings.Variant({
  lookup: substrateBindings.compactNumber,
  typedef: TypedefCodec
});
const lookupNode = (value) => ({
  type: "lookup",
  value
});
const typedefNode = (value) => ({
  type: "typedef",
  value
});
const voidEntryPointNode = typedefNode({
  type: "terminal",
  value: { type: Primitive.void }
});
const EntryPointCodec = substrateBindings.Struct({
  args: EntryPointNodeCodec,
  values: EntryPointNodeCodec
});
function storageEntryPoint(storageEntry) {
  if (storageEntry.type.tag === "plain")
    return {
      args: voidEntryPointNode,
      values: lookupNode(storageEntry.type.value)
    };
  const { key, value } = storageEntry.type.value;
  return {
    args: lookupNode(key),
    values: lookupNode(value)
  };
}
function runtimeCallEntryPoint(entry) {
  return {
    args: typedefNode({
      type: "tuple",
      value: entry.inputs.map((v) => v.type)
    }),
    values: lookupNode(entry.output)
  };
}
function enumValueEntryPointNode(entry) {
  return entry.type === "lookupEntry" ? lookupNode(entry.value.id) : typedefNode(mapLookupToTypedef(entry));
}
function singleValueEntryPoint(value) {
  return {
    args: voidEntryPointNode,
    values: lookupNode(value)
  };
}
function entryPointsAreCompatible(descriptorEntry, getDescriptorNode, runtimeEntry, getRuntimeNode, cache, deep) {
  const resolveNode = (node, getTypedef) => node.type === "lookup" ? getTypedef(node.value) : node.value;
  return {
    args: isStaticCompatible(
      resolveNode(descriptorEntry.args, getDescriptorNode),
      getDescriptorNode,
      resolveNode(runtimeEntry.args, getRuntimeNode),
      getRuntimeNode,
      cache,
      deep
    ),
    values: isStaticCompatible(
      resolveNode(runtimeEntry.values, getRuntimeNode),
      getRuntimeNode,
      resolveNode(descriptorEntry.values, getDescriptorNode),
      getDescriptorNode,
      cache,
      deep
    )
  };
}
function valueIsCompatibleWithDest(dest, getDestNode, value) {
  const node = dest.type === "lookup" ? getDestNode(dest.value) : dest.value;
  return isCompatible(value, node, getDestNode);
}
function mapEntryPointReferences(entryPoint, mapFn) {
  const mapNode = (node) => node.type === "lookup" ? lookupNode(mapFn(node.value)) : typedefNode(mapReferences(node.value, mapFn));
  return {
    args: mapNode(entryPoint.args),
    values: mapNode(entryPoint.values)
  };
}

exports.CompatibilityLevel = CompatibilityLevel;
exports.EntryPointCodec = EntryPointCodec;
exports.TypedefCodec = TypedefCodec;
exports.entryPointsAreCompatible = entryPointsAreCompatible;
exports.enumValueEntryPointNode = enumValueEntryPointNode;
exports.isCompatible = isCompatible;
exports.isStaticCompatible = isStaticCompatible;
exports.mapEntryPointReferences = mapEntryPointReferences;
exports.mapLookupToTypedef = mapLookupToTypedef;
exports.mapReferences = mapReferences;
exports.runtimeCallEntryPoint = runtimeCallEntryPoint;
exports.singleValueEntryPoint = singleValueEntryPoint;
exports.storageEntryPoint = storageEntryPoint;
exports.valueIsCompatibleWithDest = valueIsCompatibleWithDest;
exports.voidEntryPointNode = voidEntryPointNode;
//# sourceMappingURL=index.js.map
