import { jsonRpcMsg } from './json-rpc-message.mjs';
import { getOpaqueToken } from './get-opaque-token.mjs';

const getInternalId = () => `___proxyInternalId__${getOpaqueToken()}`;
const getProxy = (toConsumer) => {
  let state = {
    type: 1 /* Connecting */,
    activeBroadcasts: /* @__PURE__ */ new Map(),
    pending: []
  };
  const onMsgFromProvider = (msg) => {
    let isActive = true;
    if (state.type === 0 /* Connected */) {
      const parsed = JSON.parse(msg);
      if ("id" in parsed) {
        const { id } = parsed;
        if (state.pendingBroadcasts.has(id)) {
          const synToken = state.pendingBroadcasts.get(id);
          const upToken = parsed.result;
          state.pendingBroadcasts.delete(id);
          const activeBroadcast = state.activeBroadcasts.get(synToken);
          if (activeBroadcast)
            state.activeBroadcasts.get(synToken).upToken = upToken;
          else
            state.connection.send(
              jsonRpcMsg({
                id: getInternalId(),
                method: "transaction_v1_stop",
                params: [upToken]
              })
            );
          return;
        }
        isActive = state.onGoingRequests.has(id);
        if ("result" in parsed && state.onGoingRequests.get(id)?.type === 0 /* ChainHeadFollow */)
          state.activeChainHeads.add(parsed.result);
        state.onGoingRequests.delete(parsed.id);
      } else if ("params" in parsed) {
        const { subscription, result } = parsed.params;
        if (result?.event === "stop")
          state.activeChainHeads.delete(subscription);
      }
    }
    if (isActive && state.type !== 2 /* Done */) toConsumer(msg);
  };
  const send = (msg) => {
    if (state.type === 2 /* Done */) return;
    const parsed = JSON.parse(msg);
    if ("id" in parsed) {
      const { method, id, params } = parsed;
      const [group, , methodName] = method.split("_");
      if (group === "transaction") {
        if (methodName === "stop") {
          const [synToken] = params;
          const active = state.activeBroadcasts.get(synToken);
          state.activeBroadcasts.delete(synToken);
          toConsumer(
            jsonRpcMsg({
              id,
              result: null
            })
          );
          if (state.type === 0 /* Connected */ && active && active.upToken) {
            state.connection.send(
              jsonRpcMsg({
                id,
                method,
                params: [active.upToken]
              })
            );
          }
          return;
        }
        if (methodName === "broadcast") {
          const synToken = getOpaqueToken();
          state.activeBroadcasts.set(synToken, {
            tx: params[0],
            synToken
          });
          if (state.type === 0 /* Connected */) {
            state.pendingBroadcasts.set(id, synToken);
            state.connection.send(msg);
          }
          toConsumer(
            jsonRpcMsg({
              id,
              result: synToken
            })
          );
          return;
        }
      }
    }
    if (state.type === 1 /* Connecting */) {
      state.pending.push(msg);
      return;
    }
    if (parsed.method === "chainHead_v1_unfollow")
      state.activeChainHeads.delete(parsed.params[0]);
    if ("id" in parsed) {
      const { method, id } = parsed;
      const [group, , methodName] = method.split("_");
      const ongoingMsg = group === "chainHead" ? methodName === "follow" ? {
        type: 0 /* ChainHeadFollow */,
        msg
      } : { type: 1 /* ChainHeadOperation */, id } : { type: 2 /* Other */, msg };
      state.onGoingRequests.set(id, ongoingMsg);
    }
    state.connection.send(msg);
  };
  return {
    send,
    disconnect: () => {
      if (state.type === 2 /* Done */) return;
      if (state.type === 0 /* Connected */) state.connection.disconnect();
      state = { type: 2 /* Done */ };
    },
    connect: (cb) => {
      if (state.type !== 1 /* Connecting */) throw new Error("Nonesense");
      const { pending, activeBroadcasts } = state;
      const onGoingRequests = /* @__PURE__ */ new Map();
      const activeChainHeads = /* @__PURE__ */ new Set();
      const onHalt = () => {
        const activeBroadcasts2 = state.type !== 2 /* Done */ ? state.activeBroadcasts : /* @__PURE__ */ new Map();
        activeBroadcasts2.forEach((x) => x.upToken = void 0);
        state = {
          type: 1 /* Connecting */,
          activeBroadcasts: activeBroadcasts2,
          pending: []
        };
        activeChainHeads.forEach((subscription) => {
          onMsgFromProvider(
            jsonRpcMsg({
              params: {
                subscription,
                result: {
                  event: "stop",
                  internal: true
                }
              }
            })
          );
        });
        activeChainHeads.clear();
        for (const x of onGoingRequests.values()) {
          if (x.type === 1 /* ChainHeadOperation */)
            onMsgFromProvider(
              jsonRpcMsg({
                id: x.id,
                error: { code: -32603, message: "Internal error" },
                internal: true
              })
            );
          else send(x.msg);
        }
        onGoingRequests.clear();
      };
      state = {
        type: 0 /* Connected */,
        connection: cb(onMsgFromProvider, onHalt),
        activeBroadcasts,
        pendingBroadcasts: /* @__PURE__ */ new Map(),
        onGoingRequests,
        activeChainHeads
      };
      activeBroadcasts.forEach((broadcast) => {
        if (state.type === 0 /* Connected */) {
          const id = getInternalId();
          state.pendingBroadcasts.set(id, broadcast.synToken);
          send(
            jsonRpcMsg({
              id,
              method: "transaction_v1_broadcast",
              params: [broadcast.tx]
            })
          );
        }
      });
      pending.forEach(send);
    }
  };
};

export { getProxy };
//# sourceMappingURL=get-proxy.mjs.map
