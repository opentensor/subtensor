import { RpcError } from './RpcError.mjs';
import { getSubscriptionsManager } from './subscriptions-manager.mjs';
import { DestroyedError } from './DestroyedError.mjs';

let nextClientId = 1;
const createClient = (gProvider) => {
  let clientId = nextClientId++;
  const responses = /* @__PURE__ */ new Map();
  const subscriptions = getSubscriptionsManager();
  let connection = null;
  const send = (id, method, params) => {
    connection.send(
      JSON.stringify({
        jsonrpc: "2.0",
        id,
        method,
        params
      })
    );
  };
  function onMessage(message) {
    try {
      let id, result, error, params, subscription;
      const parsed = JSON.parse(message);
      ({ id, result, error, params } = parsed);
      if (id === null) throw new Error(params?.error?.message ?? "id null");
      if (id != null) {
        const cb = responses.get(id);
        if (!cb) return;
        responses.delete(id);
        return error ? cb.onError(new RpcError(error)) : cb.onSuccess(result, (opaqueId, subscriber) => {
          const subscriptionId2 = opaqueId;
          subscriptions.subscribe(subscriptionId2, subscriber);
          return () => {
            subscriptions.unsubscribe(subscriptionId2);
          };
        });
      }
      ;
      ({ subscription, result, error } = params);
      if (!subscription || !error && !Object.hasOwn(params, "result")) throw 0;
      const subscriptionId = subscription;
      if (error) {
        subscriptions.error(subscriptionId, new RpcError(error));
      } else {
        subscriptions.next(subscriptionId, result);
      }
    } catch (e) {
      console.warn("Error parsing incomming message: " + message);
      console.error(e);
    }
  }
  connection = gProvider(onMessage);
  const disconnect = () => {
    connection?.disconnect();
    connection = null;
    subscriptions.errorAll(new DestroyedError());
    responses.forEach((r) => r.onError(new DestroyedError()));
    responses.clear();
  };
  let nextId = 1;
  const request = (method, params, cb) => {
    if (!connection) throw new Error("Not connected");
    const id = `${clientId}-${nextId++}`;
    if (cb) responses.set(id, cb);
    send(id, method, params);
    return () => {
      responses.delete(id);
    };
  };
  return {
    request,
    disconnect
  };
};

export { createClient };
//# sourceMappingURL=createClient.mjs.map
