import { storageEntryPoint, singleValueEntryPoint, runtimeCallEntryPoint, mapEntryPointReferences, enumValueEntryPointNode, voidEntryPointNode, mapLookupToTypedef } from '@polkadot-api/metadata-compatibility';

const getUsedTypes = (lookup, builder) => {
  const checksums = new Array(lookup.metadata.lookup.length);
  const visited = /* @__PURE__ */ new Set();
  const types = /* @__PURE__ */ new Map();
  const entryPoints = /* @__PURE__ */ new Map();
  const addTypeFromLookup = (id) => {
    if (id == null) return;
    const checksum = builder.buildDefinition(id);
    if (!checksum) {
      throw new Error("Unreachable: checksum not available for lookup type");
    }
    checksums[id] = checksum;
    if (visited.has(checksum)) return;
    visited.add(checksum);
    types.set(checksum, mapLookupToTypedef(lookup(id), addTypeFromLookup));
  };
  const addTypeFromEntryPoint = (checksum, entry) => {
    entryPoints.set(checksum, entry);
    mapEntryPointReferences(entry, (id) => {
      addTypeFromLookup(id);
      return id;
    });
  };
  const buildEnum = (side, val, cb) => {
    if (val === void 0) return;
    const entry = lookup(val);
    if (entry.type === "void") return;
    if (entry.type !== "enum") throw new Error("Expected enum");
    Object.entries(entry.value).forEach(([name, value]) => {
      const checksum = cb(name);
      const node = enumValueEntryPointNode(value);
      addTypeFromEntryPoint(checksum, {
        args: side === "args" ? node : voidEntryPointNode,
        values: side === "args" ? voidEntryPointNode : node
      });
    });
  };
  lookup.metadata.pallets.forEach((pallet) => {
    pallet.storage?.items.forEach((entry) => {
      const checksum = builder.buildStorage(pallet.name, entry.name);
      addTypeFromEntryPoint(checksum, storageEntryPoint(entry));
    });
    pallet.constants.forEach(({ name, type }) => {
      const checksum = builder.buildConstant(pallet.name, name);
      addTypeFromEntryPoint(checksum, singleValueEntryPoint(type));
    });
    pallet.viewFns.forEach((entry) => {
      const checksum = builder.buildViewFns(pallet.name, entry.name);
      addTypeFromEntryPoint(checksum, runtimeCallEntryPoint(entry));
    });
    buildEnum(
      "args",
      pallet.calls?.type,
      (name) => builder.buildCall(pallet.name, name)
    );
    buildEnum(
      "values",
      pallet.events?.type,
      (name) => builder.buildEvent(pallet.name, name)
    );
    buildEnum(
      "values",
      pallet.errors?.type,
      (name) => builder.buildError(pallet.name, name)
    );
  });
  lookup.metadata.apis.forEach(
    (api) => api.methods.forEach((method) => {
      const checksum = builder.buildRuntimeCall(api.name, method.name);
      addTypeFromEntryPoint(checksum, runtimeCallEntryPoint(method));
    })
  );
  return { types, entryPoints, checksums };
};

export { getUsedTypes };
//# sourceMappingURL=get-used-types.mjs.map
