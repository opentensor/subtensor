import { getInternalTypesBuilder } from './internal-types/internal-types-builder.mjs';
import { isPrimitive } from './internal-types/type-representation.mjs';
import { generateTypescript, processPapiPrimitives, nativeNodeCodegen, mergeImports, onlyCode } from './internal-types/generate-typescript.mjs';

const defaultDeclarations = () => ({
  imports: /* @__PURE__ */ new Set(),
  variables: /* @__PURE__ */ new Map(),
  takenNames: /* @__PURE__ */ new Set()
});
const NEVER_STR = "never";
const opaqueHashers = /* @__PURE__ */ new Set([
  "Blake2128",
  "Blake2256",
  "Twox128",
  "Twox256"
]);
const getTypesBuilder = (declarations, getLookupEntryDef, knownTypes, checksumBuilder) => {
  const { metadata, call } = getLookupEntryDef;
  const callsChecksum = call ? checksumBuilder.buildDefinition(call) : null;
  const typeFileImports = /* @__PURE__ */ new Set();
  const clientFileImports = /* @__PURE__ */ new Set();
  const getChecksum = (id) => typeof id === "number" ? checksumBuilder.buildDefinition(id) : checksumBuilder.buildComposite(id);
  const internalBuilder = getInternalTypesBuilder(getLookupEntryDef);
  const anonymize = ({ name, checksum }) => knownTypes[checksum] ? name : `Anonymize<${name}>`;
  const getName = (checksum) => {
    if (!knownTypes[checksum]) return `I${checksum}`;
    const { name: originalName } = knownTypes[checksum];
    let name = originalName;
    let i = 1;
    while (declarations.takenNames.has(name)) name = originalName + i++;
    declarations.takenNames.add(name);
    return name;
  };
  const buildDefinition = (id) => {
    const node = internalBuilder(id);
    return generateTypescript(node, (node2, next, level) => {
      if (node2.type === "primitive") return nativeNodeCodegen(node2, next);
      const checksum = "id" in node2 ? getChecksum(node2.id) : (
        // for types inlined in Enums, we might have an intermediate type
        "original" in node2 ? getChecksum(node2.original) : null
      );
      const getPapiPrimitive = (level2) => {
        const papiPrimitive = processPapiPrimitives(
          node2,
          next,
          !!checksum && !!knownTypes[checksum]
        );
        if (!papiPrimitive) return null;
        papiPrimitive.imports.client?.forEach((name) => {
          if (level2 === 0) {
            clientFileImports.add(name);
          } else {
            declarations.imports.add(name);
          }
        });
        return onlyCode(papiPrimitive.code);
      };
      if (!checksum || isPrimitive(node2) || node2.type === "union") {
        return getPapiPrimitive(level) ?? nativeNodeCodegen(node2, next);
      }
      if (level > 0 && checksum === callsChecksum) {
        declarations.imports.add("TxCallData");
        return onlyCode("TxCallData");
      }
      if (declarations.variables.has(checksum)) {
        const entry = declarations.variables.get(checksum);
        if (level === 0) {
          typeFileImports.add(entry.name);
        }
        return onlyCode(anonymize(entry));
      }
      const variable = {
        checksum,
        type: "",
        name: getName(checksum)
      };
      if (level === 0) {
        typeFileImports.add(variable.name);
      }
      declarations.variables.set(checksum, variable);
      variable.type = (getPapiPrimitive(level + 1) ?? nativeNodeCodegen(node2, next)).code;
      return onlyCode(anonymize(variable));
    });
  };
  const buildTypeDefinition = (id) => buildDefinition(id).code;
  const buildStorage = (pallet, entry) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    if (storageEntry.type.tag === "plain")
      return {
        key: "[]",
        val: `${buildTypeDefinition(storageEntry.type.value)}`,
        opaque: NEVER_STR
      };
    const hashers = storageEntry.type.value.hashers;
    const opaque = hashers.map((x, idx) => opaqueHashers.has(x.tag) ? `"${idx}"` : null).filter(Boolean).join(" | ") || NEVER_STR;
    const { key, value } = storageEntry.type.value;
    const val = buildTypeDefinition(value);
    const returnKey = storageEntry.type.value.hashers.length === 1 ? `[Key: ${buildTypeDefinition(key)}]` : buildTypeDefinition(key);
    return { key: returnKey, val, opaque };
  };
  const buildViewFn = (pallet, entry) => {
    const viewFn = metadata.pallets.find((x) => x.name === pallet)?.viewFns.find((x) => x.name === entry);
    if (!viewFn) throw null;
    const innerTuple = viewFn.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(viewFn.output)
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry) throw null;
    const innerTuple = entry.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(entry.output)
    };
  };
  const buildVariant = (type) => (pallet, name) => {
    const lookupEntry = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet)[type].type
    );
    if (lookupEntry.type !== "enum") throw null;
    buildDefinition(lookupEntry.id);
    const innerLookup = lookupEntry.value[name];
    if (innerLookup.type === "lookupEntry") {
      return buildTypeDefinition(innerLookup.value.id);
    } else if (innerLookup.type === "void") {
      return "undefined";
    } else {
      const result = declarations.variables.get(
        getChecksum(innerLookup)
      ).name;
      typeFileImports.add(result);
      return `Anonymize<${result}>`;
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildTypeDefinition(storageEntry.type);
  };
  return {
    buildTypeDefinition,
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall: buildVariant("calls"),
    buildViewFn,
    buildRuntimeCall,
    buildConstant,
    getTypeFileImports: () => Array.from(typeFileImports),
    getClientFileImports: () => Array.from(clientFileImports)
  };
};
const getDocsTypesBuilder = (getLookupEntryDef, knownTypes, checksumBuilder) => {
  const { metadata, call } = getLookupEntryDef;
  const callsChecksum = call ? checksumBuilder.buildDefinition(call) : null;
  const clientFileImports = /* @__PURE__ */ new Set();
  const fileTypeEntries = /* @__PURE__ */ new Set();
  const importsPerType = /* @__PURE__ */ new Map();
  const declarations = defaultDeclarations();
  const getChecksum = (id) => typeof id === "number" ? checksumBuilder.buildDefinition(id) : checksumBuilder.buildComposite(id);
  const internalBuilder = getInternalTypesBuilder(getLookupEntryDef);
  const buildTypeDefinition = (id) => {
    fileTypeEntries.add(id);
    const node = internalBuilder(id);
    const visited = /* @__PURE__ */ new Set();
    const result = generateTypescript(node, (node2, next) => {
      const checksum = "id" in node2 ? getChecksum(node2.id) : (
        // for types inlined in Enums, we might have an intermediate type
        "original" in node2 ? getChecksum(node2.original) : null
      );
      const getPapiPrimitive = () => processPapiPrimitives(node2, next, true);
      if (!checksum) {
        return getPapiPrimitive() ?? nativeNodeCodegen(node2, next);
      }
      if (node2.type === "primitive") return nativeNodeCodegen(node2, next);
      if (checksum === callsChecksum) {
        return {
          code: "TxCallData",
          imports: {
            client: /* @__PURE__ */ new Set(["TxCallData"])
          }
        };
      }
      if (checksum in knownTypes) {
        if (declarations.variables.has(checksum)) {
          const entry = declarations.variables.get(checksum);
          return {
            code: entry.name,
            imports: {
              types: /* @__PURE__ */ new Set([entry.name])
            }
          };
        }
        const variable = {
          checksum,
          type: "",
          name: knownTypes[checksum].name
        };
        declarations.variables.set(checksum, variable);
        const generated = getPapiPrimitive() ?? nativeNodeCodegen(node2, next);
        variable.type = generated.code;
        importsPerType.set(
          checksum,
          mergeImports([
            generated.imports,
            {
              types: /* @__PURE__ */ new Set([variable.name])
            }
          ])
        );
        return {
          code: variable.name,
          imports: {
            types: /* @__PURE__ */ new Set([variable.name])
          }
        };
      }
      if (declarations.variables.has(checksum)) {
        const entry = declarations.variables.get(checksum);
        return {
          code: entry.type,
          imports: importsPerType.get(checksum) ?? {}
        };
      }
      if (visited.has(checksum)) {
        return {
          code: "__Circular",
          imports: {
            types: /* @__PURE__ */ new Set(["__Circular"])
          }
        };
      }
      visited.add(checksum);
      const result2 = getPapiPrimitive() ?? nativeNodeCodegen(node2, next);
      declarations.variables.set(checksum, {
        checksum,
        type: result2.code,
        name: "I" + checksum
      });
      importsPerType.set(checksum, result2.imports);
      return result2;
    });
    return result.code;
  };
  const buildStorage = (pallet, entry) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    if (storageEntry.type.tag === "plain")
      return {
        opaque: NEVER_STR,
        args: "[]",
        payload: `${buildTypeDefinition(storageEntry.type.value)}`
      };
    const { key, value } = storageEntry.type.value;
    const payload = buildTypeDefinition(value);
    const hashers = storageEntry.type.value.hashers;
    const opaque = hashers.map((x, idx) => opaqueHashers.has(x.tag) ? `"${idx}"` : null).filter(Boolean).join(" | ") || NEVER_STR;
    const returnKey = hashers.length === 1 ? `[Key: ${buildTypeDefinition(key)}]` : buildTypeDefinition(key);
    return { args: returnKey, payload, opaque };
  };
  const buildViewFn = (pallet, entry) => {
    const fn = metadata.pallets.find((x) => x.name === pallet)?.viewFns.find((x) => x.name === entry);
    if (!fn) throw null;
    const innerTuple = fn.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(fn.output)
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry) throw null;
    const innerTuple = entry.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(entry.output)
    };
  };
  const buildVariant = (type) => (pallet, name) => {
    const lookupEntry = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet)[type].type
    );
    if (lookupEntry.type !== "enum") throw null;
    const innerLookup = lookupEntry.value[name];
    if (innerLookup.type === "lookupEntry") {
      return buildTypeDefinition(innerLookup.value.id);
    } else if (innerLookup.type === "void") {
      return "undefined";
    } else {
      buildTypeDefinition(lookupEntry.id);
      const innerChecksum = getChecksum(innerLookup);
      const innerVariable = declarations.variables.get(innerChecksum);
      if (!innerVariable) {
        throw new Error(
          `Unable to build ${type} variant for ${pallet}::${name}: ${innerChecksum} not populated`
        );
      }
      return innerVariable.type;
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildTypeDefinition(storageEntry.type);
  };
  const recordTypeFileImports = () => {
    const allImports = /* @__PURE__ */ new Set();
    for (const id of fileTypeEntries) {
      const thisTypeImports = importsPerType.get(getChecksum(id));
      if (!thisTypeImports?.types) continue;
      for (const singleType of thisTypeImports.types.values()) {
        allImports.add(singleType);
      }
    }
    fileTypeEntries.clear();
    return Array.from(allImports);
  };
  const getDescriptorsTypes = () => [...declarations.variables.entries()].filter(([checksum]) => knownTypes[checksum]).map(([_, variable]) => variable);
  return {
    buildStorage,
    buildRuntimeCall,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall: buildVariant("calls"),
    buildConstant,
    buildViewFn,
    declarations,
    recordTypeFileImports,
    getClientFileImports: () => Array.from(clientFileImports),
    getDescriptorsTypes
  };
};

export { defaultDeclarations, getDocsTypesBuilder, getTypesBuilder };
//# sourceMappingURL=types-builder.mjs.map
