const intRegex = /^u?int(\d+)$/;
const fixedRegex = /^u?fixed\d+x(\d+)$/;
function generatePrimitiveType(primitive) {
  switch (primitive) {
    case "uint":
    case "int":
      return "bigint";
    case "address":
      return "Address";
    case "bool":
      return "boolean";
    case "fixed":
    case "ufixed":
      return "Decimal<18>";
    case "function":
      return "FunctionRef";
    case "bytes":
      return "Binary";
    case "string":
      return "string";
  }
  if (primitive.startsWith("bytes")) {
    return "Binary";
  }
  const intMatch = intRegex.exec(primitive);
  if (intMatch) {
    return Number(intMatch[1]) > 53 ? "bigint" : "number";
  }
  const fixedMatch = fixedRegex.exec(primitive);
  if (fixedMatch) {
    return `Decimal<${fixedMatch[1]}>`;
  }
  throw new Error("Can't map " + primitive);
}
const arrayRegex = /^(.+)\[(\d+)\]$/;
function generateVariableType(variable) {
  if (variable.type === "tuple") {
    return generateStructType(variable.components);
  }
  if (variable.type.endsWith("[]")) {
    return `Array<${generateVariableType({
      ...variable,
      type: variable.type.replace("[]", "")
    })}>`;
  }
  const arrayMatch = arrayRegex.exec(variable.type);
  if (arrayMatch) {
    return `Array<${generatePrimitiveType(arrayMatch[1])}>`;
  }
  return generatePrimitiveType(variable.type);
}
function generateStructType(params) {
  if (!params || !params.length) return `{}`;
  const unnamedTypes = params.filter((v) => !v.name);
  const namedTypes = params.filter((v) => !!v.name);
  if (namedTypes.length == 0) {
    if (unnamedTypes.length === 1) {
      return generateVariableType(unnamedTypes[0]);
    }
    return "[" + unnamedTypes.map(generateVariableType).join(", ") + "]";
  }
  if (unnamedTypes.length) {
    namedTypes.push({
      name: "args",
      type: "tuple",
      components: unnamedTypes
    });
  }
  return `{${namedTypes.map((v) => `"${v.name}": ${generateVariableType(v)}`).join(",\n")}}`;
}
function generateFunctionType(fnAbi) {
  if (!fnAbi.name) {
    console.log(fnAbi);
    throw new Error("Function needs a name");
  }
  return `"${fnAbi.name}": { message: ${generateStructType(fnAbi.inputs)}, response: ${generateStructType(fnAbi.outputs)} }`;
}
function generateSolTypes(abi) {
  const messages = abi.filter((v) => v.type === "function");
  const receive = abi.find((v) => v.type === "receive");
  if (receive) {
    messages.push({
      name: "receive",
      ...receive,
      type: "function"
    });
  }
  const fallback = abi.find((v) => v.type === "fallback");
  if (fallback) {
    messages.push({
      name: "fallback",
      ...fallback,
      type: "function"
    });
  }
  const messagesDescriptor = `{ ${messages.map(generateFunctionType).join(",\n")} }`;
  const constructor = abi.find((v) => v.type === "constructor") ?? {
    type: "constructor",
    stateMutability: "pure"
  };
  const constructorsDescriptor = `{ ${generateFunctionType({
    name: "new",
    ...constructor
  })} }`;
  const events = abi.filter((v) => v.type === "event");
  const eventsDescriptor = `Enum<{
    ${events.map((evt) => `"${evt.name}": ${generateStructType(evt.inputs)}`).join(",\n")}
  }>`;
  const result = `
    import type { InkDescriptors } from 'polkadot-api/ink';
    import type { HexString, Enum, Binary } from 'polkadot-api';

    type Address = HexString
    type Decimal<T extends number> = { value: bigint, decimals: T }
    type FunctionRef = { address: Address, selector: HexString }

    type StorageDescriptor = {};
    type MessagesDescriptor = ${messagesDescriptor};
    type ConstructorsDescriptor = ${constructorsDescriptor};
    type EventDescriptor = ${eventsDescriptor};

    export const descriptor: InkDescriptors<StorageDescriptor, MessagesDescriptor, ConstructorsDescriptor, EventDescriptor> = { abi: ${JSON.stringify(abi)} } as any;
  `;
  return result;
}

export { generateSolTypes };
//# sourceMappingURL=sol-types.mjs.map
