import { getLookupFn, getChecksumBuilder } from '@polkadot-api/metadata-builders';
import { getDocsTypesBuilder } from './types-builder.mjs';
import { knownTypes } from './known-types.mjs';

const paths = {
  client: "polkadot-api",
  types: "types"
};
async function generateDocsDescriptors(key, metadata) {
  const lookup = getLookupFn(metadata);
  const checksumBuilder = getChecksumBuilder(lookup);
  const docsTypesBuilder = getDocsTypesBuilder(
    lookup,
    knownTypes,
    checksumBuilder
  );
  const getClientImports = () => [
    "StorageDescriptor",
    "PlainDescriptor",
    "TxDescriptor",
    "RuntimeDescriptor",
    "Enum",
    "_Enum",
    "Binary",
    "FixedSizeBinary",
    "FixedSizeArray",
    "QueryFromPalletsDef",
    "TxFromPalletsDef",
    "EventsFromPalletsDef",
    "ErrorsFromPalletsDef",
    "ConstFromPalletsDef",
    "ViewFnsFromPalletsDef",
    "SS58String",
    "ResultPayload",
    "TxCallData",
    ...docsTypesBuilder.getClientFileImports()
  ];
  const storageOutput = await buildStorage(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const runtimeCallsOutput = await buildRuntimeCalls(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const errorsOutput = await buildErrors(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const constantsOutput = await buildConstants(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const eventsOutput = await buildEvents(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const callsOutput = await buildCalls(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const viewFnsOutput = await buildViewFns(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const descriptorsTypesFileContent = `import {
  ${getClientImports().join(",\n  ")}
} from "${paths.client}";
` + docsTypesBuilder.getDescriptorsTypes().map((variable) => {
    return `export type ${variable.name} = ${variable.type};`;
  }).join("\n") + `
/**
 * This is a special type that we're using only in this docs.
 * It's not present in descriptors generated by polkadot-api, and only used for 
 * marking circular types, if they aren't a known type.  
 */
export type __Circular = any;
`;
  const hasSection = {
    storage: storageOutput.index !== "",
    runtimeCalls: runtimeCallsOutput.index !== "",
    errors: errorsOutput.index !== "",
    constants: constantsOutput.index !== "",
    events: eventsOutput.index !== "",
    calls: callsOutput.index !== "",
    viewFns: viewFnsOutput.index !== ""
  };
  const index = getIndexFileDocs({ chainName: key, hasSection });
  return {
    index,
    types: descriptorsTypesFileContent,
    Storage: storageOutput,
    RuntimeCalls: runtimeCallsOutput,
    Errors: errorsOutput,
    Constants: constantsOutput,
    Events: eventsOutput,
    Transactions: callsOutput,
    ViewFunctions: viewFnsOutput
  };
}
const buildEnumObj = (metadata, val, cb) => {
  if (val === void 0) return {};
  const lookup = metadata.lookup[val];
  if (lookup.def.tag !== "variant") throw null;
  return Object.fromEntries(
    lookup.def.value.map((x) => {
      return [x.name, cb(x.name, x.docs)];
    })
  );
};
async function buildErrors(metadata, docsTypesBuilder, getClientImports) {
  const errors = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.errors?.type, (name, docs) => {
            return {
              type: `PlainDescriptor<${docsTypesBuilder.buildError(
                pallet.name,
                name
              )}>`,
              docs
            };
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(errors, getClientImports);
}
async function buildConstants(metadata, docsTypesBuilder, getClientImports) {
  const constants = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: Object.fromEntries(
            pallet.constants?.map(({ name, docs }) => {
              const type = `PlainDescriptor<${docsTypesBuilder.buildConstant(
                pallet.name,
                name
              )}>`;
              return [
                name,
                {
                  type,
                  docs
                }
              ];
            }) ?? []
          ),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(constants, getClientImports);
}
async function buildEvents(metadata, docsTypesBuilder, getClientImports) {
  const events = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.events?.type, (name, docs) => {
            return {
              type: `PlainDescriptor<${docsTypesBuilder.buildEvent(
                pallet.name,
                name
              )}>`,
              docs
            };
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(events, getClientImports);
}
async function buildCalls(metadata, docsTypesBuilder, getClientImports) {
  const calls = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.calls?.type, (name, docs) => {
            return {
              type: `TxDescriptor<${docsTypesBuilder.buildCall(
                pallet.name,
                name
              )}>`,
              docs
            };
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(calls, getClientImports);
}
async function buildRuntimeCalls(metadata, docsTypesBuilder, getClientImports) {
  const runtimeCalls = Object.fromEntries(
    metadata.apis.map((api) => [
      api.name,
      {
        docs: api.docs,
        values: Object.fromEntries(
          api.methods.map((method) => {
            const { args, value } = docsTypesBuilder.buildRuntimeCall(
              api.name,
              method.name
            );
            return [
              method.name,
              {
                type: `RuntimeDescriptor<${args}, ${value}>`,
                docs: method.docs
              }
            ];
          })
        ),
        descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
      }
    ])
  );
  return buildTypeFolder(runtimeCalls, getClientImports);
}
async function buildViewFns(metadata, docsTypesBuilder, getClientImports) {
  const viewFns = Object.fromEntries(
    metadata.pallets.map((pallet) => [
      pallet.name,
      {
        docs: pallet.docs,
        values: Object.fromEntries(
          pallet.viewFns.map((fn) => {
            const { args, value } = docsTypesBuilder.buildViewFn(
              pallet.name,
              fn.name
            );
            return [
              fn.name,
              {
                type: `RuntimeDescriptor<${args}, ${value}>`,
                docs: fn.docs
              }
            ];
          })
        ),
        descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
      }
    ])
  );
  return buildTypeFolder(viewFns, getClientImports);
}
async function buildStorage(metadata, docsTypesBuilder, getClientImports) {
  const storage = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: Object.fromEntries(
            pallet.storage?.items.map((item) => {
              const { name, docs, modifier } = item;
              if (pallet.name === "System" && name === "Events") {
                return [
                  "Events",
                  {
                    type: `StorageDescriptor<[], any, ${!modifier}, "never">`,
                    docs: [
                      ...docs,
                      "",
                      " Due to readability reasons, return type of Events item is omitted in this documentation"
                    ]
                  }
                ];
              }
              const { args, payload, opaque } = docsTypesBuilder.buildStorage(
                pallet.name,
                name
              );
              return [
                name,
                {
                  type: `StorageDescriptor<${args}, ${payload === "undefined" ? "null" : payload}, ${!modifier}, ${opaque}>`,
                  docs
                }
              ];
            }) ?? []
          ),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(storage, getClientImports);
}
function buildTypeFolder(input, getClientImports) {
  const output = {};
  output["index"] = "";
  for (const [
    section,
    { docs, values, descriptorsTypesImports }
  ] of Object.entries(input)) {
    if (Object.keys(values).length === 0) continue;
    const sectionDocs = docs.length > 0 ? `
/**
${docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
 * @packageDocumentation
 */


` : "";
    const imports = `
import {
  ${getClientImports().join(",\n  ")}
} from "${paths.client}";

import {
  ${descriptorsTypesImports.join(",\n  ")}
} from "../${paths.types}";
  `;
    output[section] = sectionDocs + imports + Object.entries(values).map(
      ([typeName, typeDef]) => formatDocs(typeDef.docs) + // splitting type declaration and export allows us to curcumvent potential
      // collisions between imports and type names
      `
type ${section}_${typeName} = ${typeDef.type};
export {${section}_${typeName} as ${typeName}};`
    ).join("\n");
    output["index"] += `export * as ${section} from "./${section}";
`;
  }
  return output;
}
function formatDocs(docs) {
  return `/**
${docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
*/
`;
}
function getIndexFileDocs({
  chainName,
  hasSection
}) {
  return `
/**
 * This is generated documentation for TypedAPI decriptors for **${chainName}** chain  
 * 
 * **TypedApi calls** section describes apis that are available via calls like  
 * \`\`\`ts
 * api.tx.XcmPallet.limited_teleport_assets({...})
 * \`\`\`
 * Where \`api\` is returned by \`client.getTypedApi(${chainName})\` call  
 *
 * Each section has APIs grouped by pallet name  
 * 
 * **Types** represent TypeScript types that are to be imported
 * from \`@polkadot-api/descriptors\`:  
 * \`\`\`ts
 * import { XcmVersionedLocation, XcmV3Junctions } from "@polkadot-api/descriptors"
 * \`\`\`
 * 
 * @see [papi.how](https://papi.how/) for generic documentation on \`polkadot-api\`
 * 
 * @packageDocumentation
 */

${hasSection.storage ? `/**
 * Storage queries reference
 * 
 * Each item described here is a
 *\`StorageDescriptor<Args, ReturnType, Optional, Opaque>\`  
 * For example, \`System.Account\` is of type
 * \`\`\`ts
 * Account: StorageDescriptor<[Key: SS58String], {
 *     consumers: number;
 *     data: {
 *         flags: bigint;
 *         free: bigint;
 *         frozen: bigint;
 *         reserved: bigint;
 *     };
 *     nonce: number;
 *     providers: number;
 *     sufficients: number;
 * }, false, "never">
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const account = await api.query.System.Account.getValue("<AccountId>")
 * console.log(account.data.free)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/queries) on storage queries for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Storage from "./Storage";

` : ""}
${hasSection.constants ? `/**
 * Constants reference
 * 
 * Each item described here is a \`PlainDescriptor<T>\`  
 * 
 * For example, \`System.Version\` is of type
 * \`\`\`ts
 * Version: PlainDescriptor<{
 *     apis: [FixedSizeBinary<8>, number][];
 *     authoring_version: number;
 *     impl_name: string;
 *     impl_version: number;
 *     spec_name: string;
 *     spec_version: number;
 *     state_version: number;
 *     transaction_version: number;
 * }>
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const version = await typedApi.constants.System.Version()
 * console.log(version.spec_version)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/constants) on constants for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Constants from "./Constants";

` : ""}
${hasSection.errors ? `/**
 * Errors
 * 
 * This section is temporarily commented out, 
 * as errors aren't documented in papi yet
 * https://github.com/polkadot-api/polkadot-api-docs/issues/25 
 * 
 * @namespace
 * @category Types
 */
// export * as Errors from "./Errors";

` : ""}
${hasSection.calls ? `/**
 * Transactions reference
 * 
 * Each item described here is a \`TxDescriptor<T>\`, where \`T\` describes
 * all the arguments required by the extrinsic
 * 
 * For example, \`Balances.transfer_keep_alive\` is of type
 * \`\`\`ts
 * transfer_keep_alive: TxDescriptor<{
 *     dest: MultiAddress;
 *     value: bigint;
 * }>
 * \`\`\`
 * and can be used like this
 * \`\`\`ts
 * const tx = api.tx.Balances.transfer_keep_alive({
 *   dest: MultiAddress.Id(userAddress),
 *   value: 10n ** 10n, // 1 DOT
 * })
 * await tx.signAndSubmit(signer)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/tx) on transactions for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Transactions from "./Transactions";

` : ""}
${hasSection.events ? `/**
 * Events
 * 
 * Each item described here is a \`PlainDescriptor<T>\`  
 * 
 * For example, \`System.NewAccount\` is of type
 * \`\`\`ts
 * NewAccount: PlainDescriptor<{ "account": SS58String }>;
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const newAccountEvents = await api.event.System.NewAccount.pull()
 * newAccountEvents.forEach(newAccount => {
 *  const address: SS58String = newAccount.payload.account
 *  console.log(address)
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/events) on events for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Events from "./Events";

` : ""}
${hasSection.viewFns ? `/**
 * View Functions
 * 
 * Each item described here is a \`RuntimeDescriptor<Args, ReturnType>\`
 * 
 * For example, \`Proxy.is_superset\` is of type
 * \`\`\`ts
 * is_superset: RuntimeDescriptor<[to_check: ProxyType, against: ProxyType], boolean>
 * \`\`\`
 * and can be called like this:
 * \`\`\`ts
 *  const isSuperset = await api.view.Proxy.is_superset(Enum("Any"), Enum("NonTransfer"))
 *  console.log(isSuperset)
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/view) on view functions for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as ViewFunctions from "./ViewFunctions";

` : ""}
${hasSection.runtimeCalls ? `/**
 * Runtime calls
 * 
 * Each item described here is a \`RuntimeDescriptor<Args, ReturnType>\`
 * 
 * For example, \`Metadata.metadata_at_version\` is of type
 * \`\`\`ts
 * metadata_at_version: RuntimeDescriptor<[version: number], Binary | undefined>
 * \`\`\`
 * and can be called like this:
 * \`\`\`ts
 *  const metadata = await api.apis.Metadata.metadata_at_version(15)
 *  console.log(metadata?.asHex())
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/apis) on runtime APIs for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as RuntimeCalls from "./RuntimeCalls";

` : ""}
/**
 * Descriptors types
 * 
 * These are the types used in API calls and imported out of descriptors  
 * 
 * For example, \`XcmVersionedLocation\` is an enum:
 * \`\`\`ts
 * XcmVersionedLocation: Enum<{
 *     V2: { ... };
 *     V3: {
 *         interior: XcmV3Junctions;
 *         parents: number;
 *     };
 *     V4: { ... };
 * }>
 * \`\`\`
 * and can be used like this
 * \`\`\`ts
 * import { XcmVersionedLocation, XcmV3Junctions } from "@polkadot-api/descriptors"
 * await typedApi.tx.XcmPallet.limited_teleport_assets({
      dest: XcmVersionedLocation.V3({
        parents: 0,
        interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(parachain_id)),
      }),
 * \`\`\`
 * 
 * @namespace
 * @category Types
 */
export * as Types from "./types";`;
}

export { generateDocsDescriptors };
//# sourceMappingURL=generate-docs-descriptors.mjs.map
