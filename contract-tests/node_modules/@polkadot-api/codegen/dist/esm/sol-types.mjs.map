{"version":3,"file":"sol-types.mjs","sources":["../../src/sol-types.ts"],"sourcesContent":["type AbiPrimitive =\n  | `uint${number}`\n  | `uint`\n  | `int${number}`\n  | `int`\n  | \"address\"\n  | \"bool\"\n  | `fixed${number}x${number}`\n  | `ufixed${number}x${number}`\n  | \"fixed\"\n  | \"ufixed\"\n  | `bytes${number}`\n  | \"function\"\n  | \"bytes\"\n  | \"string\"\n\ntype AbiType =\n  | AbiPrimitive\n  | `${AbiPrimitive}[${number}]`\n  | `${AbiPrimitive}[]`\n  | `tuple`\n\ntype TypedVariable = {\n  name: string\n  type: AbiType\n  components: TypedVariable[]\n}\ntype FunctionAbi = {\n  type: \"function\" | \"constructor\" | \"receive\" | \"fallback\"\n  name?: string\n  inputs?: Array<TypedVariable>\n  outputs?: Array<TypedVariable>\n  stateMutability: \"pure\" | \"view\" | \"nonpayable\" | \"payable\"\n}\n\ntype EventAbi = {\n  type: \"event\"\n  name: string\n  inputs: Array<TypedVariable>\n  anonymous?: boolean\n}\n\ntype ErrorAbi = {\n  type: \"error\"\n  name: string\n  inputs: Array<TypedVariable>\n}\n\ntype Abi = Array<FunctionAbi | EventAbi | ErrorAbi>\n\nconst intRegex = /^u?int(\\d+)$/\nconst fixedRegex = /^u?fixed\\d+x(\\d+)$/\nfunction generatePrimitiveType(primitive: AbiPrimitive) {\n  switch (primitive) {\n    case \"uint\":\n    case \"int\":\n      return \"bigint\"\n    case \"address\":\n      return \"Address\"\n    case \"bool\":\n      return \"boolean\"\n    case \"fixed\":\n    case \"ufixed\":\n      // Spec'ed, but not implemented in solc yet.\n      return \"Decimal<18>\"\n    case \"function\":\n      return \"FunctionRef\"\n    case \"bytes\":\n      return \"Binary\"\n    case \"string\":\n      return \"string\"\n  }\n\n  if (primitive.startsWith(\"bytes\")) {\n    return \"Binary\"\n  }\n\n  const intMatch = intRegex.exec(primitive)\n  if (intMatch) {\n    return Number(intMatch[1]) > 53 ? \"bigint\" : \"number\"\n  }\n\n  const fixedMatch = fixedRegex.exec(primitive)\n  if (fixedMatch) {\n    return `Decimal<${fixedMatch[1]}>`\n  }\n\n  throw new Error(\"Can't map \" + primitive)\n}\n\nconst arrayRegex = /^(.+)\\[(\\d+)\\]$/\nfunction generateVariableType(variable: TypedVariable): string {\n  if (variable.type === \"tuple\") {\n    return generateStructType(variable.components)\n  }\n\n  if (variable.type.endsWith(\"[]\")) {\n    return `Array<${generateVariableType({\n      ...variable,\n      type: variable.type.replace(\"[]\", \"\") as AbiType,\n    })}>`\n  }\n\n  const arrayMatch = arrayRegex.exec(variable.type)\n  if (arrayMatch) {\n    return `Array<${generatePrimitiveType(arrayMatch[1] as AbiPrimitive)}>`\n  }\n\n  return generatePrimitiveType(variable.type as AbiPrimitive)\n}\n\nfunction generateStructType(params?: Array<TypedVariable>): string {\n  if (!params || !params.length) return `{}`\n\n  const unnamedTypes = params.filter((v) => !v.name)\n  const namedTypes = params.filter((v) => !!v.name)\n\n  if (namedTypes.length == 0) {\n    if (unnamedTypes.length === 1) {\n      return generateVariableType(unnamedTypes[0])\n    }\n\n    return \"[\" + unnamedTypes.map(generateVariableType).join(\", \") + \"]\"\n  }\n\n  if (unnamedTypes.length) {\n    namedTypes.push({\n      name: \"args\",\n      type: \"tuple\",\n      components: unnamedTypes,\n    })\n  }\n\n  return `{${namedTypes.map((v): string => `\"${v.name}\": ${generateVariableType(v)}`).join(\",\\n\")}}`\n}\n\nfunction generateFunctionType(fnAbi: FunctionAbi) {\n  if (!fnAbi.name) {\n    console.log(fnAbi)\n    throw new Error(\"Function needs a name\")\n  }\n  return `\"${fnAbi.name}\": { message: ${generateStructType(fnAbi.inputs)}, response: ${generateStructType(fnAbi.outputs)} }`\n}\n\nexport function generateSolTypes(abi: Abi) {\n  const messages = abi.filter((v) => v.type === \"function\") as FunctionAbi[]\n\n  const receive = abi.find((v) => v.type === \"receive\") as\n    | FunctionAbi\n    | undefined\n  if (receive) {\n    messages.push({\n      name: \"receive\",\n      ...receive,\n      type: \"function\",\n    })\n  }\n\n  const fallback = abi.find((v) => v.type === \"fallback\") as\n    | FunctionAbi\n    | undefined\n  if (fallback) {\n    messages.push({\n      name: \"fallback\",\n      ...fallback,\n      type: \"function\",\n    })\n  }\n\n  const messagesDescriptor = `{ ${messages.map(generateFunctionType).join(\",\\n\")} }`\n\n  const constructor = (abi.find((v) => v.type === \"constructor\") as\n    | FunctionAbi\n    | undefined) ?? {\n    type: \"constructor\",\n    stateMutability: \"pure\",\n  }\n\n  const constructorsDescriptor = `{ ${generateFunctionType({\n    name: \"new\",\n    ...constructor,\n  })} }`\n\n  const events = abi.filter((v) => v.type === \"event\")\n  const eventsDescriptor = `Enum<{\n    ${events.map((evt) => `\"${evt.name}\": ${generateStructType(evt.inputs)}`).join(\",\\n\")}\n  }>`\n\n  const result = `\n    import type { InkDescriptors } from 'polkadot-api/ink';\n    import type { HexString, Enum, Binary } from 'polkadot-api';\n\n    type Address = HexString\n    type Decimal<T extends number> = { value: bigint, decimals: T }\n    type FunctionRef = { address: Address, selector: HexString }\n\n    type StorageDescriptor = {};\n    type MessagesDescriptor = ${messagesDescriptor};\n    type ConstructorsDescriptor = ${constructorsDescriptor};\n    type EventDescriptor = ${eventsDescriptor};\n\n    export const descriptor: InkDescriptors<StorageDescriptor, MessagesDescriptor, ConstructorsDescriptor, EventDescriptor> = { abi: ${JSON.stringify(abi)} } as any;\n  `\n\n  return result\n}\n"],"names":[],"mappings":"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"}