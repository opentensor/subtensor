import { mapObject, filterObject } from '@polkadot-api/utils';
import { anonymizeImports, anonymizeType } from './anonymize.mjs';

const isDocs = (x) => {
  if (typeof x !== "object") return false;
  const keys = new Set(Object.keys(x));
  if (keys.size !== 2) return false;
  return keys.has("docs") && keys.has("value");
};
const customStringifyObject = (input) => {
  if (typeof input === "string" || typeof input === "number") return input;
  if (Array.isArray(input))
    return `[${input.map(customStringifyObject).join(", ")}]`;
  return `{${Object.entries(
    mapObject(input, (x) => isDocs(x) ? x : customStringifyObject(x))
  ).map(([key, value]) => {
    if (isDocs(value)) {
      return `

/**
${value.docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
 */
${key}: ${customStringifyObject(value.value)}`;
    }
    return `${key}: ${value}`;
  }).join(",\n")}}`;
};
function capitalize(value) {
  return value.slice(0, 1).toUpperCase() + value.slice(1);
}
const generateDescriptors = (lookupFn, checksumToIdx, typesBuilder, checksumBuilder, key, paths, genesis) => {
  const prefix = capitalize(key);
  const { metadata } = lookupFn;
  const buildEnumObj = (val, cb) => {
    if (val === void 0) return {};
    const lookup = metadata.lookup[val];
    if (lookup.def.tag !== "variant") throw null;
    return Object.fromEntries(
      lookup.def.value.map((x) => {
        return [x.name, cb(x.name, x.docs)];
      })
    );
  };
  const storage = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        Object.fromEntries(
          pallet.storage?.items.map(({ name, modifier, docs }) => {
            const { key: key2, val, opaque } = typesBuilder.buildStorage(
              pallet.name,
              name
            );
            const checksum = checksumBuilder.buildStorage(pallet.name, name);
            const type = `StorageDescriptor<${key2}, ${val === "undefined" ? "null" : val}, ${!modifier}, ${opaque}>`;
            return [
              name,
              {
                typeRef: checksumToIdx.get(checksum),
                type,
                name: `stg_${pallet.name}_${name}`,
                docs
              }
            ];
          }) ?? []
        )
      ];
    })
  );
  const constants = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        Object.fromEntries(
          pallet.constants?.map(({ name, docs }) => {
            const checksum = checksumBuilder.buildConstant(pallet.name, name);
            const type = `PlainDescriptor<${typesBuilder.buildConstant(
              pallet.name,
              name
            )}>`;
            return [
              name,
              {
                typeRef: checksumToIdx.get(checksum),
                type,
                name: `const_${pallet.name}_${name}`,
                docs
              }
            ];
          }) ?? []
        )
      ];
    })
  );
  const calls = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        buildEnumObj(pallet.calls?.type, (name, docs) => ({
          typeRef: checksumToIdx.get(
            checksumBuilder.buildCall(pallet.name, name)
          ),
          type: `TxDescriptor<${typesBuilder.buildCall(pallet.name, name)}>`,
          name: `call_${pallet.name}_${name}`,
          docs
        }))
      ];
    })
  );
  const events = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        buildEnumObj(pallet.events?.type, (name, docs) => ({
          typeRef: checksumToIdx.get(
            checksumBuilder.buildEvent(pallet.name, name)
          ),
          type: `PlainDescriptor<${typesBuilder.buildEvent(
            pallet.name,
            name
          )}>`,
          name: `evt_${pallet.name}_${name}`,
          docs
        }))
      ];
    })
  );
  const errors = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        buildEnumObj(pallet.errors?.type, (name, docs) => {
          return {
            typeRef: checksumToIdx.get(
              checksumBuilder.buildError(pallet.name, name)
            ),
            type: `PlainDescriptor<${typesBuilder.buildError(
              pallet.name,
              name
            )}>`,
            name: `err_${pallet.name}_${name}`,
            docs
          };
        })
      ];
    })
  );
  const viewFns = Object.fromEntries(
    metadata.pallets.map((pallet) => [
      pallet.name,
      Object.fromEntries(
        pallet.viewFns.map((viewFn) => {
          const { args, value } = typesBuilder.buildViewFn(
            pallet.name,
            viewFn.name
          );
          return [
            viewFn.name,
            {
              typeRef: checksumToIdx.get(
                checksumBuilder.buildViewFns(pallet.name, viewFn.name)
              ),
              type: `RuntimeDescriptor<${args}, ${value}>`,
              name: `view_${pallet.name}_${viewFn.name}`,
              docs: viewFn.docs
            }
          ];
        })
      )
    ])
  );
  const runtimeCalls = Object.fromEntries(
    metadata.apis.map((api) => [
      api.name,
      {
        docs: api.docs,
        methods: Object.fromEntries(
          api.methods.map((method) => {
            const { args, value } = typesBuilder.buildRuntimeCall(
              api.name,
              method.name
            );
            return [
              method.name,
              {
                typeRef: checksumToIdx.get(
                  checksumBuilder.buildRuntimeCall(api.name, method.name)
                ),
                type: `RuntimeDescriptor<${args}, ${value}>`,
                name: `runtime_${api.name}_${method.name}`,
                docs: method.docs
              }
            ];
          })
        )
      }
    ])
  );
  const mapDescriptor = (descriptor, mapFn) => filterObject(
    mapObject(
      descriptor,
      (v, pallet) => mapObject(v, (value, name) => mapFn(value, pallet, name))
    ),
    (v) => Object.keys(v).length > 0
  );
  const extractValue = (input) => ({
    docs: input.docs,
    value: input.type
  });
  const iStorage = mapDescriptor(storage, extractValue);
  const iCalls = mapDescriptor(calls, extractValue);
  const iEvents = mapDescriptor(events, extractValue);
  const iErrors = mapDescriptor(errors, extractValue);
  const iConstants = mapDescriptor(constants, extractValue);
  const iViewFns = mapDescriptor(viewFns, extractValue);
  const descriptorValues = {
    storage: {},
    tx: {},
    events: {},
    constants: {},
    viewFns: {},
    apis: {}
  };
  const mapObjStr = mapObject;
  Object.keys(storage).forEach((pallet) => {
    descriptorValues["storage"][pallet] = mapObjStr(
      storage[pallet],
      (x) => x.typeRef
    );
    descriptorValues["tx"][pallet] = mapObjStr(calls[pallet], (x) => x.typeRef);
    descriptorValues["events"][pallet] = mapObjStr(
      events[pallet],
      (x) => x.typeRef
    );
    descriptorValues["constants"][pallet] = mapObjStr(
      constants[pallet],
      (x) => x.typeRef
    );
    descriptorValues["viewFns"][pallet] = mapObjStr(
      viewFns[pallet],
      (x) => x.typeRef
    );
  });
  const iRuntimeCalls = mapObject(runtimeCalls, (api) => ({
    docs: api.docs,
    value: mapObject(api.methods, ({ docs, type: value }) => ({ docs, value }))
  }));
  if (lookupFn.call) {
    typesBuilder.buildDefinition(lookupFn.call);
  }
  const callInterface = lookupFn.call ? `I${checksumBuilder.buildDefinition(lookupFn.call)}` : null;
  const chainCallType = callInterface ? `export type ${prefix}CallData = Anonymize<${callInterface}> & { value: { type: string } };` : "";
  descriptorValues["apis"] = mapObject(
    runtimeCalls,
    (api) => mapObject(api.methods, (x) => x.typeRef)
  );
  const clientImports = [
    .../* @__PURE__ */ new Set([
      "StorageDescriptor",
      "PlainDescriptor",
      "TxDescriptor",
      "RuntimeDescriptor",
      "Enum",
      "_Enum",
      "GetEnum",
      "ApisFromDef",
      "QueryFromPalletsDef",
      "TxFromPalletsDef",
      "EventsFromPalletsDef",
      "ErrorsFromPalletsDef",
      "ConstFromPalletsDef",
      "ViewFnsFromPalletsDef",
      ...typesBuilder.getClientFileImports(),
      ...anonymizeImports
    ])
  ];
  const assetId = getAssetId(lookupFn);
  const assetType = assetId == null ? "void" : typesBuilder.buildTypeDefinition(assetId);
  const dispatchErrorId = getDispatchErrorId(lookupFn);
  const dispatchErrorType = dispatchErrorId == null ? "unknown" : typesBuilder.buildTypeDefinition(dispatchErrorId);
  const commonTypeImports = typesBuilder.getTypeFileImports();
  const exports = [
    `default as ${key}`,
    callInterface ? `${prefix}CallData` : null
  ].filter((v) => v !== null);
  const imports = `import {${clientImports.join(", ")}} from "${paths.client}";
  import {${commonTypeImports.join(", ")}} from "${paths.types}";
  import { toBinary } from "${paths.common}"

  const descriptorValues = import("${paths.descriptorValues}").then(module => module["${prefix}"]);
  const metadataTypes = import("${paths.metadataTypes}").then(
    module => toBinary('default' in module ? module.default : module)
  );
  `;
  const descriptorTypes = `${imports}

${anonymizeType}

type IStorage = ${customStringifyObject(iStorage)};
type ICalls = ${customStringifyObject(iCalls)};
type IEvent = ${customStringifyObject(iEvents)};
type IError = ${customStringifyObject(iErrors)};
type IConstants = ${customStringifyObject(iConstants)};
type IViewFns = ${customStringifyObject(iViewFns)};
type IRuntimeCalls = ${customStringifyObject(iRuntimeCalls)};
type IAsset = PlainDescriptor<${assetType}>
export type ${prefix}DispatchError = ${dispatchErrorType}
const asset: IAsset = {} as IAsset
const getMetadata: () => Promise<Uint8Array> = () => import("./${key}_metadata").then(
  module => toBinary('default' in module ? module.default : module)
)
const genesis: string | undefined = ${genesis ? `"${genesis}"` : void 0}

type PalletsTypedef = {
  __storage: IStorage,
  __tx: ICalls,
  __event: IEvent,
  __error: IError,
  __const: IConstants
  __view: IViewFns
}

export type ${prefix} = {
  descriptors: {
    pallets: PalletsTypedef,
    apis: IRuntimeCalls
  } & Promise<any>,
  metadataTypes: Promise<Uint8Array>
  asset: IAsset
  getMetadata: () => Promise<Uint8Array>
  genesis: string | undefined
};
const _allDescriptors = { descriptors: descriptorValues, metadataTypes, asset, getMetadata, genesis } as any as ${prefix};
export default _allDescriptors;

export type ${prefix}Apis = ApisFromDef<IRuntimeCalls>
export type ${prefix}Queries = QueryFromPalletsDef<PalletsTypedef>
export type ${prefix}Calls = TxFromPalletsDef<PalletsTypedef>
export type ${prefix}Events = EventsFromPalletsDef<PalletsTypedef>
export type ${prefix}Errors = ErrorsFromPalletsDef<PalletsTypedef>
export type ${prefix}Constants = ConstFromPalletsDef<PalletsTypedef>
export type ${prefix}ViewFns = ViewFnsFromPalletsDef<PalletsTypedef>
${chainCallType}

export type ${prefix}WhitelistEntry =
  | PalletKey
  | ApiKey<IRuntimeCalls>
  | \`query.\${NestedKey<PalletsTypedef['__storage']>}\`
  | \`tx.\${NestedKey<PalletsTypedef['__tx']>}\`
  | \`event.\${NestedKey<PalletsTypedef['__event']>}\`
  | \`error.\${NestedKey<PalletsTypedef['__error']>}\`
  | \`const.\${NestedKey<PalletsTypedef['__const']>}\`
  | \`view.\${NestedKey<PalletsTypedef['__view']>}\`

type PalletKey = \`*.\${keyof (IStorage & ICalls & IEvent & IError & IConstants & IRuntimeCalls & IViewFns)}\`
type NestedKey<D extends Record<string, Record<string, any>>> =
  | "*"
  | {
      [P in keyof D & string]:
        | \`\${P}.*\`
        | {
            [N in keyof D[P] & string]: \`\${P}.\${N}\`
          }[keyof D[P] & string]
    }[keyof D & string]

type ApiKey<D extends Record<string, Record<string, any>>> =
  | "api.*"
  | {
      [P in keyof D & string]:
        | \`api.\${P}.*\`
        | {
            [N in keyof D[P] & string]: \`api.\${P}.\${N}\`
          }[keyof D[P] & string]
    }[keyof D & string]
`;
  return { descriptorTypes, descriptorValues, exports, commonTypeImports };
};
function getAssetId(lookup) {
  const assetPayment = lookup.metadata.extrinsic.signedExtensions.find(
    (x) => x.identifier === "ChargeAssetTxPayment"
  );
  if (assetPayment) {
    const assetTxPayment = lookup(assetPayment.type);
    if (assetTxPayment.type === "struct") {
      const optionalAssetId = assetTxPayment.value.asset_id;
      if (optionalAssetId.type === "option") return optionalAssetId.value.id;
    }
  }
  return;
}
function getDispatchErrorId(lookup) {
  const systemPalletEventId = lookup.metadata.pallets.find(
    (p) => p.name === "System"
  )?.events;
  if (systemPalletEventId == null) return;
  const systemPalletEvent = lookup(systemPalletEventId.type);
  if (systemPalletEvent.type !== "enum") return;
  const extrinsicFailed = systemPalletEvent.value.ExtrinsicFailed;
  if (extrinsicFailed?.type !== "struct") return;
  return extrinsicFailed.value.dispatch_error.id;
}

export { capitalize, customStringifyObject, generateDescriptors, getAssetId, getDispatchErrorId };
//# sourceMappingURL=generate-descriptors.mjs.map
