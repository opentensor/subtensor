import { anonymizeImports, anonymizeType } from './anonymize.mjs';
import { getInternalTypesBuilder } from './internal-types/internal-types-builder.mjs';
import { isPrimitive } from './internal-types/type-representation.mjs';
import { mergeImports, generateTypescript, processPapiPrimitives, nativeNodeCodegen } from './internal-types/generate-typescript.mjs';
import { getReusedNodes } from './internal-types/reused-nodes.mjs';

function generateInkTypes(lookup) {
  const internalBuilder = getInternalTypesBuilder(lookup);
  const buildCallable = (callable) => {
    const call = {
      type: "struct",
      value: callable.args.map((param) => ({
        label: param.label,
        value: internalBuilder(param.type.type),
        docs: []
      }))
    };
    return {
      call,
      value: internalBuilder(callable.returnType.type)
    };
  };
  const constructors = lookup.metadata.spec.constructors.map((ct) => ({
    ...ct,
    types: buildCallable(ct)
  }));
  const messages = lookup.metadata.spec.messages.map((ct) => ({
    ...ct,
    types: buildCallable(ct)
  }));
  const event = {
    type: "enum",
    value: lookup.metadata.spec.events.map(
      (evt) => ({
        label: evt.label,
        value: {
          type: "struct",
          value: evt.args.map(
            (arg) => ({
              label: arg.label,
              value: internalBuilder(arg.type.type),
              docs: arg.docs
            })
          )
        },
        docs: evt.docs
      })
    )
  };
  const storageRoots = Object.entries(lookup.storage).map(([name, value]) => ({
    name,
    key: value.key !== null ? internalBuilder(value.key) : null,
    value: internalBuilder(value.typeId)
  }));
  const storageRoot = {
    type: "struct",
    value: storageRoots.map(({ name, key, value }) => ({
      docs: [],
      label: name,
      value: {
        type: "struct",
        value: [
          {
            docs: [],
            label: "key",
            value: key ?? { type: "primitive", value: "undefined" }
          },
          {
            docs: [],
            label: "value",
            value
          }
        ]
      }
    }))
  };
  const entryPoints = [
    storageRoot,
    ...constructors.flatMap((v) => [v.types.call, v.types.value]),
    ...messages.flatMap((v) => [v.types.call, v.types.value])
  ];
  const rootNodes = getReusedNodes(entryPoints, /* @__PURE__ */ new Set());
  const assignedNames = {};
  let nextAnonymousId = 0;
  const getName = (id) => {
    if (!assignedNames[id]) {
      assignedNames[id] = `T${nextAnonymousId++}`;
    }
    return assignedNames[id];
  };
  const filteredRootNodes = Array.from(rootNodes).filter(
    (id) => !isPrimitive(internalBuilder(id))
  );
  const types = {};
  const generateNodeType = (node) => {
    const anonymize = (name) => `Anonymize<${name}>`;
    const result2 = generateTypescript(node, (node2, next) => {
      if (!("id" in node2) || isPrimitive(node2)) {
        return processPapiPrimitives(node2, next, true) ?? nativeNodeCodegen(node2, next);
      }
      if (types[node2.id]) {
        const cached = types[node2.id];
        return cached.name ? {
          code: anonymize(cached.name),
          imports: {
            types: /* @__PURE__ */ new Set([cached.name])
          }
        } : cached;
      }
      const assignedName = assignedNames[node2.id] ?? (filteredRootNodes.includes(node2.id) ? getName(node2.id) : null);
      if (assignedName) {
        types[node2.id] = {
          code: "",
          imports: {},
          name: assignedName
        };
      }
      const result3 = processPapiPrimitives(node2, next, true) ?? nativeNodeCodegen(node2, next);
      if (assignedName) {
        types[node2.id].code = result3.code;
        types[node2.id].imports = result3.imports;
        return {
          code: anonymize(assignedName),
          imports: {
            types: /* @__PURE__ */ new Set([assignedName])
          }
        };
      }
      types[node2.id] = result3;
      return types[node2.id];
    });
    if ("id" in node && types[node.id]?.name) {
      const name = types[node.id].name;
      return {
        code: anonymize(name),
        imports: {
          types: /* @__PURE__ */ new Set([name])
        }
      };
    }
    return result2;
  };
  const inlineField = (label, type) => ({
    label,
    value: {
      type: "inline",
      value: type
    },
    docs: []
  });
  const createCallableDescriptor = (callables) => generateNodeType({
    type: "struct",
    value: callables.map(
      (callable) => ({
        label: callable.label,
        value: {
          type: "struct",
          value: [
            {
              label: "message",
              value: callable.types.call,
              docs: []
            },
            {
              label: "response",
              value: callable.types.value,
              docs: []
            },
            ...callable.default ? [inlineField("default", "true")] : [],
            ...callable.payable ? [inlineField("payable", "true")] : [],
            ...callable.mutates ? [inlineField("mutates", "true")] : []
          ]
        },
        docs: callable.docs
      })
    )
  });
  const constructorsDescriptor = createCallableDescriptor(constructors);
  const messagesDescriptor = createCallableDescriptor(messages);
  const eventDescriptor = generateNodeType(event);
  const storageTypes = generateNodeType(storageRoot);
  const namedTypes = Object.entries(assignedNames).filter(([id]) => types[Number(id)]).map(([id, value]) => `type ${value} = ${types[Number(id)].code};`).join("\n");
  const clientImports = Array.from(
    mergeImports([
      storageTypes.imports,
      messagesDescriptor.imports,
      constructorsDescriptor.imports,
      eventDescriptor.imports,
      ...Object.values(types).map((v) => v.imports),
      {
        client: new Set(anonymizeImports)
      }
    ]).client
  );
  const result = `
    import type { ${clientImports.join(", ")} } from 'polkadot-api';
    import type { InkDescriptors } from 'polkadot-api/ink';

    ${anonymizeType}

    ${namedTypes}

    type StorageDescriptor = ${storageTypes.code};
    type MessagesDescriptor = ${messagesDescriptor.code};
    type ConstructorsDescriptor = ${constructorsDescriptor.code};
    type EventDescriptor = ${eventDescriptor.code};

    export const descriptor: InkDescriptors<StorageDescriptor, MessagesDescriptor, ConstructorsDescriptor, EventDescriptor> = { metadata: ${JSON.stringify(lookup.metadata)} } as any;
  `;
  return result;
}

export { generateInkTypes };
//# sourceMappingURL=ink-types.mjs.map
