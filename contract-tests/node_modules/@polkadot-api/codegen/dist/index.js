'use strict';

var metadataBuilders = require('@polkadot-api/metadata-builders');
var utils = require('@polkadot-api/utils');
var metadataCompatibility = require('@polkadot-api/metadata-compatibility');

const withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id)) return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id)) {
    result = onExitCircular(result, cache.get(id), input, ...rest);
  }
  cache.set(id, result);
  return result;
};

const primitiveTypes = {
  bool: "boolean",
  char: "string",
  str: "string",
  u8: "number",
  u16: "number",
  u32: "number",
  u64: "bigint",
  u128: "bigint",
  u256: "bigint",
  i8: "number",
  i16: "number",
  i32: "number",
  i64: "bigint",
  i128: "bigint",
  i256: "bigint",
  compactNumber: "number",
  compactBn: "bigint"
};
const buildType = withCache(
  (input, cache, stack) => {
    const buildNextType = (nextInput) => buildType(nextInput, cache, stack);
    const ltn = (type, value) => ({
      id: input.id,
      type,
      value
    });
    if (input.type === "primitive")
      return ltn("primitive", primitiveTypes[input.value]);
    if (input.type === "void") return ltn("primitive", "undefined");
    if (input.type === "AccountId20") return ltn("chainPrimitive", "HexString");
    if (input.type === "AccountId32") return ltn("chainPrimitive", "SS58String");
    if (input.type === "compact") {
      const value = [];
      value.push({
        type: "primitive",
        value: input.isBig ? "bigint" : "number"
      });
      return ltn("union", value);
    }
    if (input.type === "bitSequence")
      return ltn("chainPrimitive", "BitSequence");
    if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8")
      return ltn("chainPrimitive", "Binary");
    const buildArray = (array) => {
      const { value, len } = array;
      if (value.type === "primitive" && value.value === "u8") {
        return { type: "fixedSizeBinary", value: len };
      }
      return {
        type: "array",
        value: { value: buildNextType(value), len },
        original: array
      };
    };
    const buildTuple = (tuple) => {
      const { value, innerDocs } = tuple;
      return {
        type: "tuple",
        value: value.map((v, i) => ({
          value: buildNextType(v),
          docs: innerDocs[i] ?? []
        })),
        original: tuple
      };
    };
    const buildStruct = (struct) => {
      const { value, innerDocs } = struct;
      return {
        type: "struct",
        value: Object.entries(value).map(([label, value2]) => ({
          label,
          docs: innerDocs[label] ?? [],
          value: buildNextType(value2)
        })),
        original: struct
      };
    };
    if (input.type === "array") return { id: input.id, ...buildArray(input) };
    if (input.type === "sequence")
      return ltn("array", { value: buildNextType(input.value) });
    if (input.type === "tuple") return { id: input.id, ...buildTuple(input) };
    if (input.type === "struct") return { id: input.id, ...buildStruct(input) };
    if (input.type === "option")
      return ltn("option", buildNextType(input.value));
    if (input.type === "result")
      return ltn("result", {
        ok: buildNextType(input.value.ok),
        ko: buildNextType(input.value.ko)
      });
    const buildInnerType = (value) => {
      switch (value.type) {
        case "lookupEntry":
          return buildNextType(value.value);
        case "void":
          return void 0;
        case "array":
          return buildArray(value);
        case "struct":
          return buildStruct(value);
        case "tuple":
          return buildTuple(value);
      }
    };
    const variants = Object.entries(input.value).map(
      ([label, value]) => ({
        docs: input.innerDocs[label] ?? [],
        label,
        value: buildInnerType(value)
      })
    );
    return ltn("enum", variants);
  },
  (_, circular) => ({
    id: circular.id,
    optional: circular.type === "option",
    type: "primitive",
    value: "undefined"
  }),
  (result, tmp) => Object.assign(tmp, result)
);
const getInternalTypesBuilder = (lookup) => {
  const cache = /* @__PURE__ */ new Map();
  return (id) => buildType(lookup(id), cache, /* @__PURE__ */ new Set());
};

const isPrimitive = (node) => ["chainPrimitive", "primitive", "fixedSizeBinary", "inline"].includes(
  node.type
);

const nativeNodeCodegen = (node, next) => {
  if (node.type === "primitive" || node.type === "inline")
    return onlyCode(node.value);
  if (node.type === "chainPrimitive")
    throw new Error("Can't generate chain primitive type " + node.value);
  if (node.type === "result" || node.type === "enum" || node.type === "fixedSizeBinary")
    throw new Error("Can't generate chain primitive type " + node.type);
  if (node.type === "array") {
    const { code, imports } = next(node.value.value);
    return { code: `Array<${code}>`, imports };
  }
  if (node.type === "struct") {
    return generateObjectCode(node.value, next);
  }
  if (node.type === "tuple") {
    const tupleResults = node.value.map(({ value }) => next(value));
    return {
      code: `[${tupleResults.map(({ code }) => code).join(", ")}]`,
      imports: mergeImports(tupleResults.map(({ imports }) => imports))
    };
  }
  if (node.type === "union") {
    if (node.value.length === 1) return next(node.value[0]);
    const partResults = node.value.map(next);
    return {
      code: partResults.map(({ code }) => `(${code})`).join(" | "),
      imports: mergeImports(partResults.map(({ imports }) => imports))
    };
  }
  const optionResult = next(node.value);
  return {
    code: `(${optionResult.code}) | undefined`,
    imports: optionResult.imports
  };
};
function generateTypescript(node, getNodeCode) {
  const next = (node2, level) => getNodeCode(node2, (v) => next(v, level + 1), level);
  return next(node, 0);
}
function processPapiPrimitives(node, getCode, isKnown) {
  const clientImport = (value) => ({ client: /* @__PURE__ */ new Set([value]) });
  if (node.type === "chainPrimitive") {
    return node.value === "BitSequence" ? onlyCode(`Array<0 | 1>`) : {
      code: node.value,
      imports: {
        client: /* @__PURE__ */ new Set([node.value])
      }
    };
  }
  if (node.type === "result") {
    const okResult = getCode(node.value.ok);
    const koResult = getCode(node.value.ko);
    return {
      code: `ResultPayload<${okResult.code}, ${koResult.code}>`,
      imports: mergeImports([
        okResult.imports,
        koResult.imports,
        clientImport("ResultPayload")
      ])
    };
  }
  if (node.type === "enum") {
    const innerCode = generateObjectCode(node.value, getCode);
    if (!isKnown) {
      return {
        code: `AnonymousEnum<${innerCode.code}>`,
        imports: innerCode.imports
      };
    }
    return {
      code: `Enum<${innerCode.code}>`,
      imports: mergeImports([innerCode.imports, clientImport("Enum")])
    };
  }
  if (node.type === "fixedSizeBinary") {
    return {
      code: `FixedSizeBinary<${node.value}>`,
      imports: clientImport("FixedSizeBinary")
    };
  }
  if (node.type === "array" && node.value.len) {
    const { code, imports } = getCode(node.value.value);
    return {
      code: `FixedSizeArray<${node.value.len}, ${code}>`,
      imports: mergeImports([imports, clientImport("FixedSizeArray")])
    };
  }
  return null;
}
const generateObjectCode = (fields, next) => {
  const innerValues = fields.map((field) => ({
    ...field,
    result: field.value ? next(field.value) : null
  }));
  return {
    code: `{${innerValues.map(({ label, docs, value, result }) => {
      const docsPrefix = docs.length ? `
/**
${docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
 */
` : "";
      if (result === null)
        return docsPrefix + `${JSON.stringify(label)}: undefined`;
      const isOptional = value?.type === "option";
      const key = JSON.stringify(label) + (isOptional ? "?" : "");
      return docsPrefix + `${key}: ${result.code}`;
    }).join(", ")}}`,
    imports: mergeImports(innerValues.map((v) => v.result?.imports ?? {}))
  };
};
const mergeImports = (imports) => {
  if (!imports.length) return {};
  const result = { ...imports[0] };
  for (let i = 1; i < imports.length; i++) {
    Object.entries(imports[i]).forEach(
      ([type, value]) => result[type] = /* @__PURE__ */ new Set([...result[type] ?? [], ...value])
    );
  }
  return result;
};
const onlyCode = (code) => ({ code, imports: {} });

const defaultDeclarations = () => ({
  imports: /* @__PURE__ */ new Set(),
  variables: /* @__PURE__ */ new Map(),
  takenNames: /* @__PURE__ */ new Set()
});
const NEVER_STR = "never";
const opaqueHashers = /* @__PURE__ */ new Set([
  "Blake2128",
  "Blake2256",
  "Twox128",
  "Twox256"
]);
const getTypesBuilder = (declarations, getLookupEntryDef, knownTypes, checksumBuilder) => {
  const { metadata, call } = getLookupEntryDef;
  const callsChecksum = call ? checksumBuilder.buildDefinition(call) : null;
  const typeFileImports = /* @__PURE__ */ new Set();
  const clientFileImports = /* @__PURE__ */ new Set();
  const getChecksum = (id) => typeof id === "number" ? checksumBuilder.buildDefinition(id) : checksumBuilder.buildComposite(id);
  const internalBuilder = getInternalTypesBuilder(getLookupEntryDef);
  const anonymize = ({ name, checksum }) => knownTypes[checksum] ? name : `Anonymize<${name}>`;
  const getName = (checksum) => {
    if (!knownTypes[checksum]) return `I${checksum}`;
    const { name: originalName } = knownTypes[checksum];
    let name = originalName;
    let i = 1;
    while (declarations.takenNames.has(name)) name = originalName + i++;
    declarations.takenNames.add(name);
    return name;
  };
  const buildDefinition = (id) => {
    const node = internalBuilder(id);
    return generateTypescript(node, (node2, next, level) => {
      if (node2.type === "primitive") return nativeNodeCodegen(node2, next);
      const checksum = "id" in node2 ? getChecksum(node2.id) : (
        // for types inlined in Enums, we might have an intermediate type
        "original" in node2 ? getChecksum(node2.original) : null
      );
      const getPapiPrimitive = (level2) => {
        const papiPrimitive = processPapiPrimitives(
          node2,
          next,
          !!checksum && !!knownTypes[checksum]
        );
        if (!papiPrimitive) return null;
        papiPrimitive.imports.client?.forEach((name) => {
          if (level2 === 0) {
            clientFileImports.add(name);
          } else {
            declarations.imports.add(name);
          }
        });
        return onlyCode(papiPrimitive.code);
      };
      if (!checksum || isPrimitive(node2) || node2.type === "union") {
        return getPapiPrimitive(level) ?? nativeNodeCodegen(node2, next);
      }
      if (level > 0 && checksum === callsChecksum) {
        declarations.imports.add("TxCallData");
        return onlyCode("TxCallData");
      }
      if (declarations.variables.has(checksum)) {
        const entry = declarations.variables.get(checksum);
        if (level === 0) {
          typeFileImports.add(entry.name);
        }
        return onlyCode(anonymize(entry));
      }
      const variable = {
        checksum,
        type: "",
        name: getName(checksum)
      };
      if (level === 0) {
        typeFileImports.add(variable.name);
      }
      declarations.variables.set(checksum, variable);
      variable.type = (getPapiPrimitive(level + 1) ?? nativeNodeCodegen(node2, next)).code;
      return onlyCode(anonymize(variable));
    });
  };
  const buildTypeDefinition = (id) => buildDefinition(id).code;
  const buildStorage = (pallet, entry) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    if (storageEntry.type.tag === "plain")
      return {
        key: "[]",
        val: `${buildTypeDefinition(storageEntry.type.value)}`,
        opaque: NEVER_STR
      };
    const hashers = storageEntry.type.value.hashers;
    const opaque = hashers.map((x, idx) => opaqueHashers.has(x.tag) ? `"${idx}"` : null).filter(Boolean).join(" | ") || NEVER_STR;
    const { key, value } = storageEntry.type.value;
    const val = buildTypeDefinition(value);
    const returnKey = storageEntry.type.value.hashers.length === 1 ? `[Key: ${buildTypeDefinition(key)}]` : buildTypeDefinition(key);
    return { key: returnKey, val, opaque };
  };
  const buildViewFn = (pallet, entry) => {
    const viewFn = metadata.pallets.find((x) => x.name === pallet)?.viewFns.find((x) => x.name === entry);
    if (!viewFn) throw null;
    const innerTuple = viewFn.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(viewFn.output)
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry) throw null;
    const innerTuple = entry.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(entry.output)
    };
  };
  const buildVariant = (type) => (pallet, name) => {
    const lookupEntry = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet)[type].type
    );
    if (lookupEntry.type !== "enum") throw null;
    buildDefinition(lookupEntry.id);
    const innerLookup = lookupEntry.value[name];
    if (innerLookup.type === "lookupEntry") {
      return buildTypeDefinition(innerLookup.value.id);
    } else if (innerLookup.type === "void") {
      return "undefined";
    } else {
      const result = declarations.variables.get(
        getChecksum(innerLookup)
      ).name;
      typeFileImports.add(result);
      return `Anonymize<${result}>`;
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildTypeDefinition(storageEntry.type);
  };
  return {
    buildTypeDefinition,
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall: buildVariant("calls"),
    buildViewFn,
    buildRuntimeCall,
    buildConstant,
    getTypeFileImports: () => Array.from(typeFileImports),
    getClientFileImports: () => Array.from(clientFileImports)
  };
};
const getDocsTypesBuilder = (getLookupEntryDef, knownTypes, checksumBuilder) => {
  const { metadata, call } = getLookupEntryDef;
  const callsChecksum = call ? checksumBuilder.buildDefinition(call) : null;
  const clientFileImports = /* @__PURE__ */ new Set();
  const fileTypeEntries = /* @__PURE__ */ new Set();
  const importsPerType = /* @__PURE__ */ new Map();
  const declarations = defaultDeclarations();
  const getChecksum = (id) => typeof id === "number" ? checksumBuilder.buildDefinition(id) : checksumBuilder.buildComposite(id);
  const internalBuilder = getInternalTypesBuilder(getLookupEntryDef);
  const buildTypeDefinition = (id) => {
    fileTypeEntries.add(id);
    const node = internalBuilder(id);
    const visited = /* @__PURE__ */ new Set();
    const result = generateTypescript(node, (node2, next) => {
      const checksum = "id" in node2 ? getChecksum(node2.id) : (
        // for types inlined in Enums, we might have an intermediate type
        "original" in node2 ? getChecksum(node2.original) : null
      );
      const getPapiPrimitive = () => processPapiPrimitives(node2, next, true);
      if (!checksum) {
        return getPapiPrimitive() ?? nativeNodeCodegen(node2, next);
      }
      if (node2.type === "primitive") return nativeNodeCodegen(node2, next);
      if (checksum === callsChecksum) {
        return {
          code: "TxCallData",
          imports: {
            client: /* @__PURE__ */ new Set(["TxCallData"])
          }
        };
      }
      if (checksum in knownTypes) {
        if (declarations.variables.has(checksum)) {
          const entry = declarations.variables.get(checksum);
          return {
            code: entry.name,
            imports: {
              types: /* @__PURE__ */ new Set([entry.name])
            }
          };
        }
        const variable = {
          checksum,
          type: "",
          name: knownTypes[checksum].name
        };
        declarations.variables.set(checksum, variable);
        const generated = getPapiPrimitive() ?? nativeNodeCodegen(node2, next);
        variable.type = generated.code;
        importsPerType.set(
          checksum,
          mergeImports([
            generated.imports,
            {
              types: /* @__PURE__ */ new Set([variable.name])
            }
          ])
        );
        return {
          code: variable.name,
          imports: {
            types: /* @__PURE__ */ new Set([variable.name])
          }
        };
      }
      if (declarations.variables.has(checksum)) {
        const entry = declarations.variables.get(checksum);
        return {
          code: entry.type,
          imports: importsPerType.get(checksum) ?? {}
        };
      }
      if (visited.has(checksum)) {
        return {
          code: "__Circular",
          imports: {
            types: /* @__PURE__ */ new Set(["__Circular"])
          }
        };
      }
      visited.add(checksum);
      const result2 = getPapiPrimitive() ?? nativeNodeCodegen(node2, next);
      declarations.variables.set(checksum, {
        checksum,
        type: result2.code,
        name: "I" + checksum
      });
      importsPerType.set(checksum, result2.imports);
      return result2;
    });
    return result.code;
  };
  const buildStorage = (pallet, entry) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    if (storageEntry.type.tag === "plain")
      return {
        opaque: NEVER_STR,
        args: "[]",
        payload: `${buildTypeDefinition(storageEntry.type.value)}`
      };
    const { key, value } = storageEntry.type.value;
    const payload = buildTypeDefinition(value);
    const hashers = storageEntry.type.value.hashers;
    const opaque = hashers.map((x, idx) => opaqueHashers.has(x.tag) ? `"${idx}"` : null).filter(Boolean).join(" | ") || NEVER_STR;
    const returnKey = hashers.length === 1 ? `[Key: ${buildTypeDefinition(key)}]` : buildTypeDefinition(key);
    return { args: returnKey, payload, opaque };
  };
  const buildViewFn = (pallet, entry) => {
    const fn = metadata.pallets.find((x) => x.name === pallet)?.viewFns.find((x) => x.name === entry);
    if (!fn) throw null;
    const innerTuple = fn.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(fn.output)
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry) throw null;
    const innerTuple = entry.inputs.map(({ name, type }) => `${name}: ${buildTypeDefinition(type)}`).join(", ");
    return {
      args: `[${innerTuple}]`,
      value: buildTypeDefinition(entry.output)
    };
  };
  const buildVariant = (type) => (pallet, name) => {
    const lookupEntry = getLookupEntryDef(
      metadata.pallets.find((x) => x.name === pallet)[type].type
    );
    if (lookupEntry.type !== "enum") throw null;
    const innerLookup = lookupEntry.value[name];
    if (innerLookup.type === "lookupEntry") {
      return buildTypeDefinition(innerLookup.value.id);
    } else if (innerLookup.type === "void") {
      return "undefined";
    } else {
      buildTypeDefinition(lookupEntry.id);
      const innerChecksum = getChecksum(innerLookup);
      const innerVariable = declarations.variables.get(innerChecksum);
      if (!innerVariable) {
        throw new Error(
          `Unable to build ${type} variant for ${pallet}::${name}: ${innerChecksum} not populated`
        );
      }
      return innerVariable.type;
    }
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildTypeDefinition(storageEntry.type);
  };
  const recordTypeFileImports = () => {
    const allImports = /* @__PURE__ */ new Set();
    for (const id of fileTypeEntries) {
      const thisTypeImports = importsPerType.get(getChecksum(id));
      if (!thisTypeImports?.types) continue;
      for (const singleType of thisTypeImports.types.values()) {
        allImports.add(singleType);
      }
    }
    fileTypeEntries.clear();
    return Array.from(allImports);
  };
  const getDescriptorsTypes = () => [...declarations.variables.entries()].filter(([checksum]) => knownTypes[checksum]).map(([_, variable]) => variable);
  return {
    buildStorage,
    buildRuntimeCall,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildCall: buildVariant("calls"),
    buildConstant,
    buildViewFn,
    declarations,
    recordTypeFileImports,
    getClientFileImports: () => Array.from(clientFileImports),
    getDescriptorsTypes
  };
};

const getNewTypes = (lookup, knownTypes, getTypeName) => {
  const { metadata } = lookup;
  const checksumBuilder = metadataBuilders.getChecksumBuilder(lookup);
  let declarations = defaultDeclarations();
  let typesBuilder = getTypesBuilder(
    declarations,
    lookup,
    knownTypes,
    checksumBuilder
  );
  let ignoredIds = new Set(
    "outerEnums" in metadata ? [
      metadata.outerEnums.call,
      metadata.outerEnums.error,
      metadata.outerEnums.event
    ] : []
  );
  ("outerEnums" in metadata ? [metadata.outerEnums.call, metadata.outerEnums.event] : []).map(lookup).forEach((entry) => {
    if (entry.type !== "enum") throw null;
    Object.values(entry.value).forEach((inner) => {
      if (inner.type === "void") return;
      ignoredIds.add(Object.values(inner.value)[0].id);
    });
  });
  const wannabes = {};
  const nameToChecksum = /* @__PURE__ */ new Map();
  metadata.lookup.forEach((x) => {
    const result = checksumBuilder.buildDefinition(x.id);
    typesBuilder.buildDefinition(x.id);
    const variable = declarations.variables.get(result);
    if (!variable || !variable.type.startsWith("AnonymousEnum<") || variable.checksum in wannabes)
      return;
    const typeName = getTypeName(x);
    if (!typeName) return;
    let finalTypeName = typeName;
    for (let i = 1; nameToChecksum.has(finalTypeName); i++)
      finalTypeName = typeName + i;
    wannabes[variable.checksum] = { name: finalTypeName, priority: 0 };
    nameToChecksum.set(finalTypeName, {
      checksum: variable.checksum,
      path: x.path
    });
  });
  declarations = defaultDeclarations();
  typesBuilder = getTypesBuilder(
    declarations,
    lookup,
    wannabes,
    checksumBuilder
  );
  metadata.lookup.forEach(({ id }) => {
    typesBuilder.buildDefinition(id);
  });
  return Object.fromEntries(
    [...nameToChecksum].map(([name, { checksum, path }]) => {
      return [
        checksum,
        {
          name,
          checksum,
          type: declarations.variables.get(checksum).type,
          path
        }
      ];
    })
  );
};

const anonymizeImports = [
  "Binary",
  "FixedSizeBinary",
  "Enum",
  "FixedSizeArray"
];
const anonymizeType = `type AnonymousEnum<T extends {}> = T & {
  __anonymous: true
}

type MyTuple<T> = [T, ...T[]]

type SeparateUndefined<T> = undefined extends T
  ? undefined | Exclude<T, undefined>
  : T

type Anonymize<T> = SeparateUndefined<
  T extends FixedSizeBinary<infer L>
    ? number extends L
      ? Binary
      : FixedSizeBinary<L>
    : T extends
          | string
          | number
          | bigint
          | boolean
          | void
          | undefined
          | null
          | symbol
          | Uint8Array
          | Enum<any>
      ? T
      : T extends AnonymousEnum<infer V>
        ? Enum<V>
        : T extends MyTuple<any>
          ? {
              [K in keyof T]: T[K]
            }
          : T extends []
            ? []
            : T extends FixedSizeArray<infer L, infer T>
              ? number extends L
                ? Array<T>
                : FixedSizeArray<L, T>
              : {
                  [K in keyof T & string]: T[K]
                }
>`;

const isDocs = (x) => {
  if (typeof x !== "object") return false;
  const keys = new Set(Object.keys(x));
  if (keys.size !== 2) return false;
  return keys.has("docs") && keys.has("value");
};
const customStringifyObject = (input) => {
  if (typeof input === "string" || typeof input === "number") return input;
  if (Array.isArray(input))
    return `[${input.map(customStringifyObject).join(", ")}]`;
  return `{${Object.entries(
    utils.mapObject(input, (x) => isDocs(x) ? x : customStringifyObject(x))
  ).map(([key, value]) => {
    if (isDocs(value)) {
      return `

/**
${value.docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
 */
${key}: ${customStringifyObject(value.value)}`;
    }
    return `${key}: ${value}`;
  }).join(",\n")}}`;
};
function capitalize(value) {
  return value.slice(0, 1).toUpperCase() + value.slice(1);
}
const generateDescriptors = (lookupFn, checksumToIdx, typesBuilder, checksumBuilder, key, paths, genesis) => {
  const prefix = capitalize(key);
  const { metadata } = lookupFn;
  const buildEnumObj = (val, cb) => {
    if (val === void 0) return {};
    const lookup = metadata.lookup[val];
    if (lookup.def.tag !== "variant") throw null;
    return Object.fromEntries(
      lookup.def.value.map((x) => {
        return [x.name, cb(x.name, x.docs)];
      })
    );
  };
  const storage = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        Object.fromEntries(
          pallet.storage?.items.map(({ name, modifier, docs }) => {
            const { key: key2, val, opaque } = typesBuilder.buildStorage(
              pallet.name,
              name
            );
            const checksum = checksumBuilder.buildStorage(pallet.name, name);
            const type = `StorageDescriptor<${key2}, ${val === "undefined" ? "null" : val}, ${!modifier}, ${opaque}>`;
            return [
              name,
              {
                typeRef: checksumToIdx.get(checksum),
                type,
                name: `stg_${pallet.name}_${name}`,
                docs
              }
            ];
          }) ?? []
        )
      ];
    })
  );
  const constants = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        Object.fromEntries(
          pallet.constants?.map(({ name, docs }) => {
            const checksum = checksumBuilder.buildConstant(pallet.name, name);
            const type = `PlainDescriptor<${typesBuilder.buildConstant(
              pallet.name,
              name
            )}>`;
            return [
              name,
              {
                typeRef: checksumToIdx.get(checksum),
                type,
                name: `const_${pallet.name}_${name}`,
                docs
              }
            ];
          }) ?? []
        )
      ];
    })
  );
  const calls = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        buildEnumObj(pallet.calls?.type, (name, docs) => ({
          typeRef: checksumToIdx.get(
            checksumBuilder.buildCall(pallet.name, name)
          ),
          type: `TxDescriptor<${typesBuilder.buildCall(pallet.name, name)}>`,
          name: `call_${pallet.name}_${name}`,
          docs
        }))
      ];
    })
  );
  const events = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        buildEnumObj(pallet.events?.type, (name, docs) => ({
          typeRef: checksumToIdx.get(
            checksumBuilder.buildEvent(pallet.name, name)
          ),
          type: `PlainDescriptor<${typesBuilder.buildEvent(
            pallet.name,
            name
          )}>`,
          name: `evt_${pallet.name}_${name}`,
          docs
        }))
      ];
    })
  );
  const errors = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        buildEnumObj(pallet.errors?.type, (name, docs) => {
          return {
            typeRef: checksumToIdx.get(
              checksumBuilder.buildError(pallet.name, name)
            ),
            type: `PlainDescriptor<${typesBuilder.buildError(
              pallet.name,
              name
            )}>`,
            name: `err_${pallet.name}_${name}`,
            docs
          };
        })
      ];
    })
  );
  const viewFns = Object.fromEntries(
    metadata.pallets.map((pallet) => [
      pallet.name,
      Object.fromEntries(
        pallet.viewFns.map((viewFn) => {
          const { args, value } = typesBuilder.buildViewFn(
            pallet.name,
            viewFn.name
          );
          return [
            viewFn.name,
            {
              typeRef: checksumToIdx.get(
                checksumBuilder.buildViewFns(pallet.name, viewFn.name)
              ),
              type: `RuntimeDescriptor<${args}, ${value}>`,
              name: `view_${pallet.name}_${viewFn.name}`,
              docs: viewFn.docs
            }
          ];
        })
      )
    ])
  );
  const runtimeCalls = Object.fromEntries(
    metadata.apis.map((api) => [
      api.name,
      {
        docs: api.docs,
        methods: Object.fromEntries(
          api.methods.map((method) => {
            const { args, value } = typesBuilder.buildRuntimeCall(
              api.name,
              method.name
            );
            return [
              method.name,
              {
                typeRef: checksumToIdx.get(
                  checksumBuilder.buildRuntimeCall(api.name, method.name)
                ),
                type: `RuntimeDescriptor<${args}, ${value}>`,
                name: `runtime_${api.name}_${method.name}`,
                docs: method.docs
              }
            ];
          })
        )
      }
    ])
  );
  const mapDescriptor = (descriptor, mapFn) => utils.filterObject(
    utils.mapObject(
      descriptor,
      (v, pallet) => utils.mapObject(v, (value, name) => mapFn(value, pallet, name))
    ),
    (v) => Object.keys(v).length > 0
  );
  const extractValue = (input) => ({
    docs: input.docs,
    value: input.type
  });
  const iStorage = mapDescriptor(storage, extractValue);
  const iCalls = mapDescriptor(calls, extractValue);
  const iEvents = mapDescriptor(events, extractValue);
  const iErrors = mapDescriptor(errors, extractValue);
  const iConstants = mapDescriptor(constants, extractValue);
  const iViewFns = mapDescriptor(viewFns, extractValue);
  const descriptorValues = {
    storage: {},
    tx: {},
    events: {},
    constants: {},
    viewFns: {},
    apis: {}
  };
  const mapObjStr = utils.mapObject;
  Object.keys(storage).forEach((pallet) => {
    descriptorValues["storage"][pallet] = mapObjStr(
      storage[pallet],
      (x) => x.typeRef
    );
    descriptorValues["tx"][pallet] = mapObjStr(calls[pallet], (x) => x.typeRef);
    descriptorValues["events"][pallet] = mapObjStr(
      events[pallet],
      (x) => x.typeRef
    );
    descriptorValues["constants"][pallet] = mapObjStr(
      constants[pallet],
      (x) => x.typeRef
    );
    descriptorValues["viewFns"][pallet] = mapObjStr(
      viewFns[pallet],
      (x) => x.typeRef
    );
  });
  const iRuntimeCalls = utils.mapObject(runtimeCalls, (api) => ({
    docs: api.docs,
    value: utils.mapObject(api.methods, ({ docs, type: value }) => ({ docs, value }))
  }));
  if (lookupFn.call) {
    typesBuilder.buildDefinition(lookupFn.call);
  }
  const callInterface = lookupFn.call ? `I${checksumBuilder.buildDefinition(lookupFn.call)}` : null;
  const chainCallType = callInterface ? `export type ${prefix}CallData = Anonymize<${callInterface}> & { value: { type: string } };` : "";
  descriptorValues["apis"] = utils.mapObject(
    runtimeCalls,
    (api) => utils.mapObject(api.methods, (x) => x.typeRef)
  );
  const clientImports = [
    .../* @__PURE__ */ new Set([
      "StorageDescriptor",
      "PlainDescriptor",
      "TxDescriptor",
      "RuntimeDescriptor",
      "Enum",
      "_Enum",
      "GetEnum",
      "ApisFromDef",
      "QueryFromPalletsDef",
      "TxFromPalletsDef",
      "EventsFromPalletsDef",
      "ErrorsFromPalletsDef",
      "ConstFromPalletsDef",
      "ViewFnsFromPalletsDef",
      ...typesBuilder.getClientFileImports(),
      ...anonymizeImports
    ])
  ];
  const assetId = getAssetId(lookupFn);
  const assetType = assetId == null ? "void" : typesBuilder.buildTypeDefinition(assetId);
  const dispatchErrorId = getDispatchErrorId(lookupFn);
  const dispatchErrorType = dispatchErrorId == null ? "unknown" : typesBuilder.buildTypeDefinition(dispatchErrorId);
  const commonTypeImports = typesBuilder.getTypeFileImports();
  const exports = [
    `default as ${key}`,
    callInterface ? `${prefix}CallData` : null
  ].filter((v) => v !== null);
  const imports = `import {${clientImports.join(", ")}} from "${paths.client}";
  import {${commonTypeImports.join(", ")}} from "${paths.types}";
  import { toBinary } from "${paths.common}"

  const descriptorValues = import("${paths.descriptorValues}").then(module => module["${prefix}"]);
  const metadataTypes = import("${paths.metadataTypes}").then(
    module => toBinary('default' in module ? module.default : module)
  );
  `;
  const descriptorTypes = `${imports}

${anonymizeType}

type IStorage = ${customStringifyObject(iStorage)};
type ICalls = ${customStringifyObject(iCalls)};
type IEvent = ${customStringifyObject(iEvents)};
type IError = ${customStringifyObject(iErrors)};
type IConstants = ${customStringifyObject(iConstants)};
type IViewFns = ${customStringifyObject(iViewFns)};
type IRuntimeCalls = ${customStringifyObject(iRuntimeCalls)};
type IAsset = PlainDescriptor<${assetType}>
export type ${prefix}DispatchError = ${dispatchErrorType}
const asset: IAsset = {} as IAsset
const getMetadata: () => Promise<Uint8Array> = () => import("./${key}_metadata").then(
  module => toBinary('default' in module ? module.default : module)
)
const genesis: string | undefined = ${genesis ? `"${genesis}"` : void 0}

type PalletsTypedef = {
  __storage: IStorage,
  __tx: ICalls,
  __event: IEvent,
  __error: IError,
  __const: IConstants
  __view: IViewFns
}

export type ${prefix} = {
  descriptors: {
    pallets: PalletsTypedef,
    apis: IRuntimeCalls
  } & Promise<any>,
  metadataTypes: Promise<Uint8Array>
  asset: IAsset
  getMetadata: () => Promise<Uint8Array>
  genesis: string | undefined
};
const _allDescriptors = { descriptors: descriptorValues, metadataTypes, asset, getMetadata, genesis } as any as ${prefix};
export default _allDescriptors;

export type ${prefix}Apis = ApisFromDef<IRuntimeCalls>
export type ${prefix}Queries = QueryFromPalletsDef<PalletsTypedef>
export type ${prefix}Calls = TxFromPalletsDef<PalletsTypedef>
export type ${prefix}Events = EventsFromPalletsDef<PalletsTypedef>
export type ${prefix}Errors = ErrorsFromPalletsDef<PalletsTypedef>
export type ${prefix}Constants = ConstFromPalletsDef<PalletsTypedef>
export type ${prefix}ViewFns = ViewFnsFromPalletsDef<PalletsTypedef>
${chainCallType}

export type ${prefix}WhitelistEntry =
  | PalletKey
  | ApiKey<IRuntimeCalls>
  | \`query.\${NestedKey<PalletsTypedef['__storage']>}\`
  | \`tx.\${NestedKey<PalletsTypedef['__tx']>}\`
  | \`event.\${NestedKey<PalletsTypedef['__event']>}\`
  | \`error.\${NestedKey<PalletsTypedef['__error']>}\`
  | \`const.\${NestedKey<PalletsTypedef['__const']>}\`
  | \`view.\${NestedKey<PalletsTypedef['__view']>}\`

type PalletKey = \`*.\${keyof (IStorage & ICalls & IEvent & IError & IConstants & IRuntimeCalls & IViewFns)}\`
type NestedKey<D extends Record<string, Record<string, any>>> =
  | "*"
  | {
      [P in keyof D & string]:
        | \`\${P}.*\`
        | {
            [N in keyof D[P] & string]: \`\${P}.\${N}\`
          }[keyof D[P] & string]
    }[keyof D & string]

type ApiKey<D extends Record<string, Record<string, any>>> =
  | "api.*"
  | {
      [P in keyof D & string]:
        | \`api.\${P}.*\`
        | {
            [N in keyof D[P] & string]: \`api.\${P}.\${N}\`
          }[keyof D[P] & string]
    }[keyof D & string]
`;
  return { descriptorTypes, descriptorValues, exports, commonTypeImports };
};
function getAssetId(lookup) {
  const assetPayment = lookup.metadata.extrinsic.signedExtensions.find(
    (x) => x.identifier === "ChargeAssetTxPayment"
  );
  if (assetPayment) {
    const assetTxPayment = lookup(assetPayment.type);
    if (assetTxPayment.type === "struct") {
      const optionalAssetId = assetTxPayment.value.asset_id;
      if (optionalAssetId.type === "option") return optionalAssetId.value.id;
    }
  }
  return;
}
function getDispatchErrorId(lookup) {
  const systemPalletEventId = lookup.metadata.pallets.find(
    (p) => p.name === "System"
  )?.events;
  if (systemPalletEventId == null) return;
  const systemPalletEvent = lookup(systemPalletEventId.type);
  if (systemPalletEvent.type !== "enum") return;
  const extrinsicFailed = systemPalletEvent.value.ExtrinsicFailed;
  if (extrinsicFailed?.type !== "struct") return;
  return extrinsicFailed.value.dispatch_error.id;
}

const getTypeDependencies = (input) => new Set([...input.matchAll(/Anonymize<(I\w*)>/gm)].map((x) => x[1].slice(1)));
const optimizeVariables = (variables, commonTypeImports) => {
  const dependants = /* @__PURE__ */ new Map();
  const dependencies = /* @__PURE__ */ new Map();
  const toRemove = /* @__PURE__ */ new Set();
  [...variables.entries()].forEach(([checksum, { type }]) => {
    const iDependencies = getTypeDependencies(type);
    dependencies.set(checksum, iDependencies);
    iDependencies.forEach((dependencyChecksum) => {
      const s = dependants.get(dependencyChecksum);
      if (s) {
        s.add(checksum);
        toRemove.delete(dependencyChecksum);
      } else {
        dependants.set(dependencyChecksum, /* @__PURE__ */ new Set([checksum]));
        if (!commonTypeImports.has(variables.get(dependencyChecksum).name))
          toRemove.add(dependencyChecksum);
      }
    });
  });
  while (true) {
    const nonDependants = [...toRemove].filter(
      (item) => [...dependencies.get(item) ?? []].every((x) => !toRemove.has(x))
    );
    if (!nonDependants.length) break;
    nonDependants.forEach((checksum) => {
      const variableToInline = variables.get(checksum);
      const [target] = [...dependants.get(checksum)];
      const variable = variables.get(target);
      const newType = variableToInline.type.startsWith("AnonymousEnum<") ? variableToInline.type.slice(9) : variableToInline.type;
      variable.type = variable.type.replaceAll(
        `Anonymize<${variableToInline.name}>`,
        newType
      );
      variables.delete(checksum);
      toRemove.delete(checksum);
    });
  }
  return variables;
};
const generateTypes = (declarations, paths, commonTypeImports) => {
  const clientImports = [
    .../* @__PURE__ */ new Set([
      "Enum",
      "_Enum",
      "GetEnum",
      ...declarations.imports,
      ...anonymizeImports
    ])
  ];
  const imports = `import {${clientImports.join(", ")}} from "${paths.client}";`;
  const variables = optimizeVariables(declarations.variables, commonTypeImports);
  const baseTypes = [...variables.values()].map(
    ({ name, type }) => type.startsWith("Enum<") ? `export type ${name} = ${type};
export const ${name} = _Enum as unknown as GetEnum<${name}>;` : `export type ${name} = ${type};`
  ).join("\n\n");
  return `${imports}

  ${anonymizeType}

  ${baseTypes}
  `;
};

const getUsedTypes = (lookup, builder) => {
  const checksums = new Array(lookup.metadata.lookup.length);
  const visited = /* @__PURE__ */ new Set();
  const types = /* @__PURE__ */ new Map();
  const entryPoints = /* @__PURE__ */ new Map();
  const addTypeFromLookup = (id) => {
    if (id == null) return;
    const checksum = builder.buildDefinition(id);
    if (!checksum) {
      throw new Error("Unreachable: checksum not available for lookup type");
    }
    checksums[id] = checksum;
    if (visited.has(checksum)) return;
    visited.add(checksum);
    types.set(checksum, metadataCompatibility.mapLookupToTypedef(lookup(id), addTypeFromLookup));
  };
  const addTypeFromEntryPoint = (checksum, entry) => {
    entryPoints.set(checksum, entry);
    metadataCompatibility.mapEntryPointReferences(entry, (id) => {
      addTypeFromLookup(id);
      return id;
    });
  };
  const buildEnum = (side, val, cb) => {
    if (val === void 0) return;
    const entry = lookup(val);
    if (entry.type === "void") return;
    if (entry.type !== "enum") throw new Error("Expected enum");
    Object.entries(entry.value).forEach(([name, value]) => {
      const checksum = cb(name);
      const node = metadataCompatibility.enumValueEntryPointNode(value);
      addTypeFromEntryPoint(checksum, {
        args: side === "args" ? node : metadataCompatibility.voidEntryPointNode,
        values: side === "args" ? metadataCompatibility.voidEntryPointNode : node
      });
    });
  };
  lookup.metadata.pallets.forEach((pallet) => {
    pallet.storage?.items.forEach((entry) => {
      const checksum = builder.buildStorage(pallet.name, entry.name);
      addTypeFromEntryPoint(checksum, metadataCompatibility.storageEntryPoint(entry));
    });
    pallet.constants.forEach(({ name, type }) => {
      const checksum = builder.buildConstant(pallet.name, name);
      addTypeFromEntryPoint(checksum, metadataCompatibility.singleValueEntryPoint(type));
    });
    pallet.viewFns.forEach((entry) => {
      const checksum = builder.buildViewFns(pallet.name, entry.name);
      addTypeFromEntryPoint(checksum, metadataCompatibility.runtimeCallEntryPoint(entry));
    });
    buildEnum(
      "args",
      pallet.calls?.type,
      (name) => builder.buildCall(pallet.name, name)
    );
    buildEnum(
      "values",
      pallet.events?.type,
      (name) => builder.buildEvent(pallet.name, name)
    );
    buildEnum(
      "values",
      pallet.errors?.type,
      (name) => builder.buildError(pallet.name, name)
    );
  });
  lookup.metadata.apis.forEach(
    (api) => api.methods.forEach((method) => {
      const checksum = builder.buildRuntimeCall(api.name, method.name);
      addTypeFromEntryPoint(checksum, metadataCompatibility.runtimeCallEntryPoint(method));
    })
  );
  return { types, entryPoints, checksums };
};

const knownTypesRepository = {
  "1078dp8vlrjh3": {
    name: "SessionEvent",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["pallet_session.pallet.Event"],
    type: "Enum(NewSession)"
  },
  "11avansl9buvp": {
    name: "XcmV2MultiassetAssetInstance",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.multiasset.AssetInstance"],
    type: "Enum(Undefined, Index, Array4, Array8, Array16, Array32, Blob)"
  },
  "129huic8ces20": {
    name: "CandidateEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["polkadot_primitives.v7.CandidateEvent"],
    type: "Enum(CandidateBacked, CandidateIncluded, CandidateTimedOut)"
  },
  "14qmevhulqskl": {
    name: "NominationPoolsEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_nomination_pools.pallet.Event"],
    type: "Enum(Created, Bonded, PaidOut, Unbonded, Withdrawn, Destroyed, StateChanged, MemberRemoved, RolesUpdated, PoolSlashed, UnbondingPoolSlashed, PoolCommissionUpdated, PoolMaxCommissionUpdated, PoolCommissionChangeRateUpdated, PoolCommissionClaimPermissionUpdated, PoolCommissionClaimed, MinBalanceDeficitAdjusted, MinBalanceExcessAdjusted)"
  },
  "1e4e6h17tes8n": {
    name: "XcmV2MultiassetFungibility",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.multiasset.Fungibility"],
    type: "Enum(Fungible, NonFungible)"
  },
  "1lanl0ouai2l7": {
    name: "NominationPoolsCommissionClaimPermission",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_nomination_pools.CommissionClaimPermission"],
    type: "Enum(Permissionless, Account)"
  },
  "1pil5vhej188n": {
    name: "CommonParasRegistrarEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_common.paras_registrar.pallet.Event"],
    type: "Enum(Registered, Deregistered, Reserved, Swapped)"
  },
  "1pja0i3r5p1gp": {
    name: "XcmPalletQueryStatus",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["pallet_xcm.pallet.QueryStatus"],
    type: "Enum(Pending, VersionNotifier, Ready)"
  },
  "1ra0103q36u4i": {
    name: "ElectionProviderMultiPhasePhase",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_election_provider_multi_phase.Phase"],
    type: "Enum(Off, Signed, Unsigned, Emergency)"
  },
  "1rjg0rh02tt4m": {
    name: "CommonCrowdloanLastContribution",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_common.crowdloan.LastContribution"],
    type: "Enum(Never, PreEnding, Ending)"
  },
  "1tac42poi01n8": {
    name: "OffencesEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_offences.pallet.Event"],
    type: "Enum(Offence)"
  },
  "22g1a3o3q475f": {
    name: "NominationPoolsPoolState",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_nomination_pools.PoolState"],
    type: "Enum(Open, Blocked, Destroying)"
  },
  "264i12ff5ltjn": {
    name: "MultiAddress",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.multiaddress.MultiAddress"],
    type: "Enum(Id, Index, Raw, Address32, Address20)"
  },
  "29a9v38btsv3g": {
    name: "ParachainsInclusionUmpQueueId",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.inclusion.UmpQueueId"],
    type: "Enum(Para)"
  },
  "2bvq1blgrln1s": {
    name: "NominationPoolsBondExtra",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_nomination_pools.BondExtra"],
    type: "Enum(FreeBalance, Rewards)"
  },
  "2dcitigd3tk41": {
    name: "XcmV2OriginKind",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v2.OriginKind", "xcm.v3.OriginKind"],
    type: "Enum(Native, SovereignAccount, Superuser, Xcm)"
  },
  "2gj0h0im54fqd": {
    name: "PreimageRequestStatus",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["pallet_preimage.RequestStatus"],
    type: "Enum(Unrequested, Requested)"
  },
  "2qbmdeolj2cue": {
    name: "BagsListEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_bags_list.pallet.Event"],
    type: "Enum(Rebagged, ScoreUpdated)"
  },
  "2v2nj97k9o9e": {
    name: "CommonClaimsEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["polkadot_runtime_common.claims.pallet.Event"],
    type: "Enum(Claimed)"
  },
  "302o6h1bqiqgu": {
    name: "PreimageEvent",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["pallet_preimage.pallet.Event"],
    type: "Enum(Noted, Requested, Cleared)"
  },
  "30v4njes1avsr": {
    name: "XcmV2Response",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.Response"],
    type: "Enum(Null, Assets, ExecutionResult, Version)"
  },
  "332pk9bjbk7p3": {
    name: "XcmV3MultiassetWildMultiAsset",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.multiasset.WildMultiAsset"],
    type: "Enum(All, AllOf, AllCounted, AllOfCounted)"
  },
  "341grmvm6j3e5": {
    name: "ParachainsParasParaLifecycle",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.paras.ParaLifecycle"],
    type: "Enum(Onboarding, Parathread, Parachain, UpgradingParathread, DowngradingParachain, OffboardingParathread, OffboardingParachain)"
  },
  "3bd4nvc4e2g3p": {
    name: "StakingEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_staking.pallet.pallet.Event"],
    type: "Enum(EraPaid, Rewarded, Slashed, SlashReported, OldSlashingReportDiscarded, StakersElected, Bonded, Unbonded, Withdrawn, Kicked, StakingElectionFailed, Chilled, PayoutStarted, ValidatorPrefsSet, SnapshotVotersSizeExceeded, SnapshotTargetsSizeExceeded, ForceEra, ControllerBatchDeprecated)"
  },
  "3f4te0335d8h1": {
    name: "WestendRuntimeGovernanceOriginsPalletCustomOriginsOrigin",
    chains: "westend",
    paths: ["westend_runtime.governance.origins.pallet_custom_origins.Origin"],
    type: "Enum(StakingAdmin, Treasurer, FellowshipAdmin, GeneralAdmin, AuctionAdmin, LeaseAdmin, ReferendumCanceller, ReferendumKiller, SmallTipper, BigTipper, SmallSpender, MediumSpender, BigSpender, WhitelistedCaller, FellowshipInitiates, Fellows, FellowshipExperts, FellowshipMasters, Fellowship1Dan, Fellowship2Dan, Fellowship3Dan, Fellowship4Dan, Fellowship5Dan, Fellowship6Dan, Fellowship7Dan, Fellowship8Dan, Fellowship9Dan)"
  },
  "3g7a8g60ho721": {
    name: "BabeAllowedSlots",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["sp_consensus_babe.AllowedSlots"],
    type: "Enum(PrimarySlots, PrimaryAndSecondaryPlainSlots, PrimaryAndSecondaryVRFSlots)"
  },
  "3jnpd4dmb650": {
    name: "XcmV2MultiassetWildMultiAsset",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.multiasset.WildMultiAsset"],
    type: "Enum(All, AllOf)"
  },
  "3nveejfjt6cjg": {
    name: "WestendRuntimeRuntimeHoldReason",
    chains: "polkadot.collectives",
    paths: ["collectives_polkadot_runtime.RuntimeHoldReason"],
    type: "Enum(Preimage)"
  },
  "3psnvvr3d6p0t": {
    name: "XcmVersionedXcm",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.VersionedXcm"],
    type: "Enum(V3, V4, V5)",
    priority: 1
  },
  "3vrnp048j3b2d": {
    name: "BalancesAdjustmentDirection",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["pallet_balances.types.AdjustmentDirection"],
    type: "Enum(Increase, Decrease)"
  },
  "43e3ummb3h5dn": {
    name: "PolkadotRuntimeCommonIdentityMigratorEvent",
    chains: "westend, westend.people",
    paths: ["polkadot_runtime_common.identity_migrator.pallet.Event"],
    type: "Enum(IdentityReaped, DepositUpdated)"
  },
  "46j01db9schbn": {
    name: "XcmV2BodyId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.BodyId"],
    type: "Enum(Unit, Named, Index, Executive, Technical, Legislative, Judicial, Defense, Administration, Treasury)"
  },
  "47gh5t4ppbcdj": {
    name: "XcmVersionedAssetId",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.VersionedAssetId"],
    type: "Enum(V3, V4, V5)",
    priority: 1
  },
  "49em457ob9ou0": {
    name: "ParachainsOrigin",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.origin.pallet.Origin"],
    type: "Enum(Parachain)"
  },
  "4cajo1lbs9cmt": {
    name: "XcmV3MultiassetAssetId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.multiasset.AssetId"],
    type: "Enum(Concrete, Abstract)"
  },
  "4k4r9im11cdan": {
    name: "PvfExecKind",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.PvfExecKind",
      "polkadot_primitives.v8.PvfExecKind"
    ],
    type: "Enum(Backing, Approval)"
  },
  "4peoofcn0loqr": {
    name: "StakingRewardDestination",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_staking.RewardDestination"],
    type: "Enum(Staked, Stash, Controller, Account, None)"
  },
  "4sjnuvedkqa2r": {
    name: "ParachainsInclusionAggregateMessageOrigin",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.inclusion.AggregateMessageOrigin"],
    type: "Enum(Ump)"
  },
  "4vbt6tkj8bvqs": {
    name: "OccupiedCoreAssumption",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.OccupiedCoreAssumption",
      "polkadot_primitives.v8.OccupiedCoreAssumption"
    ],
    type: "Enum(Included, TimedOut, Free)"
  },
  "505kan7sticn1": {
    name: "XcmV2Junction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.junction.Junction"],
    type: "Enum(Parachain, AccountId32, AccountIndex64, AccountKey20, PalletInstance, GeneralIndex, GeneralKey, OnlyChild, Plurality)"
  },
  "515gfvv2a6c4o": {
    name: "PreimageOldRequestStatus",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["pallet_preimage.OldRequestStatus"],
    type: "Enum(Unrequested, Requested)"
  },
  "543plq9vh7s3m": {
    name: "XcmVersionedResponse",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.VersionedResponse"],
    type: "Enum(V2, V3, V4)"
  },
  "5g0925eiftlcf": {
    name: "XcmV3MaybeErrorCode",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.MaybeErrorCode"],
    type: "Enum(Success, Error, TruncatedError)"
  },
  "5h5t0elhnbseq": {
    name: "BagsListListListError",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_bags_list.list.ListError"],
    type: "Enum(Duplicate, NotHeavier, NotInSameBag, NodeNotFound)"
  },
  "5ltp1mv4fr7n7": {
    name: "TokenError",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.TokenError"],
    type: "Enum(FundsUnavailable, OnlyProvider, BelowMinimum, CannotCreate, UnknownAsset, Frozen, Unsupported, CannotCreateHold, NotExpendable, Blocked)"
  },
  "5svrq9ei0ks3q": {
    name: "XcmPalletOrigin",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["pallet_xcm.pallet.Origin"],
    type: "Enum(Xcm, Response)"
  },
  "5tbcfetjk0h9h": {
    name: "NominationPoolsConfigOp",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_nomination_pools.ConfigOp"],
    type: "Enum(Noop, Set, Remove)"
  },
  "629bfqn3u6tle": {
    name: "IdentityData",
    chains: "polkadot.people, kusama.people, westend, westend.people",
    paths: ["pallet_identity.types.Data"],
    type: "Enum(None, Raw0, Raw1, Raw2, Raw3, Raw4, Raw5, Raw6, Raw7, Raw8, Raw9, Raw10, Raw11, Raw12, Raw13, Raw14, Raw15, Raw16, Raw17, Raw18, Raw19, Raw20, Raw21, Raw22, Raw23, Raw24, Raw25, Raw26, Raw27, Raw28, Raw29, Raw30, Raw31, Raw32, BlakeTwo256, Sha256, Keccak256, ShaThree256)"
  },
  "66mc66cqnpat1": {
    name: "GrandpaStoredState",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_grandpa.StoredState"],
    type: "Enum(Live, PendingPause, Paused, PendingResume)"
  },
  "6ag633d941o7v": {
    name: "XcmV3Junction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.junction.Junction", "staging_xcm.v4.junction.Junction"],
    type: "Enum(Parachain, AccountId32, AccountIndex64, AccountKey20, PalletInstance, GeneralIndex, GeneralKey, OnlyChild, Plurality, GlobalConsensus)"
  },
  "6c90ieeim9tjd": {
    name: "XcmPalletVersionMigrationStage",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["pallet_xcm.pallet.VersionMigrationStage"],
    type: "Enum(MigrateSupportedVersion, MigrateVersionNotifiers, NotifyCurrentTargets, MigrateAndNotifyOldTargets)"
  },
  "6d7om5l62r3h6": {
    name: "XcmV5Junctions",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v5.junctions.Junctions"],
    type: "Enum(Here, X1, X2, X3, X4, X5, X6, X7, X8)"
  },
  "6hem0avr1eoco": {
    name: "ParachainsDisputeResult",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.disputes.DisputeResult"],
    type: "Enum(Valid, Invalid)"
  },
  "6rjjsd07rc200": {
    name: "MmrPrimitivesError",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["sp_mmr_primitives.Error"],
    type: "Enum(InvalidNumericOp, Push, GetRoot, Commit, GenerateProof, Verify, LeafNotFound, PalletNotIncluded, InvalidLeafIndex, InvalidBestKnownBlock)"
  },
  "710b6mh49al4f": {
    name: "XcmV2NetworkId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.NetworkId"],
    type: "Enum(Any, Named, Polkadot, Kusama)"
  },
  "73beoct6oecc": {
    name: "XcmV5NetworkId",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v5.junction.NetworkId"],
    type: "Enum(ByGenesis, ByFork, Polkadot, Kusama, Ethereum, BitcoinCore, BitcoinCash, PolkadotBulletin)"
  },
  "769fta165mequ": {
    name: "XcmV3WeightLimit",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.WeightLimit"],
    type: "Enum(Unlimited, Limited)"
  },
  "7bvp9q4ceuk7": {
    name: "DigestItem",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.generic.digest.DigestItem"],
    type: "Enum(PreRuntime, Consensus, Seal, Other, RuntimeEnvironmentUpdated)"
  },
  "7ffbrur6hobca": {
    name: "XcmV3Response",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.Response"],
    type: "Enum(Null, Assets, ExecutionResult, Version, PalletsInfo, DispatchResult)"
  },
  "7t5v4k056sf3d": {
    name: "PolkadotRuntimeParachainsCoretimeEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.coretime.pallet.Event"],
    type: "Enum(RevenueInfoRequested, CoreAssigned)"
  },
  "7u481jea1442o": {
    name: "BalanceStatus",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["frame_support.traits.tokens.misc.BalanceStatus"],
    type: "Enum(Free, Reserved)"
  },
  "7ujvudkvg12so": {
    name: "IdentityJudgement",
    chains: "polkadot.people, kusama.people, westend, westend.people",
    paths: ["pallet_identity.types.Judgement"],
    type: "Enum(Unknown, FeePaid, Reasonable, KnownGood, OutOfDate, LowQuality, Erroneous)"
  },
  "7vujittrav0br": {
    name: "XcmVersionedAssets",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.VersionedAssets"],
    type: "Enum(V2, V3, V4)"
  },
  "85ca14rjo42j5": {
    name: "VotingConviction",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_conviction_voting.conviction.Conviction"],
    type: "Enum(None, Locked1x, Locked2x, Locked3x, Locked4x, Locked5x, Locked6x)"
  },
  "87r8lmtt997st": {
    name: "ArithmeticError",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_arithmetic.ArithmeticError"],
    type: "Enum(Underflow, Overflow, DivisionByZero)"
  },
  "88qf3i6ugbvsp": {
    name: "IndicesEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_indices.pallet.Event"],
    type: "Enum(IndexAssigned, IndexFreed, IndexFrozen)"
  },
  "890aui9hh0f9q": {
    name: "AssetRateEvent",
    chains: "polkadot, polkadot.collectives, kusama, paseo",
    paths: ["pallet_asset_rate.pallet.Event"],
    type: "Enum(AssetRateCreated, AssetRateRemoved, AssetRateUpdated)"
  },
  "8b4gf7pjdvue3": {
    name: "NominationPoolsPalletFreezeReason",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_nomination_pools.pallet.FreezeReason"],
    type: "Enum(PoolMinBalance)"
  },
  "8c614g2bc4iej": {
    name: "XcmV3Instruction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.Instruction"],
    type: "Enum(WithdrawAsset, ReserveAssetDeposited, ReceiveTeleportedAsset, QueryResponse, TransferAsset, TransferReserveAsset, Transact, HrmpNewChannelOpenRequest, HrmpChannelAccepted, HrmpChannelClosing, ClearOrigin, DescendOrigin, ReportError, DepositAsset, DepositReserveAsset, ExchangeAsset, InitiateReserveWithdraw, InitiateTeleport, ReportHolding, BuyExecution, RefundSurplus, SetErrorHandler, SetAppendix, ClearError, ClaimAsset, Trap, SubscribeVersion, UnsubscribeVersion, BurnAsset, ExpectAsset, ExpectOrigin, ExpectError, ExpectTransactStatus, QueryPallet, ExpectPallet, ReportTransactStatus, ClearTransactStatus, UniversalOrigin, ExportMessage, LockAsset, UnlockAsset, NoteUnlockable, RequestUnlock, SetFeesMode, SetTopic, ClearTopic, AliasOrigin, UnpaidExecution)"
  },
  "8eicfpc71dtp2": {
    name: "BountiesBountyStatus",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_bounties.BountyStatus"],
    type: "Enum(Proposed, Approved, Funded, CuratorProposed, Active, PendingPayout)"
  },
  "8fgf6e6g02u7k": {
    name: "ChildBountyStatus",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_child_bounties.ChildBountyStatus"],
    type: "Enum(Added, CuratorProposed, Active, PendingPayout)"
  },
  "8g50cqebfncn4": {
    name: "NominationPoolsClaimPermission",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_nomination_pools.ClaimPermission"],
    type: "Enum(Permissioned, PermissionlessCompound, PermissionlessWithdraw, PermissionlessAll)"
  },
  "8j0abm9jkapk2": {
    name: "XcmV3TraitsError",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.traits.Error"],
    type: "Enum(Overflow, Unimplemented, UntrustedReserveLocation, UntrustedTeleportLocation, LocationFull, LocationNotInvertible, BadOrigin, InvalidLocation, AssetNotFound, FailedToTransactAsset, NotWithdrawable, LocationCannotHold, ExceedsMaxMessageSize, DestinationUnsupported, Transport, Unroutable, UnknownClaim, FailedToDecode, MaxWeightInvalid, NotHoldingFees, TooExpensive, Trap, ExpectationFalse, PalletNotFound, NameMismatch, VersionIncompatible, HoldingWouldOverflow, ExportError, ReanchorFailed, NoDeal, FeesNotMet, LockError, NoPermission, Unanchored, NotDepositable, UnhandledXcmVersion, WeightLimitReached, Barrier, WeightNotComputable, ExceedsStackLimit)"
  },
  "8jjr2rgj6aa2v": {
    name: "SlashingOffenceKind",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.slashing.SlashingOffenceKind",
      "polkadot_primitives.v8.slashing.SlashingOffenceKind"
    ],
    type: "Enum(ForInvalid, AgainstValid)"
  },
  "8mdo9fqa201s6": {
    name: "TreasuryPaymentState",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["pallet_treasury.PaymentState"],
    type: "Enum(Pending, Attempted, Failed)"
  },
  "8slcnsmtfbubd": {
    name: "ExtensionsCheckMortality",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.generic.era.Era"],
    type: "Enum(Immortal, Mortal1, Mortal2, Mortal3, Mortal4, Mortal5, Mortal6, Mortal7, Mortal8, Mortal9, Mortal10, Mortal11, Mortal12, Mortal13, Mortal14, Mortal15, Mortal16, Mortal17, Mortal18, Mortal19, Mortal20, Mortal21, Mortal22, Mortal23, Mortal24, Mortal25, Mortal26, Mortal27, Mortal28, Mortal29, Mortal30, Mortal31, Mortal32, Mortal33, Mortal34, Mortal35, Mortal36, Mortal37, Mortal38, Mortal39, Mortal40, Mortal41, Mortal42, Mortal43, Mortal44, Mortal45, Mortal46, Mortal47, Mortal48, Mortal49, Mortal50, Mortal51, Mortal52, Mortal53, Mortal54, Mortal55, Mortal56, Mortal57, Mortal58, Mortal59, Mortal60, Mortal61, Mortal62, Mortal63, Mortal64, Mortal65, Mortal66, Mortal67, Mortal68, Mortal69, Mortal70, Mortal71, Mortal72, Mortal73, Mortal74, Mortal75, Mortal76, Mortal77, Mortal78, Mortal79, Mortal80, Mortal81, Mortal82, Mortal83, Mortal84, Mortal85, Mortal86, Mortal87, Mortal88, Mortal89, Mortal90, Mortal91, Mortal92, Mortal93, Mortal94, Mortal95, Mortal96, Mortal97, Mortal98, Mortal99, Mortal100, Mortal101, Mortal102, Mortal103, Mortal104, Mortal105, Mortal106, Mortal107, Mortal108, Mortal109, Mortal110, Mortal111, Mortal112, Mortal113, Mortal114, Mortal115, Mortal116, Mortal117, Mortal118, Mortal119, Mortal120, Mortal121, Mortal122, Mortal123, Mortal124, Mortal125, Mortal126, Mortal127, Mortal128, Mortal129, Mortal130, Mortal131, Mortal132, Mortal133, Mortal134, Mortal135, Mortal136, Mortal137, Mortal138, Mortal139, Mortal140, Mortal141, Mortal142, Mortal143, Mortal144, Mortal145, Mortal146, Mortal147, Mortal148, Mortal149, Mortal150, Mortal151, Mortal152, Mortal153, Mortal154, Mortal155, Mortal156, Mortal157, Mortal158, Mortal159, Mortal160, Mortal161, Mortal162, Mortal163, Mortal164, Mortal165, Mortal166, Mortal167, Mortal168, Mortal169, Mortal170, Mortal171, Mortal172, Mortal173, Mortal174, Mortal175, Mortal176, Mortal177, Mortal178, Mortal179, Mortal180, Mortal181, Mortal182, Mortal183, Mortal184, Mortal185, Mortal186, Mortal187, Mortal188, Mortal189, Mortal190, Mortal191, Mortal192, Mortal193, Mortal194, Mortal195, Mortal196, Mortal197, Mortal198, Mortal199, Mortal200, Mortal201, Mortal202, Mortal203, Mortal204, Mortal205, Mortal206, Mortal207, Mortal208, Mortal209, Mortal210, Mortal211, Mortal212, Mortal213, Mortal214, Mortal215, Mortal216, Mortal217, Mortal218, Mortal219, Mortal220, Mortal221, Mortal222, Mortal223, Mortal224, Mortal225, Mortal226, Mortal227, Mortal228, Mortal229, Mortal230, Mortal231, Mortal232, Mortal233, Mortal234, Mortal235, Mortal236, Mortal237, Mortal238, Mortal239, Mortal240, Mortal241, Mortal242, Mortal243, Mortal244, Mortal245, Mortal246, Mortal247, Mortal248, Mortal249, Mortal250, Mortal251, Mortal252, Mortal253, Mortal254, Mortal255)"
  },
  "8ur8bpe8ahbdb": {
    name: "TransactionValidityError",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["sp_runtime.transaction_validity.TransactionValidityError"],
    type: "Enum(Invalid, Unknown)"
  },
  "8vj9hqgjobpdo": {
    name: "ParachainsDisputesEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.disputes.pallet.Event"],
    type: "Enum(DisputeInitiated, DisputeConcluded, Revert)"
  },
  "90bksimft5ia2": {
    name: "DispatchClass",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["frame_support.dispatch.DispatchClass"],
    type: "Enum(Normal, Operational, Mandatory)"
  },
  "910lmkjcsvii": {
    name: "PolkadotRuntimeCommonAssignedSlotsSlotLeasePeriodStart",
    chains: "westend",
    paths: ["polkadot_runtime_common.assigned_slots.SlotLeasePeriodStart"],
    type: "Enum(Current, Next)"
  },
  "926pkc9itkbdk": {
    name: "ReferendaTypesCurve",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["pallet_referenda.types.Curve"],
    type: "Enum(LinearDecreasing, SteppedDecreasing, Reciprocal)"
  },
  "982q4n5eor6ih": {
    name: "XcmV3JunctionNetworkId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.junction.NetworkId", "staging_xcm.v4.junction.NetworkId"],
    type: "Enum(ByGenesis, ByFork, Polkadot, Kusama, Westend, Rococo, Wococo, Ethereum, BitcoinCore, BitcoinCash, PolkadotBulletin)"
  },
  "9d6sev8uj006q": {
    name: "XcmV3MultiassetAssetInstance",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: [
      "xcm.v3.multiasset.AssetInstance",
      "staging_xcm.v4.asset.AssetInstance",
      "staging_xcm.v5.asset.AssetInstance"
    ],
    type: "Enum(Undefined, Index, Array4, Array8, Array16, Array32)"
  },
  "9fihu1euvgfa": {
    name: "PolkadotPrimitivesV6ExecutorParamsExecutorParam",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.executor_params.ExecutorParam",
      "polkadot_primitives.v8.executor_params.ExecutorParam"
    ],
    type: "Enum(MaxMemoryPages, StackLogicalMax, StackNativeMax, PrecheckingMaxMemory, PvfPrepTimeout, PvfExecTimeout, WasmExtBulkMemory)"
  },
  "9jj84pbmaraa": {
    name: "TransactionValidityInvalidTransaction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["sp_runtime.transaction_validity.InvalidTransaction"],
    type: "Enum(Call, Payment, Future, Stale, BadProof, AncientBirthBlock, ExhaustsResources, Custom, BadMandatory, MandatoryValidation, BadSigner)"
  },
  "9lvi13skegcil": {
    name: "ClaimsStatementKind",
    chains: "polkadot, kusama, paseo",
    paths: ["polkadot_runtime_common.claims.StatementKind"],
    type: "Enum(Regular, Saft)"
  },
  "9pobt6o24rqdc": {
    name: "UpgradeRestriction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: [
      "polkadot_primitives.v7.UpgradeRestriction",
      "polkadot_primitives.v8.UpgradeRestriction"
    ],
    type: "Enum(Present)"
  },
  "9uqvk3mspevjn": {
    name: "BabeDigestsPreDigest",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["sp_consensus_babe.digests.PreDigest"],
    type: "Enum(Primary, SecondaryPlain, SecondaryVRF)"
  },
  a2kllcmf9u10g: {
    name: "ParachainsDisputeLocation",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.disputes.DisputeLocation"],
    type: "Enum(Local, Remote)"
  },
  a3gvv195g4jot: {
    name: "DispatchRawOrigin",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["frame_support.dispatch.RawOrigin"],
    type: "Enum(Root, Signed, None)"
  },
  a4b928jbpau7j: {
    name: "RecoveryEvent",
    chains: "kusama, westend",
    paths: ["pallet_recovery.pallet.Event"],
    type: "Enum(RecoveryCreated, RecoveryInitiated, RecoveryVouched, RecoveryClosed, AccountRecovered, RecoveryRemoved)"
  },
  a5gvqckojmehj: {
    name: "ChildBountiesEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_child_bounties.pallet.Event"],
    type: "Enum(Added, Awarded, Claimed, Canceled)"
  },
  adqdire0qjg0e: {
    name: "XcmV2WeightLimit",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.WeightLimit"],
    type: "Enum(Unlimited, Limited)"
  },
  ajkhn97prklo5: {
    name: "ConvictionVotingEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_conviction_voting.pallet.Event"],
    type: "Enum(Delegated, Undelegated)"
  },
  amc6gl7bd9por: {
    name: "XcmV2TraitsError",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.traits.Error"],
    type: "Enum(Overflow, Unimplemented, UntrustedReserveLocation, UntrustedTeleportLocation, MultiLocationFull, MultiLocationNotInvertible, BadOrigin, InvalidLocation, AssetNotFound, FailedToTransactAsset, NotWithdrawable, LocationCannotHold, ExceedsMaxMessageSize, DestinationUnsupported, Transport, Unroutable, UnknownClaim, FailedToDecode, MaxWeightInvalid, NotHoldingFees, TooExpensive, Trap, UnhandledXcmVersion, WeightLimitReached, Barrier, WeightNotComputable)"
  },
  andndh150vhd7: {
    name: "XcmV4Instruction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v4.Instruction"],
    type: "Enum(WithdrawAsset, ReserveAssetDeposited, ReceiveTeleportedAsset, QueryResponse, TransferAsset, TransferReserveAsset, Transact, HrmpNewChannelOpenRequest, HrmpChannelAccepted, HrmpChannelClosing, ClearOrigin, DescendOrigin, ReportError, DepositAsset, DepositReserveAsset, ExchangeAsset, InitiateReserveWithdraw, InitiateTeleport, ReportHolding, BuyExecution, RefundSurplus, SetErrorHandler, SetAppendix, ClearError, ClaimAsset, Trap, SubscribeVersion, UnsubscribeVersion, BurnAsset, ExpectAsset, ExpectOrigin, ExpectError, ExpectTransactStatus, QueryPallet, ExpectPallet, ReportTransactStatus, ClearTransactStatus, UniversalOrigin, ExportMessage, LockAsset, UnlockAsset, NoteUnlockable, RequestUnlock, SetFeesMode, SetTopic, ClearTopic, AliasOrigin, UnpaidExecution)"
  },
  ap9sokavcmq5o: {
    name: "XcmVersionedLocation",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.VersionedLocation"],
    type: "Enum(V2, V3, V4)"
  },
  aquvu9nu2es05: {
    name: "XcmV2MultilocationJunctions",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.multilocation.Junctions"],
    type: "Enum(Here, X1, X2, X3, X4, X5, X6, X7, X8)"
  },
  au5bveb13r5dm: {
    name: "XcmV5AssetFilter",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v5.asset.AssetFilter"],
    type: "Enum(Definite, Wild)"
  },
  avhrl5td7rf4q: {
    name: "TransactionValidityUnknownTransaction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.transaction_validity.UnknownTransaction"],
    type: "Enum(CannotLookup, NoUnsignedValidator, Custom)"
  },
  b1eprmg9d9eh2: {
    name: "CommonAuctionsEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_common.auctions.pallet.Event"],
    type: "Enum(AuctionStarted, AuctionClosed, Reserved, Unreserved, ReserveConfiscated, BidAccepted, WinningOffset)"
  },
  b5fd0r2ju9g0l: {
    name: "CoreState",
    chains: "polkadot, kusama, paseo",
    paths: ["polkadot_primitives.v7.CoreState"],
    type: "Enum(Occupied, Scheduled, Free)"
  },
  bb454pgf9ofrq: {
    name: "StakingPalletConfigOp",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "pallet_staking.pallet.pallet.ConfigOp",
      "pallet_nomination_pools.ConfigOp"
    ],
    type: "Enum(Noop, Set, Remove)"
  },
  bd6859lkk2107: {
    name: "XcmV3JunctionBodyId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.junction.BodyId"],
    type: "Enum(Unit, Moniker, Index, Executive, Technical, Legislative, Judicial, Defense, Administration, Treasury)"
  },
  bgr9ooktct68l: {
    name: "BalancesTypesReasons",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["pallet_balances.types.Reasons"],
    type: "Enum(Fee, Misc, All)"
  },
  biemf2h6nh9pa: {
    name: "XcmV4AssetAssetFilter",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v4.asset.AssetFilter"],
    type: "Enum(Definite, Wild)"
  },
  bkbo8vqdq5g5a: {
    name: "MultiSignature",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.MultiSignature"],
    type: "Enum(Ed25519, Sr25519, Ecdsa)"
  },
  bl1lrline4to8: {
    name: "Phase",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["frame_system.Phase"],
    type: "Enum(ApplyExtrinsic, Finalization, Initialization)"
  },
  bnmfm52c5n7nq: {
    name: "XcmV4TraitsOutcome",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["staging_xcm.v4.traits.Outcome"],
    type: "Enum(Complete, Incomplete, Error)"
  },
  bnvffgg4ckmsj: {
    name: "PolkadotRuntimeOriginCaller",
    chains: "polkadot, paseo",
    paths: ["polkadot_runtime.OriginCaller", "paseo_runtime.OriginCaller"],
    type: "Enum(system, Origins, ParachainsOrigin, XcmPallet, Void)"
  },
  brvqfk00lp42n: {
    name: "GrandpaEquivocation",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["sp_consensus_grandpa.Equivocation"],
    type: "Enum(Prevote, Precommit)"
  },
  bs10onqorvq4b: {
    name: "StakingForcing",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_staking.Forcing"],
    type: "Enum(NotForcing, ForceNew, ForceNone, ForceAlways)"
  },
  bs56nuk6pe5bp: {
    name: "PolkadotPrimitivesV6DisputeStatement",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.DisputeStatement",
      "polkadot_primitives.v8.DisputeStatement"
    ],
    type: "Enum(Valid, Invalid)"
  },
  bs795i39p1rsf: {
    name: "XcmV5Instruction",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v5.Instruction"],
    type: "Enum(WithdrawAsset, ReserveAssetDeposited, ReceiveTeleportedAsset, QueryResponse, TransferAsset, TransferReserveAsset, Transact, HrmpNewChannelOpenRequest, HrmpChannelAccepted, HrmpChannelClosing, ClearOrigin, DescendOrigin, ReportError, DepositAsset, DepositReserveAsset, ExchangeAsset, InitiateReserveWithdraw, InitiateTeleport, ReportHolding, BuyExecution, RefundSurplus, SetErrorHandler, SetAppendix, ClearError, ClaimAsset, Trap, SubscribeVersion, UnsubscribeVersion, BurnAsset, ExpectAsset, ExpectOrigin, ExpectError, ExpectTransactStatus, QueryPallet, ExpectPallet, ReportTransactStatus, ClearTransactStatus, UniversalOrigin, ExportMessage, LockAsset, UnlockAsset, NoteUnlockable, RequestUnlock, SetFeesMode, SetTopic, ClearTopic, AliasOrigin, UnpaidExecution, PayFees, InitiateTransfer, ExecuteWithOrigin, SetHints)"
  },
  bta4mfoh73fpt: {
    name: "PolkadotPrimitivesV6ValidDisputeStatementKind",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.ValidDisputeStatementKind",
      "polkadot_primitives.v8.ValidDisputeStatementKind"
    ],
    type: "Enum(Explicit, BackingSeconded, BackingValid, ApprovalChecking, ApprovalCheckingMultipleCandidates)"
  },
  c0rsdcbsdt7kf: {
    name: "GovernanceOrigin",
    chains: "polkadot, paseo",
    paths: [
      "polkadot_runtime.governance.origins.pallet_custom_origins.Origin",
      "paseo_runtime.governance.origins.pallet_custom_origins.Origin"
    ],
    type: "Enum(StakingAdmin, Treasurer, FellowshipAdmin, GeneralAdmin, AuctionAdmin, LeaseAdmin, ReferendumCanceller, ReferendumKiller, SmallTipper, BigTipper, SmallSpender, MediumSpender, BigSpender, WhitelistedCaller, WishForChange)"
  },
  c1jnealhlqk0n: {
    name: "WestendRuntimeRuntimeFreezeReason",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_runtime.RuntimeFreezeReason",
      "staging_kusama_runtime.RuntimeFreezeReason",
      "paseo_runtime.RuntimeFreezeReason",
      "westend_runtime.RuntimeFreezeReason"
    ],
    type: "Enum(NominationPools)"
  },
  c4alvt16n58rg: {
    name: "ParachainsHrmpEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.hrmp.pallet.Event"],
    type: "Enum(OpenChannelRequested, OpenChannelCanceled, OpenChannelAccepted, ChannelClosed, HrmpChannelForceOpened, HrmpSystemChannelOpened, OpenChannelDepositsUpdated)"
  },
  c5529239bmt3g: {
    name: "ElectionProviderMultiPhaseEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_election_provider_multi_phase.pallet.Event"],
    type: "Enum(SolutionStored, ElectionFinalized, ElectionFailed, Rewarded, Slashed, PhaseTransitioned)"
  },
  c7d5cscq9c6gi: {
    name: "PolkadotPrimitivesV6PvfPrepKind",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.PvfPrepKind",
      "polkadot_primitives.v8.PvfPrepKind"
    ],
    type: "Enum(Precheck, Prepare)"
  },
  cb4i7efmuhik2: {
    name: "ParachainsParasEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.paras.pallet.Event"],
    type: "Enum(CurrentCodeUpdated, CurrentHeadUpdated, CodeUpgradeScheduled, NewHeadNoted, ActionQueued, PvfCheckStarted, PvfCheckAccepted, PvfCheckRejected)"
  },
  cc0rvpoin8ucr: {
    name: "VersionedLocatableAsset",
    chains: "polkadot, polkadot.collectives, kusama, paseo",
    paths: ["polkadot_runtime_common.impls.VersionedLocatableAsset"],
    type: "Enum(V3, V4)"
  },
  cee77qkk3c81t: {
    name: "ConvictionVotingVoteAccountVote",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_conviction_voting.vote.AccountVote"],
    type: "Enum(Standard, Split, SplitAbstain)"
  },
  cg1p3hrtv6n5f: {
    name: "XcmV2MultiassetWildFungibility",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: [
      "xcm.v2.multiasset.WildFungibility",
      "xcm.v3.multiasset.WildFungibility",
      "staging_xcm.v4.asset.WildFungibility",
      "staging_xcm.v5.asset.WildFungibility"
    ],
    type: "Enum(Fungible, NonFungible)"
  },
  cg9t1ptkdnbi3: {
    name: "GrandpaEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_grandpa.pallet.Event"],
    type: "Enum(NewAuthorities, Paused, Resumed)"
  },
  cgde8bg5ldqpa: {
    name: "PreimagesBounded",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["frame_support.traits.preimages.Bounded"],
    type: "Enum(Legacy, Inline, Lookup)"
  },
  cgoc620vdl0ci: {
    name: "BrokerCoretimeInterfaceCoreAssignment",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_broker.coretime_interface.CoreAssignment"],
    type: "Enum(Idle, Pool, Task)"
  },
  chgaqm88qcdbe: {
    name: "XcmVersionedLocation",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.VersionedLocation"],
    type: "Enum(V3, V4, V5)",
    priority: 1
  },
  cjonl4a47pcm8: {
    name: "TransactionPaymentEvent",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["pallet_transaction_payment.pallet.Event"],
    type: "Enum(TransactionFeePaid)"
  },
  clvofdpge58e1: {
    name: "XcmVersionedAsset",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.VersionedAsset"],
    type: "Enum(V3, V4, V5)",
    priority: 1
  },
  cn24k411b4s6t: {
    name: "PolkadotRuntimeCommonAssignedSlotsEvent",
    chains: "westend",
    paths: ["polkadot_runtime_common.assigned_slots.pallet.Event"],
    type: "Enum(PermanentSlotAssigned, TemporarySlotAssigned, MaxPermanentSlotsChanged, MaxTemporarySlotsChanged)"
  },
  cpkfkhj5jq924: {
    name: "TransactionValidityTransactionSource",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.transaction_validity.TransactionSource"],
    type: "Enum(InBlock, Local, External)"
  },
  csmfdagrgtkj5: {
    name: "XcmV4Response",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v4.Response"],
    type: "Enum(Null, Assets, ExecutionResult, Version, PalletsInfo, DispatchResult)"
  },
  cuaiiptinb4jf: {
    name: "Version",
    chains: "polkadot, polkadot.assetHub, polkadot.collectives, kusama, kusama.assetHub, paseo, paseo.assetHub, westend, westend.collectives",
    paths: ["pallet_vesting.Releases", "pallet_alliance.types.Version"],
    type: "Enum(V0, V1)"
  },
  d226b5du5oie9: {
    name: "VestingEvent",
    chains: "polkadot, polkadot.assetHub, kusama, kusama.assetHub, paseo, paseo.assetHub, westend",
    paths: ["pallet_vesting.pallet.Event"],
    type: "Enum(VestingUpdated, VestingCompleted)"
  },
  d2d2vjc8h66mf: {
    name: "XcmV3MultiassetFungibility",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: [
      "xcm.v3.multiasset.Fungibility",
      "staging_xcm.v4.asset.Fungibility",
      "staging_xcm.v5.asset.Fungibility"
    ],
    type: "Enum(Fungible, NonFungible)"
  },
  d7em8997pfm92: {
    name: "MultiSigner",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["sp_runtime.MultiSigner"],
    type: "Enum(Ed25519, Sr25519, Ecdsa)"
  },
  d7hag4aqiaqqv: {
    name: "PolkadotRuntimeParachainsSchedulerPalletCoreOccupied",
    chains: "polkadot, kusama, paseo",
    paths: ["polkadot_runtime_parachains.scheduler.pallet.CoreOccupied"],
    type: "Enum(Free, Paras)"
  },
  dp2d78gpqj4r6: {
    name: "ParachainsInclusionEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["polkadot_runtime_parachains.inclusion.pallet.Event"],
    type: "Enum(CandidateBacked, CandidateIncluded, CandidateTimedOut, UpwardMessagesReceived)"
  },
  e252kk4p31sv6: {
    name: "XcmV4AssetWildAsset",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v4.asset.WildAsset"],
    type: "Enum(All, AllOf, AllCounted, AllOfCounted)"
  },
  e3otks9vj8a3b: {
    name: "TraitsScheduleDispatchTime",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.assetHub, westend.collectives",
    paths: ["frame_support.traits.schedule.DispatchTime"],
    type: "Enum(At, After)"
  },
  e5ojv0odma80: {
    name: "ConvictionVotingVoteVoting",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_conviction_voting.vote.Voting"],
    type: "Enum(Casting, Delegating)"
  },
  ei6k1tdcht3q: {
    name: "BountiesEvent",
    chains: "polkadot, kusama, paseo",
    paths: ["pallet_bounties.pallet.Event"],
    type: "Enum(BountyProposed, BountyRejected, BountyBecameActive, BountyAwarded, BountyClaimed, BountyCanceled, BountyExtended, BountyApproved, CuratorProposed, CuratorUnassigned, CuratorAccepted)"
  },
  ek17d55ubjjm9: {
    name: "BabeDigestsNextConfigDescriptor",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["sp_consensus_babe.digests.NextConfigDescriptor"],
    type: "Enum(V1)"
  },
  es1oivk962n6f: {
    name: "XcmV2MultiassetAssetId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.multiasset.AssetId"],
    type: "Enum(Concrete, Abstract)"
  },
  eu5nmcltehl17: {
    name: "XcmV5WildAsset",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v5.asset.WildAsset"],
    type: "Enum(All, AllOf, AllCounted, AllOfCounted)"
  },
  f331um1stp6g0: {
    name: "UpgradeGoAhead",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: [
      "polkadot_primitives.v7.UpgradeGoAhead",
      "polkadot_primitives.v8.UpgradeGoAhead"
    ],
    type: "Enum(Abort, GoAhead)"
  },
  f5frjbmqcgt5k: {
    name: "XcmV2JunctionBodyPart",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.junction.BodyPart", "xcm.v2.BodyPart"],
    type: "Enum(Voice, Members, Fraction, AtLeastProportion, MoreThanProportion)"
  },
  f6qqn0nd8o1nf: {
    name: "PolkadotRuntimeParachainsSchedulerCommonAssignment",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_parachains.scheduler.common.Assignment"],
    type: "Enum(Pool, Bulk)"
  },
  f87qnbuqe30lh: {
    name: "TransactionalError",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["sp_runtime.TransactionalError"],
    type: "Enum(LimitReached, NoLayer)"
  },
  f9rpgkuafvsb4: {
    name: "InvalidDisputeStatementKind",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.InvalidDisputeStatementKind",
      "polkadot_primitives.v8.InvalidDisputeStatementKind"
    ],
    type: "Enum(Explicit)"
  },
  faafmcb1jmm2o: {
    name: "XcmV3Junctions",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.junctions.Junctions", "staging_xcm.v4.junctions.Junctions"],
    type: "Enum(Here, X1, X2, X3, X4, X5, X6, X7, X8)"
  },
  fbiij71gdkvth: {
    name: "WestendRuntimeProxyType",
    chains: "westend",
    paths: ["westend_runtime.ProxyType"],
    type: "Enum(Any, NonTransfer, Governance, Staking, SudoBalances, IdentityJudgement, CancelProxy, Auction, NominationPools)"
  },
  fcqan2gt5adqc: {
    name: "TransactionPaymentReleases",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["pallet_transaction_payment.Releases"],
    type: "Enum(V1Ancient, V2)"
  },
  fdctp8g6s725t: {
    name: "CommonSlotsEvent",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["polkadot_runtime_common.slots.pallet.Event"],
    type: "Enum(NewLeasePeriod, Leased)"
  },
  fddrr93rdab23: {
    name: "XcmV2MultiAssetFilter",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.multiasset.MultiAssetFilter"],
    type: "Enum(Definite, Wild)"
  },
  fedog0bf6e64f: {
    name: "XcmVersionedAssets",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.VersionedAssets"],
    type: "Enum(V3, V4, V5)",
    priority: 1
  },
  fms5l9j358vie: {
    name: "StakingPalletConfigOpBig",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "pallet_staking.pallet.pallet.ConfigOp",
      "pallet_nomination_pools.ConfigOp"
    ],
    type: "Enum(Noop, Set, Remove)"
  },
  fou8ip7o6q00t: {
    name: "XcmVersionedAssetId",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.VersionedAssetId"],
    type: "Enum(V3, V4)"
  },
  fqkhvelo2q77o: {
    name: "ValidityAttestation",
    chains: "polkadot, kusama, paseo, westend",
    paths: [
      "polkadot_primitives.v7.ValidityAttestation",
      "polkadot_primitives.v8.ValidityAttestation"
    ],
    type: "Enum(Implicit, Explicit)"
  },
  hpogi4p6q6h5: {
    name: "PreimagePalletHoldReason",
    chains: "polkadot, polkadot.collectives, kusama, paseo, westend, westend.collectives",
    paths: ["pallet_preimage.pallet.HoldReason"],
    type: "Enum(Preimage)"
  },
  htopdh9noje5: {
    name: "ElectionProviderMultiPhaseElectionCompute",
    chains: "polkadot, kusama, paseo, westend",
    paths: ["pallet_election_provider_multi_phase.ElectionCompute"],
    type: "Enum(OnChain, Signed, Unsigned, Fallback, Emergency)"
  },
  m2dj93rjj6ks: {
    name: "XcmVersionedXcm",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.VersionedXcm"],
    type: "Enum(V2, V3, V4)"
  },
  ml0q5vk4ei4e: {
    name: "XcmV2Instruction",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub",
    paths: ["xcm.v2.Instruction"],
    type: "Enum(WithdrawAsset, ReserveAssetDeposited, ReceiveTeleportedAsset, QueryResponse, TransferAsset, TransferReserveAsset, Transact, HrmpNewChannelOpenRequest, HrmpChannelAccepted, HrmpChannelClosing, ClearOrigin, DescendOrigin, ReportError, DepositAsset, DepositReserveAsset, ExchangeAsset, InitiateReserveWithdraw, InitiateTeleport, QueryHolding, BuyExecution, RefundSurplus, SetErrorHandler, SetAppendix, ClearError, ClaimAsset, Trap, SubscribeVersion, UnsubscribeVersion)"
  },
  ndkvtfs34lhc: {
    name: "XcmV5Junction",
    chains: "westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["staging_xcm.v5.junction.Junction"],
    type: "Enum(Parachain, AccountId32, AccountIndex64, AccountKey20, PalletInstance, GeneralIndex, GeneralKey, OnlyChild, Plurality, GlobalConsensus)"
  },
  tofo38uukr3h: {
    name: "RootTestingEvent",
    chains: "westend",
    paths: ["pallet_root_testing.pallet.Event"],
    type: "Enum(DefensiveTestCall)"
  },
  ukot04uppvug: {
    name: "XcmV3MultiassetMultiAssetFilter",
    chains: "polkadot, polkadot.assetHub, polkadot.bridgeHub, polkadot.collectives, polkadot.people, kusama, kusama.assetHub, kusama.bridgeHub, kusama.people, paseo, paseo.assetHub, westend, westend.assetHub, westend.bridgeHub, westend.collectives, westend.people",
    paths: ["xcm.v3.multiasset.MultiAssetFilter"],
    type: "Enum(Definite, Wild)"
  }
};
const knownTypes = utils.mapObject(
  knownTypesRepository,
  (entry) => typeof entry === "string" ? { name: entry, priority: 0 } : { name: entry.name, priority: entry.priority ?? 0 }
);

function applyWhitelist(metadata, whitelist) {
  if (!whitelist) return metadata;
  const allApis = whitelist.includes("api.*");
  const fullApiRegex = /^api\.(\w+)\.\*$/;
  const fullApiIncluded = whitelist.map((w) => fullApiRegex.exec(w)?.[1]).filter((v) => !!v);
  const apis = allApis ? metadata.apis : metadata.apis.map((api) => {
    if (fullApiIncluded.includes(api.name)) return api;
    return {
      ...api,
      methods: api.methods.filter(
        (method) => whitelist.includes(`api.${api.name}.${method.name}`)
      )
    };
  }).filter((api) => api.methods.length > 0);
  const fullPalletRegex = /^\*\.(\w+)$/;
  const fullPallets = whitelist.map((w) => fullPalletRegex.exec(w)?.[1]).filter((v) => !!v);
  const filterEnum = (whitelistPrefix, palletName, entry) => {
    if (!entry) return entry;
    if (whitelist.includes(`${whitelistPrefix}.*`) || whitelist.includes(`${whitelistPrefix}.${palletName}.*`))
      return entry;
    const def = metadata.lookup[entry.type].def;
    if (def.tag !== "variant") throw new Error(whitelistPrefix + " not an enum");
    const prefixNotIncluded = whitelist.every(
      (e) => !e.startsWith(`${whitelistPrefix}.${palletName}`)
    );
    const value = prefixNotIncluded ? [] : def.value.filter(
      ({ name }) => whitelist.includes(`${whitelistPrefix}.${palletName}.${name}`)
    );
    const idx = metadata.lookup.length;
    metadata.lookup.push({
      ...metadata.lookup[entry.type],
      id: idx,
      def: {
        tag: "variant",
        value
      }
    });
    return "deprecationInfo" in entry ? {
      type: idx,
      deprecationInfo: entry.deprecationInfo
    } : { type: idx };
  };
  const getEnumLength = (lookupIdx) => {
    if (!lookupIdx) return 0;
    const def = metadata.lookup[lookupIdx].def;
    if (def.tag !== "variant") throw new Error("not an enum");
    return def.value.length;
  };
  const filterList = (whitelistPrefix, palletName, list) => {
    if (whitelist.includes(`${whitelistPrefix}.*`) || whitelist.includes(`${whitelistPrefix}.${palletName}.*`))
      return list;
    const prefixNotIncluded = whitelist.every(
      (e) => !e.startsWith(`${whitelistPrefix}.${palletName}`)
    );
    if (prefixNotIncluded) return [];
    return list.filter(
      ({ name }) => whitelist.includes(`${whitelistPrefix}.${palletName}.${name}`)
    );
  };
  const filterPallets = (pallets2, filterErrors) => pallets2.map((pallet) => {
    if (fullPallets.includes(pallet.name)) return pallet;
    return {
      ...pallet,
      calls: filterEnum("tx", pallet.name, pallet.calls),
      constants: filterList("const", pallet.name, pallet.constants),
      errors: filterErrors ? void 0 : pallet.errors,
      events: filterEnum("event", pallet.name, pallet.events),
      storage: pallet.storage ? {
        ...pallet.storage,
        items: filterList("query", pallet.name, pallet.storage.items)
      } : void 0,
      viewFns: filterList("view", pallet.name, pallet.viewFns)
    };
  }).filter(
    (pallet) => getEnumLength(pallet.calls?.type) + pallet.constants.length + getEnumLength(pallet.errors?.type) + getEnumLength(pallet.events?.type) + (pallet.storage?.items.length ?? 0) + pallet.viewFns.length
  );
  const pallets = filterPallets(metadata.pallets, false);
  const visitedIdxs = [];
  const lookup = metadataBuilders.getLookupFn({ ...metadata, apis, pallets });
  getUsedTypes(lookup, metadataBuilders.getChecksumBuilder(lookup)).checksums.forEach(
    (_, idx) => visitedIdxs.push(idx)
  );
  let hasModuleError = false;
  for (const idx of visitedIdxs) {
    const visited = lookup(idx);
    if (visited.type === "enum" && visited.byteLength != null) {
      hasModuleError = true;
      break;
    }
  }
  return {
    ...metadata,
    apis,
    pallets: hasModuleError ? pallets : filterPallets(pallets, true)
  };
}

const generateMultipleDescriptors = (chains, paths, options = {}) => {
  const chainData = chains.map((chain) => {
    const metadata = options.whitelist ? applyWhitelist(chain.metadata, options.whitelist) : chain.metadata;
    const lookup = metadataBuilders.getLookupFn(metadata);
    const builder = metadataBuilders.getChecksumBuilder(lookup);
    const { checksums, types: types2, entryPoints } = getUsedTypes(lookup, builder);
    return {
      ...chain,
      lookup,
      builder,
      checksums,
      types: types2,
      entryPoints,
      knownTypes: {
        ...knownTypes,
        ...chain.knownTypes
      }
    };
  });
  resolveConflicts(chainData);
  const types = mergeTypes(chainData);
  const declarations = defaultDeclarations();
  const chainFiles = chainData.map(
    (chain) => generateDescriptors(
      chain.lookup,
      types.checksumToIdx,
      getTypesBuilder(
        declarations,
        chain.lookup,
        chain.knownTypes,
        chain.builder
      ),
      chain.builder,
      chain.key,
      paths,
      chain.genesis
    )
  );
  const descriptorsFileContent = generateDescriptorValuesContent(
    Object.fromEntries(
      chainFiles.map((file, i) => [chainData[i].key, file.descriptorValues])
    )
  );
  const commonFileContent = `const table = new Uint8Array(128);
for (let i = 0; i < 64; i++) table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
export const toBinary = (base64: string) => {
  const n = base64.length,
    bytes = new Uint8Array((n - Number(base64[n - 1] === '=') - Number(base64[n - 2] === '=')) * 3 / 4 | 0);
  for (let i2 = 0, j = 0; i2 < n;) {
    const c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
    const c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
    bytes[j++] = c0 << 2 | c1 >> 4;
    bytes[j++] = c1 << 4 | c2 >> 2;
    bytes[j++] = c2 << 6 | c3;
  }
  return bytes;
}`;
  return {
    commonFileContent,
    descriptorsFileContent,
    metadataTypes: types,
    descriptorTypesFiles: chainFiles.map((file) => ({
      content: file.descriptorTypes,
      exports: file.exports
    })),
    typesFileContent: generateTypes(
      declarations,
      paths,
      new Set(chainFiles.map((x) => x.commonTypeImports).flat())
    ),
    publicTypes: getPublicTypes(declarations.variables)
  };
};
function getPublicTypes(variables) {
  return Array.from(variables.values()).filter((variable) => variable.type.startsWith("Enum<")).map((variable) => variable.name);
}
function resolveConflicts(chainData) {
  const usedNames = /* @__PURE__ */ new Map();
  chainData.forEach(
    (chain) => chain.checksums.forEach((checksum) => {
      const known = chain.knownTypes[checksum];
      if (!known) return;
      const { name } = known;
      if (!usedNames.has(name)) {
        usedNames.set(name, /* @__PURE__ */ new Map());
      }
      if (!usedNames.get(name).has(chain.key)) {
        usedNames.get(name).set(chain.key, /* @__PURE__ */ new Set());
      }
      usedNames.get(name).get(chain.key).add(checksum);
    })
  );
  const conflictedNames = Array.from(usedNames.entries()).filter(([_, chainToChecksums]) => {
    const checksums = new Set(
      Array.from(chainToChecksums.values()).flatMap((v) => [...v])
    );
    if (checksums.size === 1) return false;
    const allAreTheSame = Array.from(chainToChecksums.values()).every(
      (chainChecksums) => chainChecksums.size === checksums.size
    );
    if (allAreTheSame) return false;
    return true;
  }).map(([name]) => name);
  conflictedNames.forEach((name) => {
    const nameChecksums = Array.from(
      new Set(
        Array.from(usedNames.get(name)?.values() ?? []).flatMap(
          (v) => Array.from(v)
        )
      )
    );
    const checksumMaxPriority = nameChecksums.map((checksum) => ({
      checksum,
      priority: chainData.map((chain) => chain.knownTypes[checksum]?.priority ?? 0).reduce((a, b) => Math.max(a, b), 0)
    }));
    const absoluteMax = checksumMaxPriority.map((v) => v.priority).reduce((a, b) => Math.max(a, b), 0);
    const checksumsLowPriority = checksumMaxPriority.filter(
      (v) => v.priority !== absoluteMax
    );
    const checksumsChangingName = checksumsLowPriority.length === checksumMaxPriority.length - 1 ? checksumsLowPriority : checksumMaxPriority;
    chainData.forEach(
      (chain) => checksumsChangingName.forEach(({ checksum }) => {
        if (!chain.knownTypes[checksum]) return;
        chain.knownTypes[checksum] = {
          name: capitalize(chain.key) + name,
          priority: chain.knownTypes[checksum].priority
        };
      })
    );
  });
}
function mergeTypes(chainData) {
  const typedefs = [];
  const entryPoints = [];
  const loookupToTypedefIdx = /* @__PURE__ */ new Map();
  const checksumToIdx = /* @__PURE__ */ new Map();
  chainData.forEach(({ types, entryPoints: chainEntryPoints, checksums }) => {
    for (const entry of types.entries()) {
      const [checksum, value] = entry;
      if (loookupToTypedefIdx.has(checksum)) continue;
      loookupToTypedefIdx.set(checksum, typedefs.length);
      typedefs.push([value, checksums]);
    }
    for (const entry of chainEntryPoints.entries()) {
      const [checksum, value] = entry;
      if (checksumToIdx.has(checksum)) continue;
      checksumToIdx.set(checksum, entryPoints.length);
      entryPoints.push([value, checksums]);
    }
  });
  const updatedTypedefs = typedefs.map(
    ([typedef, checksums]) => metadataCompatibility.mapReferences(typedef, (id) => loookupToTypedefIdx.get(checksums[id]))
  );
  const updatedEntryPoints = entryPoints.map(
    ([entryPoint, checksums]) => metadataCompatibility.mapEntryPointReferences(
      entryPoint,
      (id) => loookupToTypedefIdx.get(checksums[id])
    )
  );
  return {
    typedefs: updatedTypedefs,
    entryPoints: updatedEntryPoints,
    checksumToIdx
  };
}
function generateDescriptorValuesContent(descriptorValues) {
  const usages = {};
  const countUsages = (obj) => Object.entries(obj).forEach(([key, value]) => {
    usages[key] = usages[key] ?? 0;
    usages[key]++;
    if (typeof value === "object") countUsages(value);
  });
  countUsages(descriptorValues);
  const tokens = [];
  const tokenToIdx = {};
  const minifyKeys = (obj) => Object.fromEntries(
    Object.entries(obj).map(([key, value]) => {
      const newValue = typeof value === "number" ? value : minifyKeys(value);
      if (usages[key] <= 1) return [key, newValue];
      if (!(key in tokenToIdx)) {
        tokenToIdx[key] = tokens.length;
        tokens.push(key);
      }
      return [tokenToIdx[key], newValue];
    })
  );
  const minified = utils.mapObject(descriptorValues, minifyKeys);
  const getTreeKey = (tree) => Object.entries(tree).sort(([a], [b]) => a.localeCompare(b)).map(
    ([key, value]) => `[${key}:${typeof value === "object" ? getTreeKey(value) : value}]`
  ).join("");
  const findCommonTrees = (values) => {
    const treeUsages = {};
    const keys = values.map(
      (obj) => utils.mapObject(obj, (tree) => {
        const key = getTreeKey(tree);
        treeUsages[key] = treeUsages[key] ?? 0;
        treeUsages[key]++;
        return key;
      })
    );
    const commonTrees2 = [];
    const keyToCommonTree = {};
    values.forEach(
      (obj, i) => Object.entries(obj).forEach(([objKey, tree]) => {
        const key = keys[i][objKey];
        if (treeUsages[key] > 1) {
          if (!(key in keyToCommonTree)) {
            keyToCommonTree[key] = commonTrees2.length;
            commonTrees2.push(tree);
          }
          obj[objKey] = keyToCommonTree[key];
        }
      })
    );
    return commonTrees2;
  };
  const commonTrees = findCommonTrees(
    Object.keys(Object.values(minified)[0]).flatMap(
      (type) => Object.values(minified).map((d) => d[type])
    )
  );
  const data = JSON.stringify([minified, commonTrees, tokens]);
  return `
    const [minified, commonTrees, tokens] = JSON.parse(\`${data}\`);

    const replaceTokens = <T>(obj: Record<string | number, T>): Record<string, T> =>
      Object.fromEntries(
        Object.entries(obj).map(([key, value]) => {
          const unwrappedValue =
            typeof value === "object" ? replaceTokens(value as any) : value
          const numericKey = Number(key)
          if (Number.isNaN(numericKey)) {
            return [key, unwrappedValue]
          }
          return [tokens[numericKey], unwrappedValue]
        }),
      ) as Record<string, T>
    const tokenizedCommonTrees = commonTrees.map(replaceTokens)

    const unwrap = (
      obj: Record<string, object | number>,
      depth: number,
    ): Record<string, object> =>
      depth === 0
        ? (obj as Record<string, object>)
        : Object.fromEntries(
            Object.entries(obj).map(([key, value]) => [
              key,
              unwrap(
                typeof value === "object" ? value : tokenizedCommonTrees[value],
                depth - 1,
              ),
            ]),
          )

    const getChainDescriptors = (key: string) =>
      unwrap(replaceTokens(minified[key]), 2)

    ${Object.keys(descriptorValues).map(
    (key) => `export const ${capitalize(key)} = getChainDescriptors("${key}")`
  ).join("\n")}
  `;
}

const paths = {
  client: "polkadot-api",
  types: "types"
};
async function generateDocsDescriptors(key, metadata) {
  const lookup = metadataBuilders.getLookupFn(metadata);
  const checksumBuilder = metadataBuilders.getChecksumBuilder(lookup);
  const docsTypesBuilder = getDocsTypesBuilder(
    lookup,
    knownTypes,
    checksumBuilder
  );
  const getClientImports = () => [
    "StorageDescriptor",
    "PlainDescriptor",
    "TxDescriptor",
    "RuntimeDescriptor",
    "Enum",
    "_Enum",
    "Binary",
    "FixedSizeBinary",
    "FixedSizeArray",
    "QueryFromPalletsDef",
    "TxFromPalletsDef",
    "EventsFromPalletsDef",
    "ErrorsFromPalletsDef",
    "ConstFromPalletsDef",
    "ViewFnsFromPalletsDef",
    "SS58String",
    "ResultPayload",
    "TxCallData",
    ...docsTypesBuilder.getClientFileImports()
  ];
  const storageOutput = await buildStorage(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const runtimeCallsOutput = await buildRuntimeCalls(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const errorsOutput = await buildErrors(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const constantsOutput = await buildConstants(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const eventsOutput = await buildEvents(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const callsOutput = await buildCalls(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const viewFnsOutput = await buildViewFns(
    metadata,
    docsTypesBuilder,
    getClientImports
  );
  const descriptorsTypesFileContent = `import {
  ${getClientImports().join(",\n  ")}
} from "${paths.client}";
` + docsTypesBuilder.getDescriptorsTypes().map((variable) => {
    return `export type ${variable.name} = ${variable.type};`;
  }).join("\n") + `
/**
 * This is a special type that we're using only in this docs.
 * It's not present in descriptors generated by polkadot-api, and only used for 
 * marking circular types, if they aren't a known type.  
 */
export type __Circular = any;
`;
  const hasSection = {
    storage: storageOutput.index !== "",
    runtimeCalls: runtimeCallsOutput.index !== "",
    errors: errorsOutput.index !== "",
    constants: constantsOutput.index !== "",
    events: eventsOutput.index !== "",
    calls: callsOutput.index !== "",
    viewFns: viewFnsOutput.index !== ""
  };
  const index = getIndexFileDocs({ chainName: key, hasSection });
  return {
    index,
    types: descriptorsTypesFileContent,
    Storage: storageOutput,
    RuntimeCalls: runtimeCallsOutput,
    Errors: errorsOutput,
    Constants: constantsOutput,
    Events: eventsOutput,
    Transactions: callsOutput,
    ViewFunctions: viewFnsOutput
  };
}
const buildEnumObj = (metadata, val, cb) => {
  if (val === void 0) return {};
  const lookup = metadata.lookup[val];
  if (lookup.def.tag !== "variant") throw null;
  return Object.fromEntries(
    lookup.def.value.map((x) => {
      return [x.name, cb(x.name, x.docs)];
    })
  );
};
async function buildErrors(metadata, docsTypesBuilder, getClientImports) {
  const errors = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.errors?.type, (name, docs) => {
            return {
              type: `PlainDescriptor<${docsTypesBuilder.buildError(
                pallet.name,
                name
              )}>`,
              docs
            };
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(errors, getClientImports);
}
async function buildConstants(metadata, docsTypesBuilder, getClientImports) {
  const constants = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: Object.fromEntries(
            pallet.constants?.map(({ name, docs }) => {
              const type = `PlainDescriptor<${docsTypesBuilder.buildConstant(
                pallet.name,
                name
              )}>`;
              return [
                name,
                {
                  type,
                  docs
                }
              ];
            }) ?? []
          ),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(constants, getClientImports);
}
async function buildEvents(metadata, docsTypesBuilder, getClientImports) {
  const events = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.events?.type, (name, docs) => {
            return {
              type: `PlainDescriptor<${docsTypesBuilder.buildEvent(
                pallet.name,
                name
              )}>`,
              docs
            };
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(events, getClientImports);
}
async function buildCalls(metadata, docsTypesBuilder, getClientImports) {
  const calls = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: buildEnumObj(metadata, pallet.calls?.type, (name, docs) => {
            return {
              type: `TxDescriptor<${docsTypesBuilder.buildCall(
                pallet.name,
                name
              )}>`,
              docs
            };
          }),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(calls, getClientImports);
}
async function buildRuntimeCalls(metadata, docsTypesBuilder, getClientImports) {
  const runtimeCalls = Object.fromEntries(
    metadata.apis.map((api) => [
      api.name,
      {
        docs: api.docs,
        values: Object.fromEntries(
          api.methods.map((method) => {
            const { args, value } = docsTypesBuilder.buildRuntimeCall(
              api.name,
              method.name
            );
            return [
              method.name,
              {
                type: `RuntimeDescriptor<${args}, ${value}>`,
                docs: method.docs
              }
            ];
          })
        ),
        descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
      }
    ])
  );
  return buildTypeFolder(runtimeCalls, getClientImports);
}
async function buildViewFns(metadata, docsTypesBuilder, getClientImports) {
  const viewFns = Object.fromEntries(
    metadata.pallets.map((pallet) => [
      pallet.name,
      {
        docs: pallet.docs,
        values: Object.fromEntries(
          pallet.viewFns.map((fn) => {
            const { args, value } = docsTypesBuilder.buildViewFn(
              pallet.name,
              fn.name
            );
            return [
              fn.name,
              {
                type: `RuntimeDescriptor<${args}, ${value}>`,
                docs: fn.docs
              }
            ];
          })
        ),
        descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
      }
    ])
  );
  return buildTypeFolder(viewFns, getClientImports);
}
async function buildStorage(metadata, docsTypesBuilder, getClientImports) {
  const storage = Object.fromEntries(
    metadata.pallets.map((pallet) => {
      return [
        pallet.name,
        {
          docs: pallet.docs,
          values: Object.fromEntries(
            pallet.storage?.items.map((item) => {
              const { name, docs, modifier } = item;
              if (pallet.name === "System" && name === "Events") {
                return [
                  "Events",
                  {
                    type: `StorageDescriptor<[], any, ${!modifier}, "never">`,
                    docs: [
                      ...docs,
                      "",
                      " Due to readability reasons, return type of Events item is omitted in this documentation"
                    ]
                  }
                ];
              }
              const { args, payload, opaque } = docsTypesBuilder.buildStorage(
                pallet.name,
                name
              );
              return [
                name,
                {
                  type: `StorageDescriptor<${args}, ${payload === "undefined" ? "null" : payload}, ${!modifier}, ${opaque}>`,
                  docs
                }
              ];
            }) ?? []
          ),
          descriptorsTypesImports: docsTypesBuilder.recordTypeFileImports()
        }
      ];
    })
  );
  return buildTypeFolder(storage, getClientImports);
}
function buildTypeFolder(input, getClientImports) {
  const output = {};
  output["index"] = "";
  for (const [
    section,
    { docs, values, descriptorsTypesImports }
  ] of Object.entries(input)) {
    if (Object.keys(values).length === 0) continue;
    const sectionDocs = docs.length > 0 ? `
/**
${docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
 * @packageDocumentation
 */


` : "";
    const imports = `
import {
  ${getClientImports().join(",\n  ")}
} from "${paths.client}";

import {
  ${descriptorsTypesImports.join(",\n  ")}
} from "../${paths.types}";
  `;
    output[section] = sectionDocs + imports + Object.entries(values).map(
      ([typeName, typeDef]) => formatDocs(typeDef.docs) + // splitting type declaration and export allows us to curcumvent potential
      // collisions between imports and type names
      `
type ${section}_${typeName} = ${typeDef.type};
export {${section}_${typeName} as ${typeName}};`
    ).join("\n");
    output["index"] += `export * as ${section} from "./${section}";
`;
  }
  return output;
}
function formatDocs(docs) {
  return `/**
${docs.map((doc) => ` * ${doc.trim()}`).join("\n")}
*/
`;
}
function getIndexFileDocs({
  chainName,
  hasSection
}) {
  return `
/**
 * This is generated documentation for TypedAPI decriptors for **${chainName}** chain  
 * 
 * **TypedApi calls** section describes apis that are available via calls like  
 * \`\`\`ts
 * api.tx.XcmPallet.limited_teleport_assets({...})
 * \`\`\`
 * Where \`api\` is returned by \`client.getTypedApi(${chainName})\` call  
 *
 * Each section has APIs grouped by pallet name  
 * 
 * **Types** represent TypeScript types that are to be imported
 * from \`@polkadot-api/descriptors\`:  
 * \`\`\`ts
 * import { XcmVersionedLocation, XcmV3Junctions } from "@polkadot-api/descriptors"
 * \`\`\`
 * 
 * @see [papi.how](https://papi.how/) for generic documentation on \`polkadot-api\`
 * 
 * @packageDocumentation
 */

${hasSection.storage ? `/**
 * Storage queries reference
 * 
 * Each item described here is a
 *\`StorageDescriptor<Args, ReturnType, Optional, Opaque>\`  
 * For example, \`System.Account\` is of type
 * \`\`\`ts
 * Account: StorageDescriptor<[Key: SS58String], {
 *     consumers: number;
 *     data: {
 *         flags: bigint;
 *         free: bigint;
 *         frozen: bigint;
 *         reserved: bigint;
 *     };
 *     nonce: number;
 *     providers: number;
 *     sufficients: number;
 * }, false, "never">
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const account = await api.query.System.Account.getValue("<AccountId>")
 * console.log(account.data.free)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/queries) on storage queries for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Storage from "./Storage";

` : ""}
${hasSection.constants ? `/**
 * Constants reference
 * 
 * Each item described here is a \`PlainDescriptor<T>\`  
 * 
 * For example, \`System.Version\` is of type
 * \`\`\`ts
 * Version: PlainDescriptor<{
 *     apis: [FixedSizeBinary<8>, number][];
 *     authoring_version: number;
 *     impl_name: string;
 *     impl_version: number;
 *     spec_name: string;
 *     spec_version: number;
 *     state_version: number;
 *     transaction_version: number;
 * }>
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const version = await typedApi.constants.System.Version()
 * console.log(version.spec_version)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/constants) on constants for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Constants from "./Constants";

` : ""}
${hasSection.errors ? `/**
 * Errors
 * 
 * This section is temporarily commented out, 
 * as errors aren't documented in papi yet
 * https://github.com/polkadot-api/polkadot-api-docs/issues/25 
 * 
 * @namespace
 * @category Types
 */
// export * as Errors from "./Errors";

` : ""}
${hasSection.calls ? `/**
 * Transactions reference
 * 
 * Each item described here is a \`TxDescriptor<T>\`, where \`T\` describes
 * all the arguments required by the extrinsic
 * 
 * For example, \`Balances.transfer_keep_alive\` is of type
 * \`\`\`ts
 * transfer_keep_alive: TxDescriptor<{
 *     dest: MultiAddress;
 *     value: bigint;
 * }>
 * \`\`\`
 * and can be used like this
 * \`\`\`ts
 * const tx = api.tx.Balances.transfer_keep_alive({
 *   dest: MultiAddress.Id(userAddress),
 *   value: 10n ** 10n, // 1 DOT
 * })
 * await tx.signAndSubmit(signer)
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/tx) on transactions for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Transactions from "./Transactions";

` : ""}
${hasSection.events ? `/**
 * Events
 * 
 * Each item described here is a \`PlainDescriptor<T>\`  
 * 
 * For example, \`System.NewAccount\` is of type
 * \`\`\`ts
 * NewAccount: PlainDescriptor<{ "account": SS58String }>;
 * \`\`\`
 * and can be queried via
 * \`\`\`ts
 * const newAccountEvents = await api.event.System.NewAccount.pull()
 * newAccountEvents.forEach(newAccount => {
 *  const address: SS58String = newAccount.payload.account
 *  console.log(address)
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/events) on events for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as Events from "./Events";

` : ""}
${hasSection.viewFns ? `/**
 * View Functions
 * 
 * Each item described here is a \`RuntimeDescriptor<Args, ReturnType>\`
 * 
 * For example, \`Proxy.is_superset\` is of type
 * \`\`\`ts
 * is_superset: RuntimeDescriptor<[to_check: ProxyType, against: ProxyType], boolean>
 * \`\`\`
 * and can be called like this:
 * \`\`\`ts
 *  const isSuperset = await api.view.Proxy.is_superset(Enum("Any"), Enum("NonTransfer"))
 *  console.log(isSuperset)
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/view) on view functions for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as ViewFunctions from "./ViewFunctions";

` : ""}
${hasSection.runtimeCalls ? `/**
 * Runtime calls
 * 
 * Each item described here is a \`RuntimeDescriptor<Args, ReturnType>\`
 * 
 * For example, \`Metadata.metadata_at_version\` is of type
 * \`\`\`ts
 * metadata_at_version: RuntimeDescriptor<[version: number], Binary | undefined>
 * \`\`\`
 * and can be called like this:
 * \`\`\`ts
 *  const metadata = await api.apis.Metadata.metadata_at_version(15)
 *  console.log(metadata?.asHex())
 * })
 * \`\`\`
 * 
 * @see [PAPI docs](https://papi.how/typed/apis) on runtime APIs for more
 * 
 * @namespace
 * @category TypedApi calls
 */
export * as RuntimeCalls from "./RuntimeCalls";

` : ""}
/**
 * Descriptors types
 * 
 * These are the types used in API calls and imported out of descriptors  
 * 
 * For example, \`XcmVersionedLocation\` is an enum:
 * \`\`\`ts
 * XcmVersionedLocation: Enum<{
 *     V2: { ... };
 *     V3: {
 *         interior: XcmV3Junctions;
 *         parents: number;
 *     };
 *     V4: { ... };
 * }>
 * \`\`\`
 * and can be used like this
 * \`\`\`ts
 * import { XcmVersionedLocation, XcmV3Junctions } from "@polkadot-api/descriptors"
 * await typedApi.tx.XcmPallet.limited_teleport_assets({
      dest: XcmVersionedLocation.V3({
        parents: 0,
        interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(parachain_id)),
      }),
 * \`\`\`
 * 
 * @namespace
 * @category Types
 */
export * as Types from "./types";`;
}

function getReusedNodes(start, exclude) {
  const reused = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  let heads = [...start];
  while (heads.length) {
    const head = heads.pop();
    if ("id" in head) {
      if (visited.has(head.id)) {
        reused.add(head.id);
        continue;
      }
      visited.add(head.id);
      if (exclude.has(head.id)) {
        continue;
      }
    }
    heads = [...heads, ...getEdges(head)];
  }
  return reused;
}
const unique = (arr) => [...new Set(arr)];
function getEdges(node) {
  const lookupEdge = (node2) => "id" in node2 ? [node2] : getEdges(node2);
  if (isPrimitive(node)) return [];
  switch (node.type) {
    case "array":
      return lookupEdge(node.value.value);
    case "enum":
      return unique(
        node.value.flatMap((v) => v.value ? lookupEdge(v.value) : [])
      );
    case "option":
      return lookupEdge(node.value);
    case "result":
      return [node.value.ok, node.value.ko];
    case "struct":
    case "tuple":
      return unique(node.value.flatMap((v) => lookupEdge(v.value)));
    case "union":
      return unique(node.value.flatMap(lookupEdge));
  }
}

function generateInkTypes(lookup) {
  const internalBuilder = getInternalTypesBuilder(lookup);
  const buildCallable = (callable) => {
    const call = {
      type: "struct",
      value: callable.args.map((param) => ({
        label: param.label,
        value: internalBuilder(param.type.type),
        docs: []
      }))
    };
    return {
      call,
      value: internalBuilder(callable.returnType.type)
    };
  };
  const constructors = lookup.metadata.spec.constructors.map((ct) => ({
    ...ct,
    types: buildCallable(ct)
  }));
  const messages = lookup.metadata.spec.messages.map((ct) => ({
    ...ct,
    types: buildCallable(ct)
  }));
  const event = {
    type: "enum",
    value: lookup.metadata.spec.events.map(
      (evt) => ({
        label: evt.label,
        value: {
          type: "struct",
          value: evt.args.map(
            (arg) => ({
              label: arg.label,
              value: internalBuilder(arg.type.type),
              docs: arg.docs
            })
          )
        },
        docs: evt.docs
      })
    )
  };
  const storageRoots = Object.entries(lookup.storage).map(([name, value]) => ({
    name,
    key: value.key !== null ? internalBuilder(value.key) : null,
    value: internalBuilder(value.typeId)
  }));
  const storageRoot = {
    type: "struct",
    value: storageRoots.map(({ name, key, value }) => ({
      docs: [],
      label: name,
      value: {
        type: "struct",
        value: [
          {
            docs: [],
            label: "key",
            value: key ?? { type: "primitive", value: "undefined" }
          },
          {
            docs: [],
            label: "value",
            value
          }
        ]
      }
    }))
  };
  const entryPoints = [
    storageRoot,
    ...constructors.flatMap((v) => [v.types.call, v.types.value]),
    ...messages.flatMap((v) => [v.types.call, v.types.value])
  ];
  const rootNodes = getReusedNodes(entryPoints, /* @__PURE__ */ new Set());
  const assignedNames = {};
  let nextAnonymousId = 0;
  const getName = (id) => {
    if (!assignedNames[id]) {
      assignedNames[id] = `T${nextAnonymousId++}`;
    }
    return assignedNames[id];
  };
  const filteredRootNodes = Array.from(rootNodes).filter(
    (id) => !isPrimitive(internalBuilder(id))
  );
  const types = {};
  const generateNodeType = (node) => {
    const anonymize = (name) => `Anonymize<${name}>`;
    const result2 = generateTypescript(node, (node2, next) => {
      if (!("id" in node2) || isPrimitive(node2)) {
        return processPapiPrimitives(node2, next, true) ?? nativeNodeCodegen(node2, next);
      }
      if (types[node2.id]) {
        const cached = types[node2.id];
        return cached.name ? {
          code: anonymize(cached.name),
          imports: {
            types: /* @__PURE__ */ new Set([cached.name])
          }
        } : cached;
      }
      const assignedName = assignedNames[node2.id] ?? (filteredRootNodes.includes(node2.id) ? getName(node2.id) : null);
      if (assignedName) {
        types[node2.id] = {
          code: "",
          imports: {},
          name: assignedName
        };
      }
      const result3 = processPapiPrimitives(node2, next, true) ?? nativeNodeCodegen(node2, next);
      if (assignedName) {
        types[node2.id].code = result3.code;
        types[node2.id].imports = result3.imports;
        return {
          code: anonymize(assignedName),
          imports: {
            types: /* @__PURE__ */ new Set([assignedName])
          }
        };
      }
      types[node2.id] = result3;
      return types[node2.id];
    });
    if ("id" in node && types[node.id]?.name) {
      const name = types[node.id].name;
      return {
        code: anonymize(name),
        imports: {
          types: /* @__PURE__ */ new Set([name])
        }
      };
    }
    return result2;
  };
  const inlineField = (label, type) => ({
    label,
    value: {
      type: "inline",
      value: type
    },
    docs: []
  });
  const createCallableDescriptor = (callables) => generateNodeType({
    type: "struct",
    value: callables.map(
      (callable) => ({
        label: callable.label,
        value: {
          type: "struct",
          value: [
            {
              label: "message",
              value: callable.types.call,
              docs: []
            },
            {
              label: "response",
              value: callable.types.value,
              docs: []
            },
            ...callable.default ? [inlineField("default", "true")] : [],
            ...callable.payable ? [inlineField("payable", "true")] : [],
            ...callable.mutates ? [inlineField("mutates", "true")] : []
          ]
        },
        docs: callable.docs
      })
    )
  });
  const constructorsDescriptor = createCallableDescriptor(constructors);
  const messagesDescriptor = createCallableDescriptor(messages);
  const eventDescriptor = generateNodeType(event);
  const storageTypes = generateNodeType(storageRoot);
  const namedTypes = Object.entries(assignedNames).filter(([id]) => types[Number(id)]).map(([id, value]) => `type ${value} = ${types[Number(id)].code};`).join("\n");
  const clientImports = Array.from(
    mergeImports([
      storageTypes.imports,
      messagesDescriptor.imports,
      constructorsDescriptor.imports,
      eventDescriptor.imports,
      ...Object.values(types).map((v) => v.imports),
      {
        client: new Set(anonymizeImports)
      }
    ]).client
  );
  const result = `
    import type { ${clientImports.join(", ")} } from 'polkadot-api';
    import type { InkDescriptors } from 'polkadot-api/ink';

    ${anonymizeType}

    ${namedTypes}

    type StorageDescriptor = ${storageTypes.code};
    type MessagesDescriptor = ${messagesDescriptor.code};
    type ConstructorsDescriptor = ${constructorsDescriptor.code};
    type EventDescriptor = ${eventDescriptor.code};

    export const descriptor: InkDescriptors<StorageDescriptor, MessagesDescriptor, ConstructorsDescriptor, EventDescriptor> = { metadata: ${JSON.stringify(lookup.metadata)} } as any;
  `;
  return result;
}

const intRegex = /^u?int(\d+)$/;
const fixedRegex = /^u?fixed\d+x(\d+)$/;
function generatePrimitiveType(primitive) {
  switch (primitive) {
    case "uint":
    case "int":
      return "bigint";
    case "address":
      return "Address";
    case "bool":
      return "boolean";
    case "fixed":
    case "ufixed":
      return "Decimal<18>";
    case "function":
      return "FunctionRef";
    case "bytes":
      return "Binary";
    case "string":
      return "string";
  }
  if (primitive.startsWith("bytes")) {
    return "Binary";
  }
  const intMatch = intRegex.exec(primitive);
  if (intMatch) {
    return Number(intMatch[1]) > 53 ? "bigint" : "number";
  }
  const fixedMatch = fixedRegex.exec(primitive);
  if (fixedMatch) {
    return `Decimal<${fixedMatch[1]}>`;
  }
  throw new Error("Can't map " + primitive);
}
const arrayRegex = /^(.+)\[(\d+)\]$/;
function generateVariableType(variable) {
  if (variable.type === "tuple") {
    return generateStructType(variable.components);
  }
  if (variable.type.endsWith("[]")) {
    return `Array<${generateVariableType({
      ...variable,
      type: variable.type.replace("[]", "")
    })}>`;
  }
  const arrayMatch = arrayRegex.exec(variable.type);
  if (arrayMatch) {
    return `Array<${generatePrimitiveType(arrayMatch[1])}>`;
  }
  return generatePrimitiveType(variable.type);
}
function generateStructType(params) {
  if (!params || !params.length) return `{}`;
  const unnamedTypes = params.filter((v) => !v.name);
  const namedTypes = params.filter((v) => !!v.name);
  if (namedTypes.length == 0) {
    if (unnamedTypes.length === 1) {
      return generateVariableType(unnamedTypes[0]);
    }
    return "[" + unnamedTypes.map(generateVariableType).join(", ") + "]";
  }
  if (unnamedTypes.length) {
    namedTypes.push({
      name: "args",
      type: "tuple",
      components: unnamedTypes
    });
  }
  return `{${namedTypes.map((v) => `"${v.name}": ${generateVariableType(v)}`).join(",\n")}}`;
}
function generateFunctionType(fnAbi) {
  if (!fnAbi.name) {
    console.log(fnAbi);
    throw new Error("Function needs a name");
  }
  return `"${fnAbi.name}": { message: ${generateStructType(fnAbi.inputs)}, response: ${generateStructType(fnAbi.outputs)} }`;
}
function generateSolTypes(abi) {
  const messages = abi.filter((v) => v.type === "function");
  const receive = abi.find((v) => v.type === "receive");
  if (receive) {
    messages.push({
      name: "receive",
      ...receive,
      type: "function"
    });
  }
  const fallback = abi.find((v) => v.type === "fallback");
  if (fallback) {
    messages.push({
      name: "fallback",
      ...fallback,
      type: "function"
    });
  }
  const messagesDescriptor = `{ ${messages.map(generateFunctionType).join(",\n")} }`;
  const constructor = abi.find((v) => v.type === "constructor") ?? {
    type: "constructor",
    stateMutability: "pure"
  };
  const constructorsDescriptor = `{ ${generateFunctionType({
    name: "new",
    ...constructor
  })} }`;
  const events = abi.filter((v) => v.type === "event");
  const eventsDescriptor = `Enum<{
    ${events.map((evt) => `"${evt.name}": ${generateStructType(evt.inputs)}`).join(",\n")}
  }>`;
  const result = `
    import type { InkDescriptors } from 'polkadot-api/ink';
    import type { HexString, Enum, Binary } from 'polkadot-api';

    type Address = HexString
    type Decimal<T extends number> = { value: bigint, decimals: T }
    type FunctionRef = { address: Address, selector: HexString }

    type StorageDescriptor = {};
    type MessagesDescriptor = ${messagesDescriptor};
    type ConstructorsDescriptor = ${constructorsDescriptor};
    type EventDescriptor = ${eventsDescriptor};

    export const descriptor: InkDescriptors<StorageDescriptor, MessagesDescriptor, ConstructorsDescriptor, EventDescriptor> = { abi: ${JSON.stringify(abi)} } as any;
  `;
  return result;
}

exports.capitalize = capitalize;
exports.customStringifyObject = customStringifyObject;
exports.defaultDeclarations = defaultDeclarations;
exports.generateDescriptors = generateDescriptors;
exports.generateDocsDescriptors = generateDocsDescriptors;
exports.generateInkTypes = generateInkTypes;
exports.generateMultipleDescriptors = generateMultipleDescriptors;
exports.generateSolTypes = generateSolTypes;
exports.getAssetId = getAssetId;
exports.getDispatchErrorId = getDispatchErrorId;
exports.getDocsTypesBuilder = getDocsTypesBuilder;
exports.getNewTypes = getNewTypes;
exports.getTypesBuilder = getTypesBuilder;
exports.knownTypes = knownTypes;
exports.knownTypesRepository = knownTypesRepository;
//# sourceMappingURL=index.js.map
