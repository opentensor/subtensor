{"version":3,"file":"sdk-types.mjs","sources":["../../../src/sdk-types.ts"],"sourcesContent":["import {\n  AsyncTransaction,\n  FlattenErrors,\n  FlattenValues,\n  SdkDefinition,\n} from \"@polkadot-api/common-sdk-utils\"\nimport {\n  type GenericEvent,\n  type InkStorageDescriptor,\n} from \"@polkadot-api/ink-contracts\"\nimport {\n  Binary,\n  FixedSizeBinary,\n  HexString,\n  type ResultPayload,\n  type SS58String,\n  type TypedApi,\n} from \"polkadot-api\"\nimport type { Passet, WndAh } from \"../.papi/descriptors\"\nimport type {\n  Gas,\n  GenericInkDescriptors,\n  InkSdkApis,\n  InkSdkPallets,\n  InkSdkTypedApi,\n  ReviveSdkApis,\n  ReviveSdkPallets,\n  ReviveSdkTypedApi,\n  ReviveStorageError,\n} from \"./descriptor-types\"\nimport type { SdkStorage } from \"./get-storage\"\n\nexport type CommonTypedApi = TypedApi<Passet> | TypedApi<WndAh>\n\nexport type ReadDeployerEvents<D extends GenericInkDescriptors, Addr> = (\n  events?: Array<\n    GenericEvent & {\n      topics: FixedSizeBinary<number>[]\n    }\n  >,\n) => Array<{\n  address: Addr\n  contractEvents: Array<D[\"__types\"][\"event\"]>\n}>\n\nexport interface InkV5Sdk<\n  T extends InkSdkTypedApi | ReviveSdkTypedApi,\n  D extends GenericInkDescriptors,\n  Addr,\n  StorageErr,\n> {\n  getContract(adddress: Addr): Contract<T, D, Addr, StorageErr>\n  getDeployer(code: Binary): Deployer<T, D, Addr>\n  readDeploymentEvents: ReadDeployerEvents<D, Addr>\n}\n\n/**\n * @deprecated Old interface, will be removed in a future version\n */\nexport interface ReviveSdk<\n  T extends ReviveSdkTypedApi,\n  D extends GenericInkDescriptors,\n  Addr,\n  StorageErr,\n> extends InkV5Sdk<T, D, Addr, StorageErr> {\n  addressIsMapped: (address: SS58String) => Promise<boolean>\n}\n\nexport type ContractSdk<D extends GenericInkDescriptors> = Contract<\n  CommonTypedApi,\n  D,\n  HexString,\n  ReviveStorageError\n>\nexport type DeployerSdk<D extends GenericInkDescriptors> = Deployer<\n  CommonTypedApi,\n  D,\n  HexString\n>\nexport interface InkSdk {\n  addressIsMapped: (address: SS58String) => Promise<boolean>\n  getContract: GetContract\n  getDeployer: <D extends GenericInkDescriptors>(\n    contractDescriptors: D,\n    code: Binary,\n  ) => DeployerSdk<D>\n  readDeploymentEvents: <D extends GenericInkDescriptors>(\n    contractDescriptors: D,\n    events?: Array<\n      GenericEvent & {\n        topics: FixedSizeBinary<number>[]\n      }\n    >,\n  ) => Array<{\n    address: HexString\n    contractEvents: Array<D[\"__types\"][\"event\"]>\n  }>\n}\n\nexport interface GetContract {\n  <D extends GenericInkDescriptors>(\n    contractDescriptors: D,\n  ): (address: HexString) => ContractSdk<D>\n  <D extends GenericInkDescriptors>(\n    contractDescriptors: D,\n    address: HexString,\n  ): ContractSdk<D>\n}\n\nexport interface InkSdkOptions {\n  /**\n   * Target the latest block instead of the finalized block for any query or dry-run operation.\n   *\n   * This makes it possible to have quicker updates, but be mindful that the data returned might become\n   * invalid at any point, e.g. a contract that apparently was successfully deployed might suddenly\n   * disappear, just to reappear a few seconds later, or maybe never? Be really mindful\n   * you can get inconsistencies.\n   */\n  atBest: boolean\n}\nexport const defaultOptions: InkSdkOptions = {\n  atBest: false,\n}\n\ntype DryRunDeployFn<\n  T extends InkSdkTypedApi | ReviveSdkTypedApi,\n  Addr,\n  D extends GenericInkDescriptors,\n> = <L extends string & keyof D[\"__types\"][\"constructors\"]>(\n  constructor: L,\n  args: DryRunDeployArgs<D[\"__types\"][\"constructors\"][L][\"message\"]>,\n) => Promise<\n  ResultPayload<\n    {\n      address: Addr\n      response: FlattenValues<D[\"__types\"][\"messages\"][L][\"response\"]>\n      events: D[\"__types\"][\"event\"][]\n      gasRequired: Gas\n      storageDeposit: bigint\n      deploy: () => AsyncTransaction<any, any, any, any>\n    },\n    GetErr<T> | FlattenErrors<D[\"__types\"][\"messages\"][L][\"response\"]>\n  >\n>\n\ntype DeployFn<D extends GenericInkDescriptors> = <\n  L extends string & keyof D[\"__types\"][\"constructors\"],\n>(\n  constructor: L,\n  args: DeployArgs<D[\"__types\"][\"constructors\"][L][\"message\"]>,\n) => AsyncTransaction<any, any, any, any>\n\ntype EstimateAddrFn<D extends GenericInkDescriptors, Addr> = <\n  L extends string & keyof D[\"__types\"][\"constructors\"],\n>(\n  constructor: L,\n  args: Data<D[\"__types\"][\"constructors\"][L][\"message\"]> & {\n    origin: SS58String\n    value?: bigint\n    nonce?: number\n    salt?: FixedSizeBinary<32>\n  },\n) => Promise<Addr | null>\n\nexport interface Deployer<\n  T extends InkSdkTypedApi | ReviveSdkTypedApi,\n  D extends GenericInkDescriptors,\n  Addr,\n> {\n  dryRun: DryRunDeployFn<T, Addr, D>\n  deploy: DeployFn<D>\n  estimateAddress: EstimateAddrFn<D, Addr>\n}\n\ntype GetErr<T> =\n  T extends TypedApi<SdkDefinition<InkSdkPallets, InkSdkApis<any, infer R>>>\n    ? R\n    : T extends TypedApi<\n          SdkDefinition<ReviveSdkPallets<any>, ReviveSdkApis<any, infer R>>\n        >\n      ? R\n      : any\n\nexport type StorageRootType<T extends InkStorageDescriptor> = \"\" extends keyof T\n  ? T[\"\"][\"value\"]\n  : never\n\nexport interface Contract<\n  T extends InkSdkTypedApi | ReviveSdkTypedApi,\n  D extends GenericInkDescriptors,\n  Addr,\n  StorageErr,\n> {\n  accountId: SS58String\n  getBalance(): Promise<bigint>\n  isCompatible(): Promise<boolean>\n  getStorage(): SdkStorage<D[\"__types\"][\"storage\"], StorageErr>\n  query: <L extends string & keyof D[\"__types\"][\"messages\"]>(\n    message: L,\n    args: QueryArgs<D[\"__types\"][\"messages\"][L][\"message\"]>,\n  ) => Promise<\n    ResultPayload<\n      {\n        response: FlattenValues<D[\"__types\"][\"messages\"][L][\"response\"]>\n        events: D[\"__types\"][\"event\"][]\n        gasRequired: Gas\n        storageDeposit: bigint\n        send: () => AsyncTransaction<any, any, any, any>\n      },\n      | GetErr<T>\n      | FlattenErrors<D[\"__types\"][\"messages\"][L][\"response\"]>\n      | {\n          type: \"FlagReverted\"\n          value: {\n            message: string\n            raw: Binary\n            gasRequired: Gas\n            storageDeposit: bigint\n            send: () => AsyncTransaction<any, any, any, any>\n          }\n        }\n    >\n  >\n  send: <L extends string & keyof D[\"__types\"][\"messages\"]>(\n    message: L,\n    args: SendArgs<D[\"__types\"][\"messages\"][L][\"message\"]>,\n  ) => AsyncTransaction<any, any, any, any>\n  dryRunRedeploy: DryRunDeployFn<T, Addr, D>\n  redeploy: DeployFn<D>\n  filterEvents: (\n    events?: Array<\n      | {\n          event: GenericEvent\n          topics: Binary[]\n        }\n      | (GenericEvent & {\n          topics: Binary[]\n        })\n    >,\n  ) => Array<D[\"__types\"][\"event\"]>\n}\n\ntype QueryOptions = Partial<{\n  gasLimit: Gas\n  storageDepositLimit: bigint\n}>\ntype Data<D> = {} extends D\n  ? {\n      data?: D\n    }\n  : {\n      data: D\n    }\n\ntype QueryArgs<D> = Data<D> & {\n  options?: QueryOptions\n  value?: bigint\n  origin: SS58String\n}\n\ntype GasInput =\n  | {\n      origin: SS58String\n    }\n  | {\n      gasLimit: Gas\n      storageDepositLimit: bigint\n    }\n\ntype SendArgs<D> = Data<D> & {\n  value?: bigint\n} & GasInput\n\ntype DeployOptions = Partial<{\n  gasLimit: Gas\n  storageDepositLimit: bigint\n  salt: FixedSizeBinary<32>\n}>\ntype DryRunDeployArgs<D> = Data<D> & {\n  options?: DeployOptions\n  value?: bigint\n  origin: SS58String\n}\ntype DeployArgs<D> = Data<D> & {\n  options?: Omit<DeployOptions, \"gasLimit\" | \"storageDepositLimit\">\n  value?: bigint\n} & GasInput\n"],"names":[],"mappings":"AAwHO,MAAM,cAAA,GAAgC;AAAA,EAC3C,MAAA,EAAQ;AACV;;;;"}