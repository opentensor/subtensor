import { wrapAsyncTx, mapResult, flattenResult } from '@polkadot-api/common-sdk-utils';
import { Enum } from 'polkadot-api';
import { getDeployer } from './get-deployer.mjs';
import { getStorage } from './get-storage.mjs';
import { getStorageLimit, getSignedStorage } from './util.mjs';

function getContract(provider, encodingProvider, address, mapAddr, accountId) {
  const codeHash = provider.getCodeHash(address).then((r) => {
    if (!r) {
      throw new Error(`Contract ${mapAddr(address)} not found`);
    }
    return r;
  });
  const deployer = getDeployer(
    provider,
    encodingProvider,
    Enum("Existing", codeHash),
    mapAddr
  );
  const contractApi = {
    accountId,
    getBalance: () => provider.getBalance(address),
    async isCompatible() {
      try {
        const code_hash = await codeHash;
        return code_hash ? encodingProvider.isCompatible(code_hash) : false;
      } catch (ex) {
        console.error(ex);
        return false;
      }
    },
    getStorage: () => getStorage(provider, encodingProvider, address),
    async query(message, args) {
      const msg = encodingProvider.message(message);
      const data = msg.encode(args.data ?? {});
      const value = args.value ?? 0n;
      const response = await provider.dryRunCall(
        args.origin,
        address,
        value,
        args.options?.gasLimit,
        args.options?.storageDepositLimit,
        data
      );
      if (response.result.success) {
        const availableData = {
          events: encodingProvider.filterEvents(
            mapAddr(address),
            response.events
          ),
          gasRequired: response.gas_required,
          storageDeposit: getSignedStorage(response.storage_deposit),
          send: () => {
            const limitParams = {
              gasLimit: response.gas_required,
              storageDepositLimit: getStorageLimit(response.storage_deposit)
            };
            return contractApi.send(message, {
              ...args,
              ...limitParams
            });
          }
        };
        if (response.result.value.flags & 1) {
          const data2 = response.result.value.data;
          return {
            success: false,
            value: {
              type: "FlagReverted",
              value: {
                ...availableData,
                message: encodingProvider.decodeError(data2),
                raw: response.result.value.data
              }
            }
          };
        }
        const decoded = msg.decode(
          response.result.value.data
        );
        return mapResult(flattenResult(decoded), {
          value: (innerResponse) => ({
            response: innerResponse,
            ...availableData
          })
        });
      }
      return {
        success: false,
        value: response.result.value
      };
    },
    send: (message, args) => wrapAsyncTx(async () => {
      const data = encodingProvider.message(message).encode(args.data ?? {});
      const limits = await (async () => {
        if ("gasLimit" in args)
          return {
            gas: args.gasLimit,
            storage: args.storageDepositLimit
          };
        const response = await provider.dryRunCall(
          args.origin,
          address,
          args.value ?? 0n,
          void 0,
          void 0,
          data
        );
        return {
          gas: response.gas_required,
          storage: getStorageLimit(response.storage_deposit)
        };
      })();
      return provider.txCall({
        dest: address,
        value: args.value ?? 0n,
        gas_limit: limits.gas,
        storage_deposit_limit: limits.storage,
        data
      });
    }),
    dryRunRedeploy: deployer.dryRun,
    redeploy: deployer.deploy,
    filterEvents(events) {
      return encodingProvider.filterEvents(mapAddr(address), events);
    }
  };
  return contractApi;
}

export { getContract };
//# sourceMappingURL=get-contract.mjs.map
