import { wrapAsyncTx, mapResult, flattenResult } from '@polkadot-api/common-sdk-utils';
import { Enum } from 'polkadot-api';
import { getStorageLimit, getSignedStorage } from './util.mjs';

function getDeployer(provider, encodingProvider, code, mapAddr) {
  const loadedCode = async () => code.type === "Upload" ? code : {
    type: "Existing",
    value: await code.value
  };
  const deployer = {
    async dryRun(constructorLabel, args) {
      const ctor = encodingProvider.constructor(constructorLabel);
      const value = args.value ?? 0n;
      const data = ctor.encode(args.data ?? {});
      const response = await provider.dryRunInstantiate(
        args.origin,
        value,
        args.options?.gasLimit,
        args.options?.storageDepositLimit,
        code.type === "Existing" ? Enum("Existing", await code.value) : code,
        data,
        args.options?.salt
      );
      if (response.result.success) {
        const decoded = ctor.decode(
          response.result.value.result.data
        );
        const address = response.result.value.addr;
        return mapResult(flattenResult(decoded), {
          value: (value2) => ({
            address: mapAddr(address),
            response: value2,
            events: encodingProvider.filterEvents(
              mapAddr(address),
              response.events
            ),
            gasRequired: response.gas_required,
            storageDeposit: getSignedStorage(response.storage_deposit),
            deploy() {
              const limitParams = {
                gasLimit: response.gas_required,
                storageDepositLimit: getStorageLimit(response.storage_deposit)
              };
              return deployer.deploy(constructorLabel, {
                ...args,
                ...limitParams
              });
            }
          })
        });
      }
      return {
        success: false,
        value: response.result.value
      };
    },
    deploy: (constructorLabel, args) => wrapAsyncTx(async () => {
      const ctor = encodingProvider.constructor(constructorLabel);
      const limits = await (async () => {
        if ("gasLimit" in args)
          return {
            gas: args.gasLimit,
            storage: args.storageDepositLimit
          };
        const response = await provider.dryRunInstantiate(
          args.origin,
          args.value ?? 0n,
          void 0,
          void 0,
          code.type === "Existing" ? Enum("Existing", await code.value) : code,
          ctor.encode(args.data ?? {}),
          args.options?.salt
        );
        return {
          gas: response.gas_required,
          storage: getStorageLimit(response.storage_deposit)
        };
      })();
      const params = {
        value: args.value ?? 0n,
        gas_limit: limits.gas,
        storage_deposit_limit: limits.storage,
        data: ctor.encode(args.data ?? {}),
        salt: args.options?.salt
      };
      return code.type === "Upload" ? provider.txInstantiateWithCode({
        ...params,
        code: code.value
      }) : provider.txInstantiate({
        ...params,
        code_hash: await code.value
      });
    }),
    estimateAddress: async (constructorLabel, args) => {
      const ctor = encodingProvider.constructor(constructorLabel);
      const data = ctor.encode(args.data ?? {});
      const addr = await provider.getEstimatedAddress(
        args.origin,
        args.value ?? 0n,
        await loadedCode(),
        data,
        args.salt,
        args.nonce
      );
      return addr ? mapAddr(addr) : null;
    }
  };
  return deployer;
}

export { getDeployer };
//# sourceMappingURL=get-deployer.mjs.map
