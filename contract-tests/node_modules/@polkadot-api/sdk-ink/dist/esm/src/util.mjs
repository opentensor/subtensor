import { RLP } from '@ethereumjs/rlp';
import { Keccak256 } from '@polkadot-api/substrate-bindings';
import { Binary, AccountId } from 'polkadot-api';
import { mergeUint8 } from 'polkadot-api/utils';

const getSignedStorage = (depositResponse) => depositResponse.type === "Charge" ? depositResponse.value : -depositResponse.value;
const getStorageLimit = (depositResponse) => depositResponse.type === "Charge" ? depositResponse.value : 0n;
const ss58ToEthereum = (address) => Binary.fromBytes(Keccak256(AccountId().enc(address)).slice(12));
const reviveAddressIsMapped = (typedApi, address) => typedApi.query.Revive.OriginalAccount.getValue(ss58ToEthereum(address)).then(
  (r) => r != null
);
const u64Range = 2n ** 64n;
const valueToU256 = (value, nativeToEth) => {
  const scaled = value * BigInt(nativeToEth);
  return [
    scaled % u64Range,
    scaled / u64Range % u64Range,
    scaled / u64Range ** 2n % u64Range,
    scaled / u64Range ** 3n % u64Range
  ];
};
const u256ToValue = (u256, nativeToEth) => {
  const scaled = u256.reduce(
    (acc, value, i) => acc + value * u64Range ** BigInt(i),
    0n
  );
  return scaled / BigInt(nativeToEth);
};
const parseReviveAddress = (address) => typeof address === "string" ? address.startsWith("0x") ? Binary.fromHex(address) : ss58ToEthereum(address) : address;
const getDeploymentAddressWithNonce = (deployer, nonce) => {
  const addr = parseReviveAddress(deployer);
  const data = RLP.encode([addr.asBytes(), nonce]);
  const bytes = Keccak256(data).slice(12);
  return Binary.fromBytes(bytes);
};
const getDeploymentAddressWithSalt = (deployer, deploymentHash, salt) => {
  const addr = parseReviveAddress(deployer);
  const saltBin = typeof salt === "string" ? Binary.fromHex(salt) : salt;
  const bytes = Keccak256(
    mergeUint8([
      new Uint8Array([255]),
      addr.asBytes(),
      saltBin.asBytes(),
      Binary.fromHex(deploymentHash).asBytes()
    ])
  ).slice(12);
  return Binary.fromBytes(bytes);
};
const getDeploymentHash = (code, inputData) => Binary.fromBytes(
  Keccak256(mergeUint8(code.asBytes(), inputData.asBytes()))
).asHex();

export { getDeploymentAddressWithNonce, getDeploymentAddressWithSalt, getDeploymentHash, getSignedStorage, getStorageLimit, reviveAddressIsMapped, ss58ToEthereum, u256ToValue, valueToU256 };
//# sourceMappingURL=util.mjs.map
