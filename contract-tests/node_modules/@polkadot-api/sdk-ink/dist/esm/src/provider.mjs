import { mapResult } from '@polkadot-api/common-sdk-utils';
import { Binary, CompatibilityLevel, Enum } from 'polkadot-api';
import { mergeUint8 } from 'polkadot-api/utils';
import { getDeploymentAddressWithSalt, getDeploymentHash, getDeploymentAddressWithNonce, valueToU256, ss58ToEthereum, u256ToValue } from './util.mjs';

const defaultSalt = Binary.fromText("");
const contractsProvider = (typedApi, atBest) => {
  const callOptions = atBest ? { at: "best" } : {};
  const dryRunInstantiate = async (origin, value, gas_limit, storage_deposit_limit, code, data, salt) => {
    const response = await typedApi.apis.ContractsApi.instantiate(
      origin,
      value,
      gas_limit,
      storage_deposit_limit,
      code,
      data,
      salt ?? defaultSalt,
      callOptions
    );
    const result = response.result;
    return {
      ...response,
      result: mapResult(result, {
        value: ({ account_id, result: result2 }) => ({
          result: result2,
          addr: account_id
        })
      })
    };
  };
  return {
    async getBalance(addr) {
      const account = await typedApi.query.System.Account.getValue(addr);
      return account.data.free;
    },
    dryRunCall: (...args) => typedApi.apis.ContractsApi.call(...args, callOptions),
    dryRunInstantiate,
    getEstimatedAddress: async (origin, value, code, data, salt) => {
      const result = await dryRunInstantiate(
        origin,
        value,
        void 0,
        void 0,
        code,
        data,
        salt
      );
      return result.result.success ? result.result.value.addr : null;
    },
    getStorage: (...args) => typedApi.apis.ContractsApi.get_storage(...args, callOptions),
    getCodeHash: (addr) => typedApi.query.Contracts.ContractInfoOf.getValue(addr, callOptions).then(
      (r) => r?.code_hash
    ),
    txCall: ({ data, dest, gas_limit, value, storage_deposit_limit }) => typedApi.tx.Contracts.call({
      data,
      dest: {
        type: "Id",
        value: dest
      },
      gas_limit,
      storage_deposit_limit,
      value
    }),
    txInstantiate: (payload) => typedApi.tx.Contracts.instantiate({
      storage_deposit_limit: void 0,
      ...payload,
      salt: payload.salt ?? defaultSalt
    }),
    txInstantiateWithCode: (payload) => typedApi.tx.Contracts.instantiate_with_code({
      storage_deposit_limit: void 0,
      ...payload,
      salt: payload.salt ?? defaultSalt
    })
  };
};
const logToEvent = ({
  address,
  topics,
  data
}) => ({
  topics,
  event: {
    type: "Revive",
    value: {
      type: "ContractEmitted",
      value: {
        contract: address,
        data
      }
    }
  }
});
const getEventsFromTrace = (trace) => [
  ...trace.logs.map(logToEvent),
  ...trace.calls.flatMap(getEventsFromTrace)
];
const reviveProvider = (typedApi, atBest) => {
  const callOptions = atBest ? { at: "best" } : {};
  const traceCall = ({
    from,
    to,
    input,
    value
  }) => typedApi.apis.ReviveApi.trace_call(
    {
      authorization_list: [],
      blob_versioned_hashes: [],
      blobs: [],
      from,
      input,
      to,
      value
    },
    Enum("CallTracer", {
      only_top_call: false,
      with_logs: true
    }),
    callOptions
  ).catch((ex) => {
    console.error(ex);
    return {
      success: false
    };
  });
  return {
    async getBalance(addr) {
      const ethBalance = await typedApi.apis.ReviveApi.balance(addr);
      const nativeToEth = await typedApi.constants.Revive.NativeToEthRatio();
      return u256ToValue(ethBalance, nativeToEth);
    },
    dryRunCall: (origin, dest, value, gas_limit, storage_deposit_limit, input) => Promise.all([
      typedApi.apis.ReviveApi.call(
        origin,
        dest,
        value,
        gas_limit,
        storage_deposit_limit,
        input,
        callOptions
      ),
      traceCall({
        from: ss58ToEthereum(origin),
        input: {
          input
        },
        to: dest
      })
    ]).then(([call, trace]) => {
      const events = (() => {
        if (call.events) return call.events;
        if (!trace.success) return void 0;
        if ("type" in trace.value) {
          if (trace.value.type === "Prestate") {
            console.error("Unexpected prestate response for events");
            return void 0;
          }
          return getEventsFromTrace(trace.value.value);
        }
        return getEventsFromTrace(trace.value);
      })();
      return {
        ...call,
        events
      };
    }),
    dryRunInstantiate: (origin, value, gas_limit, storage_deposit_limit, code, data, salt) => Promise.all([
      typedApi.apis.ReviveApi.instantiate(
        origin,
        value,
        gas_limit,
        storage_deposit_limit,
        code,
        data,
        salt,
        callOptions
      ),
      typedApi.constants.Revive.NativeToEthRatio().then(
        (nativeToEth) => traceCall({
          from: ss58ToEthereum(origin),
          input: {
            input: Binary.fromBytes(
              mergeUint8([code.value.asBytes(), data.asBytes()])
            )
          },
          value: valueToU256(value, nativeToEth)
        })
      )
    ]).then(([call, trace]) => {
      const events = (() => {
        if (call.events) return call.events;
        if (!trace.success) return void 0;
        if ("type" in trace.value) {
          if (trace.value.type === "Prestate") {
            console.error("Unexpected prestate response for events");
            return void 0;
          }
          return getEventsFromTrace(trace.value.value);
        }
        return getEventsFromTrace(trace.value);
      })();
      return {
        ...call,
        events
      };
    }),
    getEstimatedAddress: async (origin, _value, code_arg, data, salt, nonce_arg) => {
      if (salt) {
        const code = code_arg.type === "Upload" ? code_arg.value : await typedApi.query.Revive.PristineCode.getValue(
          code_arg.value,
          callOptions
        );
        if (!code) return null;
        return getDeploymentAddressWithSalt(
          origin,
          getDeploymentHash(code, data),
          salt
        );
      }
      const nonce = nonce_arg != null ? nonce_arg : (await typedApi.query.System.Account.getValue(origin, callOptions)).nonce;
      return getDeploymentAddressWithNonce(origin, nonce);
    },
    getStorage: async (...args) => {
      const var_key_call = typedApi.apis.ReviveApi.get_storage_var_key;
      const call = var_key_call.isCompatible(CompatibilityLevel.Partial) ? var_key_call : typedApi.apis.ReviveApi.get_storage;
      return call(...args, callOptions);
    },
    getCodeHash: async (addr) => {
      const newApi = typedApi;
      if (await newApi.query.Revive.AccountInfoOf.isCompatible(
        CompatibilityLevel.Partial
      )) {
        const result2 = await newApi.query.Revive.AccountInfoOf.getValue(
          addr,
          callOptions
        );
        if (result2?.account_type.type !== "Contract") {
          return void 0;
        }
        return result2.account_type.value.code_hash;
      }
      const oldApi = typedApi;
      const result = await oldApi.query.Revive.ContractInfoOf.getValue(
        addr,
        callOptions
      );
      return result?.code_hash;
    },
    txCall: (payload) => {
      if (payload.storage_deposit_limit == null) {
        throw new Error("Pallet revive requires storage deposit limit");
      }
      return typedApi.tx.Revive.call({
        storage_deposit_limit: payload.storage_deposit_limit,
        ...payload
      });
    },
    txInstantiate: (payload) => {
      if (payload.storage_deposit_limit == null) {
        throw new Error("Pallet revive requires storage deposit limit");
      }
      return typedApi.tx.Revive.instantiate({
        storage_deposit_limit: payload.storage_deposit_limit,
        salt: payload.salt,
        ...payload
      });
    },
    txInstantiateWithCode: (payload) => {
      if (payload.storage_deposit_limit == null) {
        throw new Error("Pallet revive requires storage deposit limit");
      }
      return typedApi.tx.Revive.instantiate_with_code({
        storage_deposit_limit: payload.storage_deposit_limit,
        salt: payload.salt,
        ...payload
      });
    }
  };
};

export { contractsProvider, reviveProvider };
//# sourceMappingURL=provider.mjs.map
