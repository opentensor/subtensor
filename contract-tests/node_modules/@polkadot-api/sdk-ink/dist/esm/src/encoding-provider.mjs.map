{"version":3,"file":"encoding-provider.mjs","sources":["../../../src/encoding-provider.ts"],"sourcesContent":["import {\n  GenericEvent,\n  getInkClient,\n  getInkLookup,\n} from \"@polkadot-api/ink-contracts\"\nimport {\n  AbiConstructor,\n  AbiError,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n} from \"abitype\"\nimport { Binary, FixedSizeBinary } from \"polkadot-api\"\nimport {\n  Abi,\n  decodeErrorResult,\n  decodeEventLog,\n  decodeFunctionResult,\n  encodeDeployData,\n  encodeFunctionData,\n} from \"viem\"\nimport { GenericInkDescriptors } from \"./descriptor-types\"\nimport { compactNumber } from \"@polkadot-api/substrate-bindings\"\n\nexport interface EncodingProvider {\n  isCompatible(codeHash: FixedSizeBinary<32>): boolean\n  message(message: string): {\n    encode: (value: unknown) => Binary\n    decode: (value: Binary) => unknown\n  }\n  constructor(constructor: string): {\n    encode: (value: unknown) => Binary\n    decode: (value: Binary) => unknown\n  }\n  filterEvents(\n    address: string,\n    events?: Array<\n      | {\n          event: GenericEvent\n          topics: Binary[]\n        }\n      | (GenericEvent & {\n          topics: Binary[]\n        })\n    >,\n  ): GenericEvent[]\n  storage(key: string): {\n    encode: (value: unknown) => Binary\n    decode: (value: Binary) => unknown\n  }\n  storagePaths(): string[]\n  decodeError(data: Binary): unknown\n}\n\nexport const inkEncoding = (\n  descriptors: GenericInkDescriptors,\n): EncodingProvider => {\n  if (!descriptors.metadata)\n    throw new Error(\"ink encoding needs an ink contract\")\n\n  const inkClient = getInkClient(descriptors)\n  const lookup = getInkLookup(descriptors.metadata)\n\n  return {\n    isCompatible(codeHash) {\n      return codeHash ? codeHash.asHex() === lookup.metadata.source.hash : false\n    },\n    message(message) {\n      const msg = inkClient.message(message)\n\n      return {\n        encode: (value) => msg.encode(value as any),\n        decode: (data) => msg.decode({ data }),\n      }\n    },\n    constructor(constructor) {\n      const msg = inkClient.constructor(constructor)\n\n      return {\n        encode: (value) => msg.encode(value as any),\n        decode: (data) => msg.decode({ data }),\n      }\n    },\n    filterEvents(address, events) {\n      return inkClient.event.filter(address, events)\n    },\n    storage(key) {\n      const storage = inkClient.storage(key)\n\n      return {\n        encode: (value) => storage.encode(value as any),\n        decode: (data) => storage.decode(data),\n      }\n    },\n    storagePaths() {\n      return Object.keys(lookup.storage)\n    },\n    decodeError(data) {\n      // In case of panic! or return_value(REVERT, &\"some message\"), the value comes back as an opaque string\n      // Meaning what we get over the wire is [payload_len,data]\n      // And `data` is a Vec<u8>, hence [msg_len,...chars]. In this case, the msg_len is redundant.\n      try {\n        const bytes = data.asBytes()\n        const length = compactNumber.dec(bytes)\n        const compactLength = compactNumber.enc(length).length\n        if (compactLength + length === bytes.length) {\n          return Binary.fromBytes(bytes.slice(compactLength)).asText()\n        }\n      } catch {}\n      return data.asHex()\n    },\n  }\n}\n\ntype AbiCallable = AbiConstructor | AbiFallback | AbiFunction | AbiReceive\n\nexport const solEncoding = (\n  descriptors: GenericInkDescriptors,\n): EncodingProvider => {\n  if (descriptors.abi == null)\n    throw new Error(\"sol encoding needs an solidity contract\")\n  const abi = descriptors.abi as Abi\n\n  // There are two objects that are different between papi and viem:\n  // - function: { address: HexString, selector: HexString } <=> HexString\n  // - bytes: Binary <=> HexString\n  const valueToViem = (value: unknown, param: AbiParameter): unknown => {\n    if (param.type === \"function\") {\n      if (typeof value === \"string\" && value.startsWith(\"0x\")) return value\n      if (\n        typeof value !== \"object\" ||\n        !value ||\n        !(\"address\" in value) ||\n        !(\"selector\" in value)\n      ) {\n        throw new Error(\n          \"Expected FunctionRef in parameter \" + (param.name ?? \"(no name)\"),\n        )\n      }\n\n      return (value.address as string) + (value.selector as string).slice(2)\n    }\n    if (param.type.endsWith(\"]\")) {\n      if (!Array.isArray(value))\n        throw new Error(\n          \"Expected array in parameter \" + (param.name ?? \"(no name)\"),\n        )\n      const innerType = {\n        ...param,\n        type: param.type.slice(0, param.type.indexOf(\"[\")),\n      }\n      return value.map((v) => valueToViem(v, innerType))\n    }\n    // TODO tuple\n\n    if (param.type.startsWith(\"bytes\")) {\n      if (typeof value === \"string\" && value.startsWith(\"0x\")) return value\n      if (\n        typeof value !== \"object\" ||\n        !value ||\n        !(\"asHex\" in value) ||\n        typeof value.asHex != \"function\"\n      ) {\n        throw new Error(\n          \"Expected Binary in parameter \" + (param.name ?? \"(no name)\"),\n        )\n      }\n      return value.asHex()\n    }\n\n    return value\n  }\n  const viemToValue = (value: unknown, param: AbiParameter): unknown => {\n    const strValue = value as string\n    if (param.type === \"function\") {\n      const address = strValue.slice(0, 2 + 20 * 2)\n      const selector = \"0x\" + strValue.slice(2 + 20 * 2)\n      return { address, selector }\n    }\n    if (param.type.endsWith(\"]\")) {\n      const innerType = {\n        ...param,\n        type: param.type.slice(0, param.type.indexOf(\"[\")),\n      }\n      return (value as any[]).map((v) => viemToValue(v, innerType))\n    }\n    if (param.type.startsWith(\"bytes\")) {\n      return Binary.fromHex(strValue)\n    }\n\n    return value\n  }\n\n  const inputsToViem = (\n    value: unknown,\n    inputs: readonly AbiParameter[],\n  ): unknown[] => {\n    const unnamedTypes = inputs.filter((v) => !v.name)\n    const namedTypes = inputs.filter((v) => !!v.name)\n\n    if (namedTypes.length == 0) {\n      if (!unnamedTypes.length) return []\n\n      if (unnamedTypes.length === 1) {\n        return [valueToViem(value, unnamedTypes[0])]\n      }\n\n      if (!Array.isArray(value)) {\n        throw new Error(\"Expected array as input\")\n      }\n      return unnamedTypes.map((v, i) => valueToViem(value[i], v))\n    }\n\n    if (!value || typeof value !== \"object\") {\n      throw new Error(\"Expected object as input\")\n    }\n    const anyValue = value as any\n\n    let iUnnamed = 0\n    return inputs.map((v) => {\n      if (v.name) {\n        return valueToViem(anyValue[v.name], v)\n      }\n      return valueToViem(anyValue.args[iUnnamed++], v)\n    })\n  }\n  const viemToOutputs = (\n    value: unknown,\n    outputs: readonly AbiParameter[],\n  ): unknown => {\n    // In case there's only one output, viem always flattens it out, even if it's named.\n\n    const unnamedTypes = outputs.filter((v) => !v.name)\n    const namedTypes = outputs.filter((v) => !!v.name)\n\n    if (namedTypes.length == 0) {\n      if (unnamedTypes.length === 1) {\n        return viemToValue(value, unnamedTypes[0])\n      }\n\n      return unnamedTypes.map((v, i) => viemToValue((value as any)[i], v))\n    }\n\n    if (namedTypes.length === 1) {\n      return {\n        [namedTypes[0].name!]: viemToValue(value, namedTypes[0]),\n      }\n    }\n\n    const result: Record<string, any> = {}\n    const args: any[] = []\n    const valueArr = value as any[]\n\n    outputs.forEach((v, i) => {\n      const value = viemToValue(valueArr[i], v)\n      if (v.name) {\n        result[v.name] = value\n      } else {\n        args.push(value)\n      }\n    })\n\n    if (args.length) result.args = args\n\n    return result\n  }\n\n  return {\n    isCompatible() {\n      return true\n    },\n    constructor() {\n      const ctor = abi.find((v) => v.type === \"constructor\")\n\n      return {\n        encode(value) {\n          return Binary.fromHex(\n            ctor\n              ? encodeDeployData({\n                  abi,\n                  args: inputsToViem(value, ctor.inputs ?? []),\n                  bytecode: \"0x\",\n                })\n              : \"0x\",\n          )\n        },\n        decode() {\n          return null\n        },\n      }\n    },\n    message(message) {\n      const msg = abi.find((v) =>\n        message === \"fallback\" || message === \"receive\"\n          ? v.type === message\n          : \"name\" in v && v.name === message,\n      ) as AbiCallable\n      if (!msg) {\n        throw new Error(\"Can't find message \" + msg)\n      }\n\n      return {\n        encode(value) {\n          return Binary.fromHex(\n            encodeFunctionData({\n              abi,\n              // TODO \"receive\"\n              functionName: message === \"fallback\" ? undefined : message,\n              args: inputsToViem(value, \"inputs\" in msg ? msg.inputs : []),\n            }),\n          )\n        },\n        decode(value) {\n          const result = decodeFunctionResult({\n            abi,\n            functionName: message === \"fallback\" ? undefined : message,\n            data: value.asHex() as `0x${string}`,\n          })\n          return viemToOutputs(result, \"outputs\" in msg ? msg.outputs : [])\n        },\n      }\n    },\n    filterEvents(address, events = []) {\n      const addrEq = (a: string | Binary) =>\n        (a instanceof Binary ? a.asHex() : a) === address\n\n      const contractEvents = events\n        .map((v) => (\"event\" in v ? v : { event: v, topics: v.topics }))\n        .filter(\n          (v) =>\n            v.event.type === \"Revive\" &&\n            (v.event.value as any).type === \"ContractEmitted\" &&\n            addrEq((v.event.value as any).value.contract),\n        )\n\n      return contractEvents\n        .map((v): GenericEvent | null => {\n          const topics = v.topics.map((v) => v.asHex())\n\n          try {\n            const evtLog = decodeEventLog({\n              abi,\n              topics: topics as any,\n              data: (v.event.value as any).value.data.asHex(),\n            })\n            return {\n              type: evtLog.eventName!,\n              value: evtLog.args,\n            }\n          } catch (ex) {\n            return null\n          }\n        })\n        .filter((v) => v !== null)\n    },\n    storage() {\n      throw new Error(\"Solidity contract storage unaccessible\")\n    },\n    storagePaths() {\n      throw new Error(\"Solidity contract storage unaccessible\")\n    },\n    decodeError(data) {\n      try {\n        const error = decodeErrorResult({\n          abi,\n          data: data.asHex() as `0x${string}`,\n        })\n        const abiItem = error.abiItem as AbiError\n\n        return {\n          type: error.errorName,\n          value: viemToOutputs(error.args, abiItem.inputs),\n        }\n      } catch (ex) {\n        console.error(ex)\n        return data.asHex()\n      }\n    },\n  }\n}\n"],"names":["value","v"],"mappings":"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"}