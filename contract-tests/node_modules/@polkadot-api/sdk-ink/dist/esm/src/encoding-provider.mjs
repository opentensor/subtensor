import { getInkClient, getInkLookup } from '@polkadot-api/ink-contracts';
import { Binary } from 'polkadot-api';
import { decodeErrorResult, decodeEventLog, decodeFunctionResult, encodeFunctionData, encodeDeployData } from 'viem';
import { compactNumber } from '@polkadot-api/substrate-bindings';

const inkEncoding = (descriptors) => {
  if (!descriptors.metadata)
    throw new Error("ink encoding needs an ink contract");
  const inkClient = getInkClient(descriptors);
  const lookup = getInkLookup(descriptors.metadata);
  return {
    isCompatible(codeHash) {
      return codeHash ? codeHash.asHex() === lookup.metadata.source.hash : false;
    },
    message(message) {
      const msg = inkClient.message(message);
      return {
        encode: (value) => msg.encode(value),
        decode: (data) => msg.decode({ data })
      };
    },
    constructor(constructor) {
      const msg = inkClient.constructor(constructor);
      return {
        encode: (value) => msg.encode(value),
        decode: (data) => msg.decode({ data })
      };
    },
    filterEvents(address, events) {
      return inkClient.event.filter(address, events);
    },
    storage(key) {
      const storage = inkClient.storage(key);
      return {
        encode: (value) => storage.encode(value),
        decode: (data) => storage.decode(data)
      };
    },
    storagePaths() {
      return Object.keys(lookup.storage);
    },
    decodeError(data) {
      try {
        const bytes = data.asBytes();
        const length = compactNumber.dec(bytes);
        const compactLength = compactNumber.enc(length).length;
        if (compactLength + length === bytes.length) {
          return Binary.fromBytes(bytes.slice(compactLength)).asText();
        }
      } catch {
      }
      return data.asHex();
    }
  };
};
const solEncoding = (descriptors) => {
  if (descriptors.abi == null)
    throw new Error("sol encoding needs an solidity contract");
  const abi = descriptors.abi;
  const valueToViem = (value, param) => {
    if (param.type === "function") {
      if (typeof value === "string" && value.startsWith("0x")) return value;
      if (typeof value !== "object" || !value || !("address" in value) || !("selector" in value)) {
        throw new Error(
          "Expected FunctionRef in parameter " + (param.name ?? "(no name)")
        );
      }
      return value.address + value.selector.slice(2);
    }
    if (param.type.endsWith("]")) {
      if (!Array.isArray(value))
        throw new Error(
          "Expected array in parameter " + (param.name ?? "(no name)")
        );
      const innerType = {
        ...param,
        type: param.type.slice(0, param.type.indexOf("["))
      };
      return value.map((v) => valueToViem(v, innerType));
    }
    if (param.type.startsWith("bytes")) {
      if (typeof value === "string" && value.startsWith("0x")) return value;
      if (typeof value !== "object" || !value || !("asHex" in value) || typeof value.asHex != "function") {
        throw new Error(
          "Expected Binary in parameter " + (param.name ?? "(no name)")
        );
      }
      return value.asHex();
    }
    return value;
  };
  const viemToValue = (value, param) => {
    const strValue = value;
    if (param.type === "function") {
      const address = strValue.slice(0, 2 + 20 * 2);
      const selector = "0x" + strValue.slice(2 + 20 * 2);
      return { address, selector };
    }
    if (param.type.endsWith("]")) {
      const innerType = {
        ...param,
        type: param.type.slice(0, param.type.indexOf("["))
      };
      return value.map((v) => viemToValue(v, innerType));
    }
    if (param.type.startsWith("bytes")) {
      return Binary.fromHex(strValue);
    }
    return value;
  };
  const inputsToViem = (value, inputs) => {
    const unnamedTypes = inputs.filter((v) => !v.name);
    const namedTypes = inputs.filter((v) => !!v.name);
    if (namedTypes.length == 0) {
      if (!unnamedTypes.length) return [];
      if (unnamedTypes.length === 1) {
        return [valueToViem(value, unnamedTypes[0])];
      }
      if (!Array.isArray(value)) {
        throw new Error("Expected array as input");
      }
      return unnamedTypes.map((v, i) => valueToViem(value[i], v));
    }
    if (!value || typeof value !== "object") {
      throw new Error("Expected object as input");
    }
    const anyValue = value;
    let iUnnamed = 0;
    return inputs.map((v) => {
      if (v.name) {
        return valueToViem(anyValue[v.name], v);
      }
      return valueToViem(anyValue.args[iUnnamed++], v);
    });
  };
  const viemToOutputs = (value, outputs) => {
    const unnamedTypes = outputs.filter((v) => !v.name);
    const namedTypes = outputs.filter((v) => !!v.name);
    if (namedTypes.length == 0) {
      if (unnamedTypes.length === 1) {
        return viemToValue(value, unnamedTypes[0]);
      }
      return unnamedTypes.map((v, i) => viemToValue(value[i], v));
    }
    if (namedTypes.length === 1) {
      return {
        [namedTypes[0].name]: viemToValue(value, namedTypes[0])
      };
    }
    const result = {};
    const args = [];
    const valueArr = value;
    outputs.forEach((v, i) => {
      const value2 = viemToValue(valueArr[i], v);
      if (v.name) {
        result[v.name] = value2;
      } else {
        args.push(value2);
      }
    });
    if (args.length) result.args = args;
    return result;
  };
  return {
    isCompatible() {
      return true;
    },
    constructor() {
      const ctor = abi.find((v) => v.type === "constructor");
      return {
        encode(value) {
          return Binary.fromHex(
            ctor ? encodeDeployData({
              abi,
              args: inputsToViem(value, ctor.inputs ?? []),
              bytecode: "0x"
            }) : "0x"
          );
        },
        decode() {
          return null;
        }
      };
    },
    message(message) {
      const msg = abi.find(
        (v) => message === "fallback" || message === "receive" ? v.type === message : "name" in v && v.name === message
      );
      if (!msg) {
        throw new Error("Can't find message " + msg);
      }
      return {
        encode(value) {
          return Binary.fromHex(
            encodeFunctionData({
              abi,
              // TODO "receive"
              functionName: message === "fallback" ? void 0 : message,
              args: inputsToViem(value, "inputs" in msg ? msg.inputs : [])
            })
          );
        },
        decode(value) {
          const result = decodeFunctionResult({
            abi,
            functionName: message === "fallback" ? void 0 : message,
            data: value.asHex()
          });
          return viemToOutputs(result, "outputs" in msg ? msg.outputs : []);
        }
      };
    },
    filterEvents(address, events = []) {
      const addrEq = (a) => (a instanceof Binary ? a.asHex() : a) === address;
      const contractEvents = events.map((v) => "event" in v ? v : { event: v, topics: v.topics }).filter(
        (v) => v.event.type === "Revive" && v.event.value.type === "ContractEmitted" && addrEq(v.event.value.value.contract)
      );
      return contractEvents.map((v) => {
        const topics = v.topics.map((v2) => v2.asHex());
        try {
          const evtLog = decodeEventLog({
            abi,
            topics,
            data: v.event.value.value.data.asHex()
          });
          return {
            type: evtLog.eventName,
            value: evtLog.args
          };
        } catch (ex) {
          return null;
        }
      }).filter((v) => v !== null);
    },
    storage() {
      throw new Error("Solidity contract storage unaccessible");
    },
    storagePaths() {
      throw new Error("Solidity contract storage unaccessible");
    },
    decodeError(data) {
      try {
        const error = decodeErrorResult({
          abi,
          data: data.asHex()
        });
        const abiItem = error.abiItem;
        return {
          type: error.errorName,
          value: viemToOutputs(error.args, abiItem.inputs)
        };
      } catch (ex) {
        console.error(ex);
        return data.asHex();
      }
    }
  };
};

export { inkEncoding, solEncoding };
//# sourceMappingURL=encoding-provider.mjs.map
