{"version":3,"file":"get-storage.mjs","sources":["../../../src/get-storage.ts"],"sourcesContent":["import type { InkStorageDescriptor } from \"@polkadot-api/ink-contracts\"\nimport type { ResultPayload } from \"polkadot-api\"\nimport type { GenericInkDescriptors, StorageError } from \"./descriptor-types\"\nimport { EncodingProvider } from \"./encoding-provider\"\nimport { ContractsProvider } from \"./provider\"\n\nexport type SdkStorage<\n  S extends InkStorageDescriptor,\n  StorageErr,\n> = NestedStorage<S, StorageErr> & RootStorage<S, StorageErr>\n\nexport function getStorage<Addr, StorageErr, D extends GenericInkDescriptors>(\n  provider: ContractsProvider<Addr, StorageErr>,\n  encodingProvider: EncodingProvider,\n  address: Addr,\n): SdkStorage<D[\"__types\"][\"storage\"], StorageErr> {\n  type S = D[\"__types\"][\"storage\"]\n\n  const getStorage = async (\n    label: string,\n    key: unknown,\n  ): Promise<ResultPayload<unknown, StorageErr>> => {\n    const storage = encodingProvider.storage(label)\n    const result = await provider.getStorage(\n      address,\n      storage.encode(key as any),\n    )\n\n    if (result.success) {\n      return {\n        success: true,\n        value: result.value ? storage.decode(result.value) : undefined,\n      }\n    }\n    return {\n      success: false,\n      value: result.value,\n    }\n  }\n\n  return {\n    async getNested<L extends string & Exclude<keyof S, \"\">>(\n      label: L,\n      ...args: S[L][\"key\"] extends undefined ? [] : [key: S[L][\"key\"]]\n    ): Promise<ResultPayload<S[L][\"value\"], StorageErr>> {\n      return getStorage(label, args[0])\n    },\n    async getRoot(): Promise<\n      ResultPayload<S[\"\"][\"value\"] & UnNest<Omit<S, \"\">>, StorageErr>\n    > {\n      const root = (await getStorage(\"\", undefined)) as ResultPayload<\n        S[\"\"][\"value\"],\n        StorageErr\n      >\n      if (!root.success) {\n        return root\n      }\n\n      const value = root.value as S[\"\"][\"value\"] & UnNest<Omit<S, \"\">>\n      for (const path of encodingProvider.storagePaths()) {\n        if (path === \"\") continue\n        assignFnAtPath(value, path.split(\".\"), (key: any) =>\n          getStorage(path, key),\n        )\n      }\n\n      return {\n        success: true,\n        value,\n      }\n    },\n  }\n}\n\nconst assignFnAtPath = (\n  target: any,\n  segments: string[],\n  value: (...args: unknown[]) => unknown,\n) => {\n  const [current, ...rest] = segments\n  if (rest.length === 0) {\n    if (typeof target[current] === \"object\") {\n      target[current] = Object.assign(value, target[current])\n    } else {\n      target[current] = value\n    }\n  } else {\n    target[current] = current in target ? target[current] : {}\n    assignFnAtPath(target[current], rest, value)\n  }\n}\n\ntype NestedStorage<S extends InkStorageDescriptor, StorageErr> =\n  Exclude<keyof S, \"\"> extends never\n    ? {}\n    : {\n        getNested<L extends string & Exclude<keyof S, \"\">>(\n          label: L,\n          ...args: S[L][\"key\"] extends undefined ? [] : [key: S[L][\"key\"]]\n        ): Promise<ResultPayload<S[L][\"value\"], StorageErr>>\n      }\n\ntype RootStorage<\n  S extends InkStorageDescriptor,\n  StorageErr,\n> = \"\" extends keyof S\n  ? {\n      getRoot(): Promise<\n        ResultPayload<S[\"\"][\"value\"] & UnNest<Omit<S, \"\">>, StorageErr>\n      >\n    }\n  : {}\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype BuildNested<K extends string, V> = K extends `${infer P}.${infer Rest}`\n  ? { [Key in P]: BuildNested<Rest, V> }\n  : K extends \"\"\n    ? V\n    : {\n        [Key in K]: V\n      }\n\ntype UnNest<S extends InkStorageDescriptor> = UnionToIntersection<\n  {\n    [K in string & keyof S]: BuildNested<\n      K,\n      (\n        ...args: S[K][\"key\"] extends undefined ? [] : [key: S[K][\"key\"]]\n      ) => Promise<ResultPayload<S[K][\"value\"], StorageError>>\n    >\n  }[string & keyof S]\n>\n"],"names":["getStorage"],"mappings":"AAWO,SAAS,UAAA,CACd,QAAA,EACA,gBAAA,EACA,OAAA,EACiD;AAGjD,EAAA,MAAMA,WAAAA,GAAa,OACjB,KAAA,EACA,GAAA,KACgD;AAChD,IAAA,MAAM,OAAA,GAAU,gBAAA,CAAiB,OAAA,CAAQ,KAAK,CAAA;AAC9C,IAAA,MAAM,MAAA,GAAS,MAAM,QAAA,CAAS,UAAA;AAAA,MAC5B,OAAA;AAAA,MACA,OAAA,CAAQ,OAAO,GAAU;AAAA,KAC3B;AAEA,IAAA,IAAI,OAAO,OAAA,EAAS;AAClB,MAAA,OAAO;AAAA,QACL,OAAA,EAAS,IAAA;AAAA,QACT,OAAO,MAAA,CAAO,KAAA,GAAQ,QAAQ,MAAA,CAAO,MAAA,CAAO,KAAK,CAAA,GAAI;AAAA,OACvD;AAAA,IACF;AACA,IAAA,OAAO;AAAA,MACL,OAAA,EAAS,KAAA;AAAA,MACT,OAAO,MAAA,CAAO;AAAA,KAChB;AAAA,EACF,CAAA;AAEA,EAAA,OAAO;AAAA,IACL,MAAM,SAAA,CACJ,KAAA,EAAA,GACG,IAAA,EACgD;AACnD,MAAA,OAAOA,WAAAA,CAAW,KAAA,EAAO,IAAA,CAAK,CAAC,CAAC,CAAA;AAAA,IAClC,CAAA;AAAA,IACA,MAAM,OAAA,GAEJ;AACA,MAAA,MAAM,IAAA,GAAQ,MAAMA,WAAAA,CAAW,EAAA,EAAI,MAAS,CAAA;AAI5C,MAAA,IAAI,CAAC,KAAK,OAAA,EAAS;AACjB,QAAA,OAAO,IAAA;AAAA,MACT;AAEA,MAAA,MAAM,QAAQ,IAAA,CAAK,KAAA;AACnB,MAAA,KAAA,MAAW,IAAA,IAAQ,gBAAA,CAAiB,YAAA,EAAa,EAAG;AAClD,QAAA,IAAI,SAAS,EAAA,EAAI;AACjB,QAAA,cAAA;AAAA,UAAe,KAAA;AAAA,UAAO,IAAA,CAAK,MAAM,GAAG,CAAA;AAAA,UAAG,CAAC,GAAA,KACtCA,WAAAA,CAAW,IAAA,EAAM,GAAG;AAAA,SACtB;AAAA,MACF;AAEA,MAAA,OAAO;AAAA,QACL,OAAA,EAAS,IAAA;AAAA,QACT;AAAA,OACF;AAAA,IACF;AAAA,GACF;AACF;AAEA,MAAM,cAAA,GAAiB,CACrB,MAAA,EACA,QAAA,EACA,KAAA,KACG;AACH,EAAA,MAAM,CAAC,OAAA,EAAS,GAAG,IAAI,CAAA,GAAI,QAAA;AAC3B,EAAA,IAAI,IAAA,CAAK,WAAW,CAAA,EAAG;AACrB,IAAA,IAAI,OAAO,MAAA,CAAO,OAAO,CAAA,KAAM,QAAA,EAAU;AACvC,MAAA,MAAA,CAAO,OAAO,CAAA,GAAI,MAAA,CAAO,OAAO,KAAA,EAAO,MAAA,CAAO,OAAO,CAAC,CAAA;AAAA,IACxD,CAAA,MAAO;AACL,MAAA,MAAA,CAAO,OAAO,CAAA,GAAI,KAAA;AAAA,IACpB;AAAA,EACF,CAAA,MAAO;AACL,IAAA,MAAA,CAAO,OAAO,CAAA,GAAI,OAAA,IAAW,SAAS,MAAA,CAAO,OAAO,IAAI,EAAC;AACzD,IAAA,cAAA,CAAe,MAAA,CAAO,OAAO,CAAA,EAAG,IAAA,EAAM,KAAK,CAAA;AAAA,EAC7C;AACF,CAAA;;;;"}