import { TypedApi, PalletsTypedef as PalletsTypedef$2, StorageDescriptor, SS58String, FixedSizeBinary, TxDescriptor, Enum, Binary, ApisTypedef, RuntimeDescriptor, ResultPayload, PlainDescriptor, FixedSizeArray, GetEnum, HexString, PolkadotClient } from 'polkadot-api';
import { SdkDefinition, FlattenValues, AsyncTransaction, FlattenErrors } from '@polkadot-api/common-sdk-utils';
export { AsyncTransaction } from '@polkadot-api/common-sdk-utils';
import { InkDescriptors, InkStorageDescriptor, InkCallableDescriptor, Event, GenericEvent } from '@polkadot-api/ink-contracts';

type MultiAddress = Enum<{
    Id: SS58String;
    Index: undefined;
    Raw: Binary;
    Address32: FixedSizeBinary<32>;
    Address20: FixedSizeBinary<20>;
}>;
type Gas = {
    ref_time: bigint;
    proof_size: bigint;
};
type StorageError = Enum<{
    DoesntExist: undefined;
    KeyDecodingFailed: undefined;
    MigrationInProgress: undefined;
}>;
type DryRunCallParams<Addr> = [
    origin: SS58String,
    dest: Addr,
    value: bigint,
    gas_limit: Gas | undefined,
    storage_deposit_limit: bigint | undefined,
    input_data: Binary
];
type DryRunCallResult<Ev = any, Err = any> = {
    gas_consumed: Gas;
    gas_required: Gas;
    storage_deposit: Enum<{
        Refund: bigint;
        Charge: bigint;
    }>;
    result: ResultPayload<{
        flags: number;
        data: Binary;
    }, Err>;
    events?: Array<Ev>;
};
type DryRunInstantiateParams = [
    origin: SS58String,
    value: bigint,
    gas_limit: Gas | undefined,
    storage_deposit_limit: bigint | undefined,
    code: Enum<{
        Upload: Binary;
        Existing: FixedSizeBinary<32>;
    }>,
    data: Binary,
    salt: Binary | undefined
];
type DryRunInstantiateResult<AddrRes, Ev = any, Err = any> = {
    gas_consumed: Gas;
    gas_required: Gas;
    storage_deposit: Enum<{
        Refund: bigint;
        Charge: bigint;
    }>;
    result: ResultPayload<{
        result: {
            flags: number;
            data: Binary;
        };
    } & AddrRes, Err>;
    events?: Array<Ev>;
};
type InkSdkApis<Ev = any, Err = any> = ApisTypedef<{
    ContractsApi: {
        call: RuntimeDescriptor<DryRunCallParams<SS58String>, DryRunCallResult<Ev, Err>>;
        instantiate: RuntimeDescriptor<DryRunInstantiateParams, DryRunInstantiateResult<{
            account_id: SS58String;
        }, Ev, Err>>;
        get_storage: RuntimeDescriptor<[
            address: SS58String,
            key: Binary
        ], ResultPayload<Binary | undefined, StorageError>>;
    };
}>;
type InkSdkPallets = PalletsTypedef$2<{
    System: {
        Account: StorageDescriptor<[
            Key: SS58String
        ], {
            data: {
                free: bigint;
            };
        }, false, never>;
    };
    Contracts: {
        ContractInfoOf: StorageDescriptor<[
            Key: SS58String
        ], {
            code_hash: FixedSizeBinary<32>;
        }, true, never>;
    };
}, {
    Contracts: {
        call: TxDescriptor<{
            dest: MultiAddress;
            value: bigint;
            gas_limit: Gas;
            storage_deposit_limit: bigint | undefined;
            data: Binary;
        }>;
        instantiate: TxDescriptor<{
            value: bigint;
            gas_limit: Gas;
            storage_deposit_limit: bigint | undefined;
            code_hash: FixedSizeBinary<32>;
            data: Binary;
            salt: Binary;
        }>;
        instantiate_with_code: TxDescriptor<{
            value: bigint;
            gas_limit: Gas;
            storage_deposit_limit: bigint | undefined;
            code: Binary;
            data: Binary;
            salt: Binary;
        }>;
    };
}, {}, {}, {}, {}>;
type InkSdkDefinition = SdkDefinition<InkSdkPallets, InkSdkApis>;
type InkSdkTypedApi = TypedApi<InkSdkDefinition>;
type GenericInkDescriptors = InkDescriptors<InkStorageDescriptor, InkCallableDescriptor, InkCallableDescriptor, Event>;
type ReviveAddress = FixedSizeBinary<20>;
type ReviveStorageError = Enum<{
    DoesntExist: undefined;
    KeyDecodingFailed: undefined;
}>;
type U256 = FixedSizeArray<4, bigint>;
type GenericTransaction = {
    blob_versioned_hashes: Array<FixedSizeBinary<32>>;
    authorization_list?: Array<unknown>;
    blobs: Array<Binary>;
    from?: FixedSizeBinary<20> | undefined;
    input: {
        input?: Binary | undefined;
        data?: Binary | undefined;
    };
    to?: FixedSizeBinary<20> | undefined;
    value?: U256 | undefined;
};
type TraceCallResult = {
    from: FixedSizeBinary<20>;
    to: FixedSizeBinary<20>;
    output: Binary;
    error?: string;
    revert_reason?: string;
    calls: Array<TraceCallResult>;
    logs: Array<{
        address: FixedSizeBinary<20>;
        topics: Array<FixedSizeBinary<32>>;
        data: Binary;
        position: number;
    }>;
    value?: U256 | undefined;
};
type ContractState = Array<[
    FixedSizeBinary<20>,
    {
        balance?: U256 | undefined;
        nonce?: number | undefined;
        code?: Binary | undefined;
        storage: Array<[Binary, Binary | undefined]>;
    }
]>;
type ReviveSdkApis<Ev = any, Err = any> = ApisTypedef<{
    ReviveApi: {
        call: RuntimeDescriptor<DryRunCallParams<ReviveAddress>, DryRunCallResult<Ev, Err>>;
        instantiate: RuntimeDescriptor<DryRunInstantiateParams, DryRunInstantiateResult<{
            addr: ReviveAddress;
        }, Ev, Err>>;
        get_storage: RuntimeDescriptor<[
            address: ReviveAddress,
            key: FixedSizeBinary<32>
        ], ResultPayload<Binary | undefined, ReviveStorageError>>;
        get_storage_var_key?: RuntimeDescriptor<[
            address: ReviveAddress,
            key: Binary
        ], ResultPayload<Binary | undefined, ReviveStorageError>>;
        trace_call: RuntimeDescriptor<[
            tx: GenericTransaction,
            config: Enum<{
                CallTracer?: {
                    with_logs: boolean;
                    only_top_call?: boolean;
                } | undefined;
                PrestateTracer?: {
                    diff_mode: boolean;
                    disable_storage: boolean;
                    disable_code: boolean;
                } | undefined;
            }>
        ], ResultPayload<Enum<{
            Call: TraceCallResult;
            Prestate: Enum<{
                Prestate: ContractState;
                DiffMode: {
                    pre: ContractState;
                    post: ContractState;
                };
            }>;
        }> | TraceCallResult, Enum<{
            Data: Binary;
            Message: string;
        }>>>;
        balance: RuntimeDescriptor<[address: FixedSizeBinary<20>], U256>;
    };
}>;
type ReviveSdkPallets<TStorage> = PalletsTypedef$2<{
    System: {
        Account: StorageDescriptor<[
            Key: SS58String
        ], {
            nonce: number;
        }, false, never>;
    };
    Revive: {
        PristineCode: StorageDescriptor<[
            Key: FixedSizeBinary<32>
        ], Binary, true, never>;
        OriginalAccount: StorageDescriptor<[
            Key: FixedSizeBinary<20>
        ], SS58String, true, never>;
    } & TStorage;
}, {
    Revive: {
        call: TxDescriptor<{
            dest: ReviveAddress;
            value: bigint;
            gas_limit: Gas;
            storage_deposit_limit: bigint;
            data: Binary;
        }>;
        instantiate: TxDescriptor<{
            value: bigint;
            gas_limit: Gas;
            storage_deposit_limit: bigint;
            code_hash: FixedSizeBinary<32>;
            data: Binary;
            salt: FixedSizeBinary<32> | undefined;
        }>;
        instantiate_with_code: TxDescriptor<{
            value: bigint;
            gas_limit: Gas;
            storage_deposit_limit: bigint;
            code: Binary;
            data: Binary;
            salt: FixedSizeBinary<32> | undefined;
        }>;
    };
}, {}, {}, {
    Revive: {
        NativeToEthRatio: PlainDescriptor<number>;
    };
}, {}>;
type OldStorage = {
    ContractInfoOf: StorageDescriptor<[
        Key: ReviveAddress
    ], {
        code_hash: FixedSizeBinary<32>;
    }, true, never>;
};
type NewStorage = {
    AccountInfoOf: StorageDescriptor<[
        Key: FixedSizeBinary<20>
    ], {
        account_type: Enum<{
            Contract: {
                code_hash: FixedSizeBinary<32>;
            };
            EOA: undefined;
        }>;
    }, true, never>;
};
type ReviveSdkDefinition<TStorage> = SdkDefinition<ReviveSdkPallets<TStorage>, ReviveSdkApis>;
type ReviveSdkTypedApi = TypedApi<ReviveSdkDefinition<OldStorage | NewStorage>>;
type OldReviveSdkTypedApi = TypedApi<ReviveSdkDefinition<OldStorage>>;
type NewReviveSdkTypedApi = TypedApi<ReviveSdkDefinition<NewStorage>>;

type AnonymousEnum$2<T extends {}> = T & {
    __anonymous: true;
};
type MyTuple$2<T> = [T, ...T[]];
type SeparateUndefined$2<T> = undefined extends T ? undefined | Exclude<T, undefined> : T;
type Anonymize$2<T> = SeparateUndefined$2<T extends FixedSizeBinary<infer L> ? number extends L ? Binary : FixedSizeBinary<L> : T extends string | number | bigint | boolean | void | undefined | null | symbol | Uint8Array | Enum<any> ? T : T extends AnonymousEnum$2<infer V> ? Enum<V> : T extends MyTuple$2<any> ? {
    [K in keyof T]: T[K];
} : T extends [] ? [] : T extends FixedSizeArray<infer L, infer T> ? number extends L ? Array<T> : FixedSizeArray<L, T> : {
    [K in keyof T & string]: T[K];
}>;
type I5sesotjlssv2d = {
    "nonce": number;
    "consumers": number;
    "providers": number;
    "sufficients": number;
    "data": {
        "free": bigint;
        "reserved": bigint;
        "frozen": bigint;
        "flags": bigint;
    };
};
type I14i9pui8lc778 = {
    "account_type": Enum<{
        "Contract": {
            "trie_id": Binary;
            "code_hash": FixedSizeBinary<32>;
            "storage_bytes": number;
            "storage_items": number;
            "storage_byte_deposit": bigint;
            "storage_item_deposit": bigint;
            "storage_base_deposit": bigint;
            "immutable_data_len": number;
        };
        "EOA": undefined;
    }>;
    "dust": number;
};
type Idsg8aod8e8fqn = {
    "dest": FixedSizeBinary<20>;
    "value": bigint;
    "gas_limit": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit_limit": bigint;
    "data": Binary;
};
type I4q39t5hn830vp = {
    "ref_time": bigint;
    "proof_size": bigint;
};
type I46nktn22m6hbi = {
    "value": bigint;
    "gas_limit": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit_limit": bigint;
    "code_hash": FixedSizeBinary<32>;
    "data": Binary;
    "salt"?: Anonymize$2<I4s6vifaf8k998>;
};
type I4s6vifaf8k998 = (FixedSizeBinary<32>) | undefined;
type Ibgj1cthra7lte = {
    "value": bigint;
    "gas_limit": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit_limit": bigint;
    "code": Binary;
    "data": Binary;
    "salt"?: Anonymize$2<I4s6vifaf8k998>;
};
type I5o0s7c8q1cc9b = AnonymousEnum$2<{
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     */
    "InvalidSpecName": undefined;
    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     */
    "SpecVersionNeedsToIncrease": undefined;
    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     */
    "FailedToExtractRuntimeVersion": undefined;
    /**
     * Suicide called when the account has non-default composite data.
     */
    "NonDefaultComposite": undefined;
    /**
     * There is a non-zero reference count preventing the account from being purged.
     */
    "NonZeroRefCount": undefined;
    /**
     * The origin filter prevent the call to be dispatched.
     */
    "CallFiltered": undefined;
    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     */
    "MultiBlockMigrationsOngoing": undefined;
    /**
     * No upgrade authorized.
     */
    "NothingAuthorized": undefined;
    /**
     * The submitted code is not authorized.
     */
    "Unauthorized": undefined;
}>;
type Icjkr35j4tmg7k = AnonymousEnum$2<{
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     */
    "OverlappingUpgrades": undefined;
    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     */
    "ProhibitedByPolkadot": undefined;
    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     */
    "TooBig": undefined;
    /**
     * The inherent which supplies the validation data did not run this block.
     */
    "ValidationDataNotAvailable": undefined;
    /**
     * The inherent which supplies the host configuration did not run this block.
     */
    "HostConfigurationNotAvailable": undefined;
    /**
     * No validation function upgrade is currently scheduled.
     */
    "NotScheduled": undefined;
}>;
type Iaaqq5jevtahm8 = AnonymousEnum$2<{
    /**
     * The operation cannot complete since some MBMs are ongoing.
     */
    "Ongoing": undefined;
}>;
type I4cfhml1prt4lu = AnonymousEnum$2<{
    /**
     * Preimage is too large to store on-chain.
     */
    "TooBig": undefined;
    /**
     * Preimage has already been noted on-chain.
     */
    "AlreadyNoted": undefined;
    /**
     * The user is not authorized to perform this action.
     */
    "NotAuthorized": undefined;
    /**
     * The preimage cannot be removed since it has not yet been noted.
     */
    "NotNoted": undefined;
    /**
     * A preimage may not be removed when there are outstanding requests.
     */
    "Requested": undefined;
    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     */
    "NotRequested": undefined;
    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     */
    "TooMany": undefined;
    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     */
    "TooFew": undefined;
}>;
type If7oa8fprnilo5 = AnonymousEnum$2<{
    /**
     * Failed to schedule a call
     */
    "FailedToSchedule": undefined;
    /**
     * Cannot find the scheduled call.
     */
    "NotFound": undefined;
    /**
     * Given target block number is in the past.
     */
    "TargetBlockNumberInPast": undefined;
    /**
     * Reschedule failed because it does not change scheduled time.
     */
    "RescheduleNoChange": undefined;
    /**
     * Attempt to use a non-named function on a named task.
     */
    "Named": undefined;
}>;
type Iaug04qjhbli00 = AnonymousEnum$2<{
    /**
     * Sender must be the Sudo account.
     */
    "RequireSudo": undefined;
}>;
type Idj13i7adlomht = AnonymousEnum$2<{
    /**
     * Vesting balance too high to send value.
     */
    "VestingBalance": undefined;
    /**
     * Account liquidity restrictions prevent withdrawal.
     */
    "LiquidityRestrictions": undefined;
    /**
     * Balance too low to send value.
     */
    "InsufficientBalance": undefined;
    /**
     * Value too low to create account due to existential deposit.
     */
    "ExistentialDeposit": undefined;
    /**
     * Transfer/payment would kill account.
     */
    "Expendability": undefined;
    /**
     * A vesting schedule already exists for this account.
     */
    "ExistingVestingSchedule": undefined;
    /**
     * Beneficiary account must pre-exist.
     */
    "DeadAccount": undefined;
    /**
     * Number of named reserves exceed `MaxReserves`.
     */
    "TooManyReserves": undefined;
    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     */
    "TooManyHolds": undefined;
    /**
     * Number of freezes exceed `MaxFreezes`.
     */
    "TooManyFreezes": undefined;
    /**
     * The issuance cannot be modified since it is already deactivated.
     */
    "IssuanceDeactivated": undefined;
    /**
     * The delta cannot be zero.
     */
    "DeltaZero": undefined;
}>;
type Icof2acl69lq3c = AnonymousEnum$2<{
    /**
     * The account given is not vesting.
     */
    "NotVesting": undefined;
    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     */
    "AtMaxVestingSchedules": undefined;
    /**
     * Amount being transferred is too low to create a vesting schedule.
     */
    "AmountLow": undefined;
    /**
     * An index was out of bounds of the vesting schedules.
     */
    "ScheduleIndexOutOfBounds": undefined;
    /**
     * Failed to create a new schedule because some parameter was invalid.
     */
    "InvalidScheduleParams": undefined;
}>;
type I36bcffk2387dv = AnonymousEnum$2<{
    /**
     * The pallet has too many candidates.
     */
    "TooManyCandidates": undefined;
    /**
     * Leaving would result in too few candidates.
     */
    "TooFewEligibleCollators": undefined;
    /**
     * Account is already a candidate.
     */
    "AlreadyCandidate": undefined;
    /**
     * Account is not a candidate.
     */
    "NotCandidate": undefined;
    /**
     * There are too many Invulnerables.
     */
    "TooManyInvulnerables": undefined;
    /**
     * Account is already an Invulnerable.
     */
    "AlreadyInvulnerable": undefined;
    /**
     * Account is not an Invulnerable.
     */
    "NotInvulnerable": undefined;
    /**
     * Account has no associated validator ID.
     */
    "NoAssociatedValidatorId": undefined;
    /**
     * Validator ID is not yet registered.
     */
    "ValidatorNotRegistered": undefined;
    /**
     * Could not insert in the candidate list.
     */
    "InsertToCandidateListFailed": undefined;
    /**
     * Could not remove from the candidate list.
     */
    "RemoveFromCandidateListFailed": undefined;
    /**
     * New deposit amount would be below the minimum candidacy bond.
     */
    "DepositTooLow": undefined;
    /**
     * Could not update the candidate list.
     */
    "UpdateCandidateListFailed": undefined;
    /**
     * Deposit amount is too low to take the target's slot in the candidate list.
     */
    "InsufficientBond": undefined;
    /**
     * The target account to be replaced in the candidate list is not a candidate.
     */
    "TargetIsNotCandidate": undefined;
    /**
     * The updated deposit amount is equal to the amount already reserved.
     */
    "IdenticalDeposit": undefined;
    /**
     * Cannot lower candidacy bond while occupying a future collator slot in the list.
     */
    "InvalidUnreserve": undefined;
}>;
type I1e07dgbaqd1sq = AnonymousEnum$2<{
    /**
     * Invalid ownership proof.
     */
    "InvalidProof": undefined;
    /**
     * No associated validator ID for account.
     */
    "NoAssociatedValidatorId": undefined;
    /**
     * Registered duplicate key.
     */
    "DuplicatedKey": undefined;
    /**
     * No keys are associated with this account.
     */
    "NoKeys": undefined;
    /**
     * Key setting account is not live, so it's impossible to associate keys.
     */
    "NoAccount": undefined;
}>;
type Idnnbndsjjeqqs = AnonymousEnum$2<{
    /**
     * Setting the queue config failed since one of its values was invalid.
     */
    "BadQueueConfig": undefined;
    /**
     * The execution is already suspended.
     */
    "AlreadySuspended": undefined;
    /**
     * The execution is already resumed.
     */
    "AlreadyResumed": undefined;
    /**
     * There are too many active outbound channels.
     */
    "TooManyActiveOutboundChannels": undefined;
    /**
     * The message is too big.
     */
    "TooBig": undefined;
}>;
type I4vcvo9od6afmt = AnonymousEnum$2<{
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     */
    "Unreachable": undefined;
    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     */
    "SendFailure": undefined;
    /**
     * The message execution fails the filter.
     */
    "Filtered": undefined;
    /**
     * The message's weight could not be determined.
     */
    "UnweighableMessage": undefined;
    /**
     * The destination `Location` provided cannot be inverted.
     */
    "DestinationNotInvertible": undefined;
    /**
     * The assets to be sent are empty.
     */
    "Empty": undefined;
    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     */
    "CannotReanchor": undefined;
    /**
     * Too many assets have been attempted for transfer.
     */
    "TooManyAssets": undefined;
    /**
     * Origin is invalid for sending.
     */
    "InvalidOrigin": undefined;
    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     */
    "BadVersion": undefined;
    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     */
    "BadLocation": undefined;
    /**
     * The referenced subscription could not be found.
     */
    "NoSubscription": undefined;
    /**
     * The location is invalid since it already has a subscription from us.
     */
    "AlreadySubscribed": undefined;
    /**
     * Could not check-out the assets for teleportation to the destination chain.
     */
    "CannotCheckOutTeleport": undefined;
    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     */
    "LowBalance": undefined;
    /**
     * The asset owner has too many locks on the asset.
     */
    "TooManyLocks": undefined;
    /**
     * The given account is not an identifiable sovereign account for any location.
     */
    "AccountNotSovereign": undefined;
    /**
     * The operation required fees to be paid which the initiator could not meet.
     */
    "FeesNotMet": undefined;
    /**
     * A remote lock with the corresponding data could not be found.
     */
    "LockNotFound": undefined;
    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     */
    "InUse": undefined;
    /**
     * Invalid asset, reserve chain could not be determined for it.
     */
    "InvalidAssetUnknownReserve": undefined;
    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     */
    "InvalidAssetUnsupportedReserve": undefined;
    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     */
    "TooManyReserves": undefined;
    /**
     * Local XCM execution incomplete.
     */
    "LocalExecutionIncomplete": undefined;
    /**
     * Too many locations authorized to alias origin.
     */
    "TooManyAuthorizedAliases": undefined;
    /**
     * Expiry block number is in the past.
     */
    "ExpiresInPast": undefined;
    /**
     * The alias to remove authorization for was not found.
     */
    "AliasNotFound": undefined;
    /**
     * Local XCM execution incomplete with the actual XCM error and the index of the
     * instruction that caused the error.
     */
    "LocalExecutionIncompleteWithError": Anonymize$2<I5r8t4iaend96p>;
}>;
type I5r8t4iaend96p = {
    "index": number;
    "error": Enum<{
        "Overflow": undefined;
        "Unimplemented": undefined;
        "UntrustedReserveLocation": undefined;
        "UntrustedTeleportLocation": undefined;
        "LocationFull": undefined;
        "LocationNotInvertible": undefined;
        "BadOrigin": undefined;
        "InvalidLocation": undefined;
        "AssetNotFound": undefined;
        "FailedToTransactAsset": undefined;
        "NotWithdrawable": undefined;
        "LocationCannotHold": undefined;
        "ExceedsMaxMessageSize": undefined;
        "DestinationUnsupported": undefined;
        "Transport": undefined;
        "Unroutable": undefined;
        "UnknownClaim": undefined;
        "FailedToDecode": undefined;
        "MaxWeightInvalid": undefined;
        "NotHoldingFees": undefined;
        "TooExpensive": undefined;
        "Trap": undefined;
        "ExpectationFalse": undefined;
        "PalletNotFound": undefined;
        "NameMismatch": undefined;
        "VersionIncompatible": undefined;
        "HoldingWouldOverflow": undefined;
        "ExportError": undefined;
        "ReanchorFailed": undefined;
        "NoDeal": undefined;
        "FeesNotMet": undefined;
        "LockError": undefined;
        "NoPermission": undefined;
        "Unanchored": undefined;
        "NotDepositable": undefined;
        "TooManyAssets": undefined;
        "UnhandledXcmVersion": undefined;
        "WeightLimitReached": undefined;
        "Barrier": undefined;
        "WeightNotComputable": undefined;
        "ExceedsStackLimit": undefined;
    }>;
};
type I5iupade5ag2dp = AnonymousEnum$2<{
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     */
    "NotReapable": undefined;
    /**
     * Page to be reaped does not exist.
     */
    "NoPage": undefined;
    /**
     * The referenced message could not be found.
     */
    "NoMessage": undefined;
    /**
     * The message was already processed and cannot be processed again.
     */
    "AlreadyProcessed": undefined;
    /**
     * The message is queued for future execution.
     */
    "Queued": undefined;
    /**
     * There is temporarily not enough weight to continue servicing messages.
     */
    "InsufficientWeight": undefined;
    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     */
    "TemporarilyUnprocessable": undefined;
    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     */
    "QueuePaused": undefined;
    /**
     * Another call is in progress and needs to finish before this call can happen.
     */
    "RecursiveDisallowed": undefined;
}>;
type Idqkarp7hi55vf = AnonymousEnum$2<{
    /**
     * Convert versioned location failure
     */
    "UnsupportedLocationVersion": undefined;
    /**
     * Check location failure, should start from the dispatch origin as owner
     */
    "InvalidAssetOwner": undefined;
    /**
     * Send xcm message failure
     */
    "SendFailure": undefined;
    /**
     * Withdraw fee asset failure
     */
    "FeesNotMet": undefined;
    /**
     * Convert to reanchored location failure
     */
    "LocationConversionFailed": undefined;
    /**
     * Message export is halted
     */
    "Halted": undefined;
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     */
    "Unreachable": undefined;
    /**
     * The asset provided for the tip is unsupported.
     */
    "UnsupportedAsset": undefined;
    /**
     * Unable to withdraw asset.
     */
    "WithdrawError": undefined;
    /**
     * Account could not be converted to a location.
     */
    "InvalidAccount": undefined;
    /**
     * Provided tip asset could not be swapped for ether.
     */
    "SwapError": undefined;
    /**
     * Ether could not be burned.
     */
    "BurnError": undefined;
    /**
     * The tip provided is zero.
     */
    "TipAmountZero": undefined;
}>;
type I8dt2g2hcrgh36 = AnonymousEnum$2<{
    /**
     * Too many calls batched.
     */
    "TooManyCalls": undefined;
}>;
type Ia76qmhhg4jvb9 = AnonymousEnum$2<{
    /**
     * Threshold must be 2 or greater.
     */
    "MinimumThreshold": undefined;
    /**
     * Call is already approved by this signatory.
     */
    "AlreadyApproved": undefined;
    /**
     * Call doesn't need any (more) approvals.
     */
    "NoApprovalsNeeded": undefined;
    /**
     * There are too few signatories in the list.
     */
    "TooFewSignatories": undefined;
    /**
     * There are too many signatories in the list.
     */
    "TooManySignatories": undefined;
    /**
     * The signatories were provided out of order; they should be ordered.
     */
    "SignatoriesOutOfOrder": undefined;
    /**
     * The sender was contained in the other signatories; it shouldn't be.
     */
    "SenderInSignatories": undefined;
    /**
     * Multisig operation not found in storage.
     */
    "NotFound": undefined;
    /**
     * Only the account that originally created the multisig is able to cancel it or update
     * its deposits.
     */
    "NotOwner": undefined;
    /**
     * No timepoint was given, yet the multisig operation is already underway.
     */
    "NoTimepoint": undefined;
    /**
     * A different timepoint was given to the multisig operation that is underway.
     */
    "WrongTimepoint": undefined;
    /**
     * A timepoint was given, yet no multisig operation is underway.
     */
    "UnexpectedTimepoint": undefined;
    /**
     * The maximum weight information provided was too low.
     */
    "MaxWeightTooLow": undefined;
    /**
     * The data to be stored is already stored.
     */
    "AlreadyStored": undefined;
}>;
type Iuvt54ei4cehc = AnonymousEnum$2<{
    /**
     * There are too many proxies registered or too many announcements pending.
     */
    "TooMany": undefined;
    /**
     * Proxy registration not found.
     */
    "NotFound": undefined;
    /**
     * Sender is not a proxy of the account to be proxied.
     */
    "NotProxy": undefined;
    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     */
    "Unproxyable": undefined;
    /**
     * Account is already a proxy.
     */
    "Duplicate": undefined;
    /**
     * Call may not be made by proxy because it may escalate its privileges.
     */
    "NoPermission": undefined;
    /**
     * Announcement, if made at all, was made too recently.
     */
    "Unannounced": undefined;
    /**
     * Cannot add self as proxy.
     */
    "NoSelfProxy": undefined;
}>;
type Icq1825fru3di2 = AnonymousEnum$2<{
    /**
     * The index was not already assigned.
     */
    "NotAssigned": undefined;
    /**
     * The index is assigned to another account.
     */
    "NotOwner": undefined;
    /**
     * The index was not available.
     */
    "InUse": undefined;
    /**
     * The source and destination accounts are identical.
     */
    "NotTransfer": undefined;
    /**
     * The index is permanent and may not be freed/changed.
     */
    "Permanent": undefined;
}>;
type Ieqmcndp78shme = AnonymousEnum$2<{
    /**
     * Account balance must be greater than or equal to the transfer amount.
     */
    "BalanceLow": undefined;
    /**
     * The account to alter does not exist.
     */
    "NoAccount": undefined;
    /**
     * The signing account has no permission to do the operation.
     */
    "NoPermission": undefined;
    /**
     * The given asset ID is unknown.
     */
    "Unknown": undefined;
    /**
     * The origin account is frozen.
     */
    "Frozen": undefined;
    /**
     * The asset ID is already taken.
     */
    "InUse": undefined;
    /**
     * Invalid witness data given.
     */
    "BadWitness": undefined;
    /**
     * Minimum balance should be non-zero.
     */
    "MinBalanceZero": undefined;
    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     */
    "UnavailableConsumer": undefined;
    /**
     * Invalid metadata given.
     */
    "BadMetadata": undefined;
    /**
     * No approval exists that would allow the transfer.
     */
    "Unapproved": undefined;
    /**
     * The source account would not survive the transfer and it needs to stay alive.
     */
    "WouldDie": undefined;
    /**
     * The asset-account already exists.
     */
    "AlreadyExists": undefined;
    /**
     * The asset-account doesn't have an associated deposit.
     */
    "NoDeposit": undefined;
    /**
     * The operation would result in funds being burned.
     */
    "WouldBurn": undefined;
    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     */
    "LiveAsset": undefined;
    /**
     * The asset is not live, and likely being destroyed.
     */
    "AssetNotLive": undefined;
    /**
     * The asset status is not the expected status.
     */
    "IncorrectStatus": undefined;
    /**
     * The asset should be frozen before the given operation.
     */
    "NotFrozen": undefined;
    /**
     * Callback action resulted in error
     */
    "CallbackFailed": undefined;
    /**
     * The asset ID must be equal to the [`NextAssetId`].
     */
    "BadAssetId": undefined;
    /**
     * The asset cannot be destroyed because some accounts for this asset contain freezes.
     */
    "ContainsFreezes": undefined;
    /**
     * The asset cannot be destroyed because some accounts for this asset contain holds.
     */
    "ContainsHolds": undefined;
}>;
type Ie9ou99obd2hgv = AnonymousEnum$2<{
    /**
     * The signing account has no permission to do the operation.
     */
    "NoPermission": undefined;
    /**
     * The given item ID is unknown.
     */
    "UnknownCollection": undefined;
    /**
     * The item ID has already been used for an item.
     */
    "AlreadyExists": undefined;
    /**
     * The owner turned out to be different to what was expected.
     */
    "WrongOwner": undefined;
    /**
     * Invalid witness data given.
     */
    "BadWitness": undefined;
    /**
     * The item ID is already taken.
     */
    "InUse": undefined;
    /**
     * The item or collection is frozen.
     */
    "Frozen": undefined;
    /**
     * The delegate turned out to be different to what was expected.
     */
    "WrongDelegate": undefined;
    /**
     * There is no delegate approved.
     */
    "NoDelegate": undefined;
    /**
     * No approval exists that would allow the transfer.
     */
    "Unapproved": undefined;
    /**
     * The named owner has not signed ownership of the collection is acceptable.
     */
    "Unaccepted": undefined;
    /**
     * The item is locked.
     */
    "Locked": undefined;
    /**
     * All items have been minted.
     */
    "MaxSupplyReached": undefined;
    /**
     * The max supply has already been set.
     */
    "MaxSupplyAlreadySet": undefined;
    /**
     * The provided max supply is less to the amount of items a collection already has.
     */
    "MaxSupplyTooSmall": undefined;
    /**
     * The given item ID is unknown.
     */
    "UnknownItem": undefined;
    /**
     * Item is not for sale.
     */
    "NotForSale": undefined;
    /**
     * The provided bid is too low.
     */
    "BidTooLow": undefined;
    /**
     * No metadata is found.
     */
    "NoMetadata": undefined;
    /**
     * Wrong metadata key/value bytes supplied.
     */
    "WrongMetadata": undefined;
    /**
     * An attribute is not found.
     */
    "AttributeNotFound": undefined;
    /**
     * Wrong attribute key/value bytes supplied.
     */
    "WrongAttribute": undefined;
}>;
type I58r1150kmj18u = AnonymousEnum$2<{
    /**
     * The signing account has no permission to do the operation.
     */
    "NoPermission": undefined;
    /**
     * The given item ID is unknown.
     */
    "UnknownCollection": undefined;
    /**
     * The item ID has already been used for an item.
     */
    "AlreadyExists": undefined;
    /**
     * The approval had a deadline that expired, so the approval isn't valid anymore.
     */
    "ApprovalExpired": undefined;
    /**
     * The owner turned out to be different to what was expected.
     */
    "WrongOwner": undefined;
    /**
     * The witness data given does not match the current state of the chain.
     */
    "BadWitness": undefined;
    /**
     * Collection ID is already taken.
     */
    "CollectionIdInUse": undefined;
    /**
     * Items within that collection are non-transferable.
     */
    "ItemsNonTransferable": undefined;
    /**
     * The provided account is not a delegate.
     */
    "NotDelegate": undefined;
    /**
     * The delegate turned out to be different to what was expected.
     */
    "WrongDelegate": undefined;
    /**
     * No approval exists that would allow the transfer.
     */
    "Unapproved": undefined;
    /**
     * The named owner has not signed ownership acceptance of the collection.
     */
    "Unaccepted": undefined;
    /**
     * The item is locked (non-transferable).
     */
    "ItemLocked": undefined;
    /**
     * Item's attributes are locked.
     */
    "LockedItemAttributes": undefined;
    /**
     * Collection's attributes are locked.
     */
    "LockedCollectionAttributes": undefined;
    /**
     * Item's metadata is locked.
     */
    "LockedItemMetadata": undefined;
    /**
     * Collection's metadata is locked.
     */
    "LockedCollectionMetadata": undefined;
    /**
     * All items have been minted.
     */
    "MaxSupplyReached": undefined;
    /**
     * The max supply is locked and can't be changed.
     */
    "MaxSupplyLocked": undefined;
    /**
     * The provided max supply is less than the number of items a collection already has.
     */
    "MaxSupplyTooSmall": undefined;
    /**
     * The given item ID is unknown.
     */
    "UnknownItem": undefined;
    /**
     * Swap doesn't exist.
     */
    "UnknownSwap": undefined;
    /**
     * The given item has no metadata set.
     */
    "MetadataNotFound": undefined;
    /**
     * The provided attribute can't be found.
     */
    "AttributeNotFound": undefined;
    /**
     * Item is not for sale.
     */
    "NotForSale": undefined;
    /**
     * The provided bid is too low.
     */
    "BidTooLow": undefined;
    /**
     * The item has reached its approval limit.
     */
    "ReachedApprovalLimit": undefined;
    /**
     * The deadline has already expired.
     */
    "DeadlineExpired": undefined;
    /**
     * The duration provided should be less than or equal to `MaxDeadlineDuration`.
     */
    "WrongDuration": undefined;
    /**
     * The method is disabled by system settings.
     */
    "MethodDisabled": undefined;
    /**
     * The provided setting can't be set.
     */
    "WrongSetting": undefined;
    /**
     * Item's config already exists and should be equal to the provided one.
     */
    "InconsistentItemConfig": undefined;
    /**
     * Config for a collection or an item can't be found.
     */
    "NoConfig": undefined;
    /**
     * Some roles were not cleared.
     */
    "RolesNotCleared": undefined;
    /**
     * Mint has not started yet.
     */
    "MintNotStarted": undefined;
    /**
     * Mint has already ended.
     */
    "MintEnded": undefined;
    /**
     * The provided Item was already used for claiming.
     */
    "AlreadyClaimed": undefined;
    /**
     * The provided data is incorrect.
     */
    "IncorrectData": undefined;
    /**
     * The extrinsic was sent by the wrong origin.
     */
    "WrongOrigin": undefined;
    /**
     * The provided signature is incorrect.
     */
    "WrongSignature": undefined;
    /**
     * The provided metadata might be too long.
     */
    "IncorrectMetadata": undefined;
    /**
     * Can't set more attributes per one call.
     */
    "MaxAttributesLimitReached": undefined;
    /**
     * The provided namespace isn't supported in this call.
     */
    "WrongNamespace": undefined;
    /**
     * Can't delete non-empty collections.
     */
    "CollectionNotEmpty": undefined;
    /**
     * The witness data should be provided.
     */
    "WitnessRequired": undefined;
}>;
type Ib24bvufha821j = AnonymousEnum$2<{
    /**
     * Asset ID does not correspond to locked NFT.
     */
    "IncorrectAssetId": undefined;
    /**
     * The signing account has no permission to do the operation.
     */
    "NoPermission": undefined;
    /**
     * NFT doesn't exist.
     */
    "NftNotFound": undefined;
    /**
     * NFT has not yet been fractionalised.
     */
    "NftNotFractionalized": undefined;
}>;
type I4u78hb23uhvi2 = AnonymousEnum$2<{
    /**
     * Provided asset pair is not supported for pool.
     */
    "InvalidAssetPair": undefined;
    /**
     * Pool already exists.
     */
    "PoolExists": undefined;
    /**
     * Desired amount can't be zero.
     */
    "WrongDesiredAmount": undefined;
    /**
     * Provided amount should be greater than or equal to the existential deposit/asset's
     * minimal amount.
     */
    "AmountOneLessThanMinimal": undefined;
    /**
     * Provided amount should be greater than or equal to the existential deposit/asset's
     * minimal amount.
     */
    "AmountTwoLessThanMinimal": undefined;
    /**
     * Reserve needs to always be greater than or equal to the existential deposit/asset's
     * minimal amount.
     */
    "ReserveLeftLessThanMinimal": undefined;
    /**
     * Desired amount can't be equal to the pool reserve.
     */
    "AmountOutTooHigh": undefined;
    /**
     * The pool doesn't exist.
     */
    "PoolNotFound": undefined;
    /**
     * An overflow happened.
     */
    "Overflow": undefined;
    /**
     * The minimal amount requirement for the first token in the pair wasn't met.
     */
    "AssetOneDepositDidNotMeetMinimum": undefined;
    /**
     * The minimal amount requirement for the second token in the pair wasn't met.
     */
    "AssetTwoDepositDidNotMeetMinimum": undefined;
    /**
     * The minimal amount requirement for the first token in the pair wasn't met.
     */
    "AssetOneWithdrawalDidNotMeetMinimum": undefined;
    /**
     * The minimal amount requirement for the second token in the pair wasn't met.
     */
    "AssetTwoWithdrawalDidNotMeetMinimum": undefined;
    /**
     * Optimal calculated amount is less than desired.
     */
    "OptimalAmountLessThanDesired": undefined;
    /**
     * Insufficient liquidity minted.
     */
    "InsufficientLiquidityMinted": undefined;
    /**
     * Requested liquidity can't be zero.
     */
    "ZeroLiquidity": undefined;
    /**
     * Amount can't be zero.
     */
    "ZeroAmount": undefined;
    /**
     * Calculated amount out is less than provided minimum amount.
     */
    "ProvidedMinimumNotSufficientForSwap": undefined;
    /**
     * Provided maximum amount is not sufficient for swap.
     */
    "ProvidedMaximumNotSufficientForSwap": undefined;
    /**
     * The provided path must consists of 2 assets at least.
     */
    "InvalidPath": undefined;
    /**
     * The provided path must consists of unique assets.
     */
    "NonUniquePath": undefined;
    /**
     * It was not possible to get or increment the Id of the pool.
     */
    "IncorrectPoolAssetId": undefined;
    /**
     * The destination account cannot exist with the swapped funds.
     */
    "BelowMinimum": undefined;
}>;
type I4dd4ctqfnk5kr = AnonymousEnum$2<{
    /**
     * Number of freezes on an account would exceed `MaxFreezes`.
     */
    "TooManyFreezes": undefined;
}>;
type Id1qlto7be0ig7 = AnonymousEnum$2<{
    /**
     * Invalid schedule supplied, e.g. with zero weight of a basic operation.
     */
    "InvalidSchedule": undefined;
    /**
     * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
     */
    "InvalidCallFlags": undefined;
    /**
     * The executed contract exhausted its gas limit.
     */
    "OutOfGas": undefined;
    /**
     * Performing the requested transfer failed. Probably because there isn't enough
     * free balance in the sender's account.
     */
    "TransferFailed": undefined;
    /**
     * Performing a call was denied because the calling depth reached the limit
     * of what is specified in the schedule.
     */
    "MaxCallDepthReached": undefined;
    /**
     * No contract was found at the specified address.
     */
    "ContractNotFound": undefined;
    /**
     * No code could be found at the supplied code hash.
     */
    "CodeNotFound": undefined;
    /**
     * No code info could be found at the supplied code hash.
     */
    "CodeInfoNotFound": undefined;
    /**
     * A buffer outside of sandbox memory was passed to a contract API function.
     */
    "OutOfBounds": undefined;
    /**
     * Input passed to a contract API function failed to decode as expected type.
     */
    "DecodingFailed": undefined;
    /**
     * Contract trapped during execution.
     */
    "ContractTrapped": undefined;
    /**
     * Event body or storage item exceeds [`limits::PAYLOAD_BYTES`].
     */
    "ValueTooLarge": undefined;
    /**
     * Termination of a contract is not allowed while the contract is already
     * on the call stack. Can be triggered by `seal_terminate`.
     */
    "TerminatedWhileReentrant": undefined;
    /**
     * `seal_call` forwarded this contracts input. It therefore is no longer available.
     */
    "InputForwarded": undefined;
    /**
     * The amount of topics passed to `seal_deposit_events` exceeds the limit.
     */
    "TooManyTopics": undefined;
    /**
     * A contract with the same AccountId already exists.
     */
    "DuplicateContract": undefined;
    /**
     * A contract self destructed in its constructor.
     *
     * This can be triggered by a call to `seal_terminate`.
     */
    "TerminatedInConstructor": undefined;
    /**
     * A call tried to invoke a contract that is flagged as non-reentrant.
     */
    "ReentranceDenied": undefined;
    /**
     * A contract called into the runtime which then called back into this pallet.
     */
    "ReenteredPallet": undefined;
    /**
     * A contract attempted to invoke a state modifying API while being in read-only mode.
     */
    "StateChangeDenied": undefined;
    /**
     * Origin doesn't have enough balance to pay the required storage deposits.
     */
    "StorageDepositNotEnoughFunds": undefined;
    /**
     * More storage was created than allowed by the storage deposit limit.
     */
    "StorageDepositLimitExhausted": undefined;
    /**
     * Code removal was denied because the code is still in use by at least one contract.
     */
    "CodeInUse": undefined;
    /**
     * The contract ran to completion but decided to revert its storage changes.
     * Please note that this error is only returned from extrinsics. When called directly
     * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
     * to determine whether a reversion has taken place.
     */
    "ContractReverted": undefined;
    /**
     * The contract failed to compile or is missing the correct entry points.
     *
     * A more detailed error can be found on the node console if debug messages are enabled
     * by supplying `-lruntime::revive=debug`.
     */
    "CodeRejected": undefined;
    /**
     * The code blob supplied is larger than [`limits::code::BLOB_BYTES`].
     */
    "BlobTooLarge": undefined;
    /**
     * The contract declares too much memory (ro + rw + stack).
     */
    "StaticMemoryTooLarge": undefined;
    /**
     * The program contains a basic block that is larger than allowed.
     */
    "BasicBlockTooLarge": undefined;
    /**
     * The program contains an invalid instruction.
     */
    "InvalidInstruction": undefined;
    /**
     * The contract has reached its maximum number of delegate dependencies.
     */
    "MaxDelegateDependenciesReached": undefined;
    /**
     * The dependency was not found in the contract's delegate dependencies.
     */
    "DelegateDependencyNotFound": undefined;
    /**
     * The contract already depends on the given delegate dependency.
     */
    "DelegateDependencyAlreadyExists": undefined;
    /**
     * Can not add a delegate dependency to the code hash of the contract itself.
     */
    "CannotAddSelfAsDelegateDependency": undefined;
    /**
     * Can not add more data to transient storage.
     */
    "OutOfTransientStorage": undefined;
    /**
     * The contract tried to call a syscall which does not exist (at its current api level).
     */
    "InvalidSyscall": undefined;
    /**
     * Invalid storage flags were passed to one of the storage syscalls.
     */
    "InvalidStorageFlags": undefined;
    /**
     * PolkaVM failed during code execution. Probably due to a malformed program.
     */
    "ExecutionFailed": undefined;
    /**
     * Failed to convert a U256 to a Balance.
     */
    "BalanceConversionFailed": undefined;
    /**
     * Immutable data can only be set during deploys and only be read during calls.
     * Additionally, it is only valid to set the data once and it must not be empty.
     */
    "InvalidImmutableAccess": undefined;
    /**
     * An `AccountID32` account tried to interact with the pallet without having a mapping.
     *
     * Call [`Pallet::map_account`] in order to create a mapping for the account.
     */
    "AccountUnmapped": undefined;
    /**
     * Tried to map an account that is already mapped.
     */
    "AccountAlreadyMapped": undefined;
    /**
     * The transaction used to dry-run a contract is invalid.
     */
    "InvalidGenericTransaction": undefined;
    /**
     * The refcount of a code either over or underflowed.
     */
    "RefcountOverOrUnderflow": undefined;
    /**
     * Unsupported precompile address.
     */
    "UnsupportedPrecompileAddress": undefined;
    /**
     * The calldata exceeds [`limits::CALLDATA_BYTES`].
     */
    "CallDataTooLarge": undefined;
    /**
     * The return data exceeds [`limits::CALLDATA_BYTES`].
     */
    "ReturnDataTooLarge": undefined;
}>;
type I1vqs5qaqr6h6 = AnonymousEnum$2<{
    /**
     * The staker does not have enough tokens to perform the operation.
     */
    "NotEnoughTokens": undefined;
    /**
     * An operation was attempted on a non-existent pool.
     */
    "NonExistentPool": undefined;
    /**
     * An operation was attempted for a non-existent staker.
     */
    "NonExistentStaker": undefined;
    /**
     * An operation was attempted with a non-existent asset.
     */
    "NonExistentAsset": undefined;
    /**
     * There was an error converting a block number.
     */
    "BlockNumberConversionError": undefined;
    /**
     * The expiry block must be in the future.
     */
    "ExpiryBlockMustBeInTheFuture": undefined;
    /**
     * Insufficient funds to create the freeze.
     */
    "InsufficientFunds": undefined;
    /**
     * The expiry block can be only extended.
     */
    "ExpiryCut": undefined;
    /**
     * The reward rate per block can be only increased.
     */
    "RewardRateCut": undefined;
    /**
     * The pool still has staked tokens or rewards.
     */
    "NonEmptyPool": undefined;
}>;
type I96objte63brjr = AnonymousEnum$2<{
    /**
     * Max signed limits not respected.
     */
    "MaxSignedLimits": undefined;
    /**
     * A key was longer than the configured maximum.
     *
     * This means that the migration halted at the current [`Progress`] and
     * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
     * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
     * The value should only be increased to avoid a storage migration for the currently
     * stored [`crate::Progress::LastKey`].
     */
    "KeyTooLong": undefined;
    /**
     * submitter does not have enough funds.
     */
    "NotEnoughFunds": undefined;
    /**
     * Bad witness data provided.
     */
    "BadWitness": undefined;
    /**
     * Signed migration is not allowed because the maximum limit is not set yet.
     */
    "SignedMigrationNotAllowed": undefined;
    /**
     * Bad child root provided.
     */
    "BadChildRoot": undefined;
}>;
type Icftpn34uf5f21 = AnonymousEnum$2<{
    /**
     * Not a controller account.
     */
    "NotController": undefined;
    /**
     * Not a stash account.
     */
    "NotStash": undefined;
    /**
     * Stash is already bonded.
     */
    "AlreadyBonded": undefined;
    /**
     * Controller is already paired.
     */
    "AlreadyPaired": undefined;
    /**
     * Targets cannot be empty.
     */
    "EmptyTargets": undefined;
    /**
     * Duplicate index.
     */
    "DuplicateIndex": undefined;
    /**
     * Slash record not found.
     */
    "InvalidSlashRecord": undefined;
    /**
     * Cannot bond, nominate or validate with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     */
    "InsufficientBond": undefined;
    /**
     * Can not schedule more unlock chunks.
     */
    "NoMoreChunks": undefined;
    /**
     * Can not rebond without unlocking chunks.
     */
    "NoUnlockChunk": undefined;
    /**
     * Attempting to target a stash that still has funds.
     */
    "FundedTarget": undefined;
    /**
     * Invalid era to reward.
     */
    "InvalidEraToReward": undefined;
    /**
     * Invalid number of nominations.
     */
    "InvalidNumberOfNominations": undefined;
    /**
     * Rewards for this era have already been claimed for this validator.
     */
    "AlreadyClaimed": undefined;
    /**
     * No nominators exist on this page.
     */
    "InvalidPage": undefined;
    /**
     * Incorrect previous history depth input provided.
     */
    "IncorrectHistoryDepth": undefined;
    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     */
    "BadState": undefined;
    /**
     * Too many nomination targets supplied.
     */
    "TooManyTargets": undefined;
    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     */
    "BadTarget": undefined;
    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     */
    "CannotChillOther": undefined;
    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     */
    "TooManyNominators": undefined;
    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     */
    "TooManyValidators": undefined;
    /**
     * Commission is too low. Must be at least `MinCommission`.
     */
    "CommissionTooLow": undefined;
    /**
     * Some bound is not met.
     */
    "BoundNotMet": undefined;
    /**
     * Used when attempting to use deprecated controller account logic.
     */
    "ControllerDeprecated": undefined;
    /**
     * Cannot reset a ledger.
     */
    "CannotRestoreLedger": undefined;
    /**
     * Provided reward destination is not allowed.
     */
    "RewardDestinationRestricted": undefined;
    /**
     * Not enough funds available to withdraw.
     */
    "NotEnoughFunds": undefined;
    /**
     * Operation not allowed for virtual stakers.
     */
    "VirtualStakerNotAllowed": undefined;
    /**
     * Stash could not be reaped as other pallet might depend on it.
     */
    "CannotReapStash": undefined;
    /**
     * The stake of this account is already migrated to `Fungible` holds.
     */
    "AlreadyMigrated": undefined;
    /**
     * Era not yet started.
     */
    "EraNotStarted": undefined;
    /**
     * Account is restricted from participation in staking. This may happen if the account is
     * staking in another way already, such as via pool.
     */
    "Restricted": undefined;
    /**
     * Unapplied slashes in the recently concluded era is blocking this operation.
     * See `Call::apply_slash` to apply them.
     */
    "UnappliedSlashesInPreviousEra": undefined;
    /**
     * The era is not eligible for pruning.
     */
    "EraNotPrunable": undefined;
    /**
     * The slash has been cancelled and cannot be applied.
     */
    "CancelledSlash": undefined;
}>;
type Iuudu4kursojc = AnonymousEnum$2<{
    /**
     * A (bonded) pool id does not exist.
     */
    "PoolNotFound": undefined;
    /**
     * An account is not a member.
     */
    "PoolMemberNotFound": undefined;
    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     */
    "RewardPoolNotFound": undefined;
    /**
     * A sub pool does not exist.
     */
    "SubPoolsNotFound": undefined;
    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     */
    "AccountBelongsToOtherPool": undefined;
    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     */
    "FullyUnbonding": undefined;
    /**
     * The member cannot unbond further chunks due to reaching the limit.
     */
    "MaxUnbondingLimit": undefined;
    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     */
    "CannotWithdrawAny": undefined;
    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
     * caller does not have nominating permissions for the pool. Members can never unbond to a
     * value below `MinJoinBond`.
     */
    "MinimumBondNotMet": undefined;
    /**
     * The transaction could not be executed due to overflow risk for the pool.
     */
    "OverflowRisk": undefined;
    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     */
    "NotDestroying": undefined;
    /**
     * The caller does not have nominating permissions for the pool.
     */
    "NotNominator": undefined;
    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     */
    "NotKickerOrDestroying": undefined;
    /**
     * The pool is not open to join
     */
    "NotOpen": undefined;
    /**
     * The system is maxed out on pools.
     */
    "MaxPools": undefined;
    /**
     * Too many members in the pool or system.
     */
    "MaxPoolMembers": undefined;
    /**
     * The pools state cannot be changed.
     */
    "CanNotChangeState": undefined;
    /**
     * The caller does not have adequate permissions.
     */
    "DoesNotHavePermission": undefined;
    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     */
    "MetadataExceedsMaxLen": undefined;
    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     */
    "Defensive": Anonymize$2<Ie2db4l6126rkt>;
    /**
     * Partial unbonding now allowed permissionlessly.
     */
    "PartialUnbondNotAllowedPermissionlessly": undefined;
    /**
     * The pool's max commission cannot be set higher than the existing value.
     */
    "MaxCommissionRestricted": undefined;
    /**
     * The supplied commission exceeds the max allowed commission.
     */
    "CommissionExceedsMaximum": undefined;
    /**
     * The supplied commission exceeds global maximum commission.
     */
    "CommissionExceedsGlobalMaximum": undefined;
    /**
     * Not enough blocks have surpassed since the last commission update.
     */
    "CommissionChangeThrottled": undefined;
    /**
     * The submitted changes to commission change rate are not allowed.
     */
    "CommissionChangeRateNotAllowed": undefined;
    /**
     * There is no pending commission to claim.
     */
    "NoPendingCommission": undefined;
    /**
     * No commission current has been set.
     */
    "NoCommissionCurrentSet": undefined;
    /**
     * Pool id currently in use.
     */
    "PoolIdInUse": undefined;
    /**
     * Pool id provided is not correct/usable.
     */
    "InvalidPoolId": undefined;
    /**
     * Bonding extra is restricted to the exact pending reward amount.
     */
    "BondExtraRestricted": undefined;
    /**
     * No imbalance in the ED deposit for the pool.
     */
    "NothingToAdjust": undefined;
    /**
     * No slash pending that can be applied to the member.
     */
    "NothingToSlash": undefined;
    /**
     * The slash amount is too low to be applied.
     */
    "SlashTooLow": undefined;
    /**
     * The pool or member delegation has already migrated to delegate stake.
     */
    "AlreadyMigrated": undefined;
    /**
     * The pool or member delegation has not migrated yet to delegate stake.
     */
    "NotMigrated": undefined;
    /**
     * This call is not allowed in the current state of the pallet.
     */
    "NotSupported": undefined;
    /**
     * Account is restricted from participation in pools. This may happen if the account is
     * staking in another way already.
     */
    "Restricted": undefined;
}>;
type Ie2db4l6126rkt = AnonymousEnum$2<{
    "NotEnoughSpaceInUnbondPool": undefined;
    "PoolNotFound": undefined;
    "RewardPoolNotFound": undefined;
    "SubPoolsNotFound": undefined;
    "BondedStashKilledPrematurely": undefined;
    "DelegationUnsupported": undefined;
    "SlashNotApplied": undefined;
}>;
type Iau9bur8dc3bec = AnonymousEnum$2<{
    /**
     * The provided Controller account was not found.
     *
     * This means that the given account is not bonded.
     */
    "NotController": undefined;
    /**
     * The bonded account has already been queued.
     */
    "AlreadyQueued": undefined;
    /**
     * The bonded account has active unlocking chunks.
     */
    "NotFullyBonded": undefined;
    /**
     * The provided un-staker is not in the `Queue`.
     */
    "NotQueued": undefined;
    /**
     * The provided un-staker is already in Head, and cannot deregister.
     */
    "AlreadyHead": undefined;
    /**
     * The call is not allowed at this point because the pallet is not active.
     */
    "CallNotAllowed": undefined;
}>;
type I2e4fekrkcdej2 = AnonymousEnum$2<{
    /**
     * A error in the list interface implementation.
     */
    "List": Anonymize$2<Ictkqqlhdjt761>;
    /**
     * Could not update a node, because the pallet is locked.
     */
    "Locked": undefined;
}>;
type Ictkqqlhdjt761 = AnonymousEnum$2<{
    "Duplicate": undefined;
    "NotHeavier": undefined;
    "NotInSameBag": undefined;
    "NodeNotFound": undefined;
    "Locked": undefined;
}>;
type Iaogv3iimefnis = AnonymousEnum$2<{
    /**
     * The account cannot perform this operation.
     */
    "NotAllowed": undefined;
    /**
     * An existing staker cannot perform this action.
     */
    "AlreadyStaking": undefined;
    /**
     * Reward Destination cannot be same as `Agent` account.
     */
    "InvalidRewardDestination": undefined;
    /**
     * Delegation conditions are not met.
     *
     * Possible issues are
     * 1) Cannot delegate to self,
     * 2) Cannot delegate to multiple delegates.
     */
    "InvalidDelegation": undefined;
    /**
     * The account does not have enough funds to perform the operation.
     */
    "NotEnoughFunds": undefined;
    /**
     * Not an existing `Agent` account.
     */
    "NotAgent": undefined;
    /**
     * Not a Delegator account.
     */
    "NotDelegator": undefined;
    /**
     * Some corruption in internal state.
     */
    "BadState": undefined;
    /**
     * Unapplied pending slash restricts operation on `Agent`.
     */
    "UnappliedSlash": undefined;
    /**
     * `Agent` has no pending slash to be applied.
     */
    "NothingToSlash": undefined;
    /**
     * Failed to withdraw amount from Core Staking.
     */
    "WithdrawFailed": undefined;
    /**
     * Operation not supported by this pallet.
     */
    "NotSupported": undefined;
}>;
type I6gonitoaqpiua = AnonymousEnum$2<{
    /**
     * Triggering the `Fallback` failed.
     */
    "Fallback": undefined;
    /**
     * Unexpected phase
     */
    "UnexpectedPhase": undefined;
    /**
     * Snapshot was unavailable.
     */
    "Snapshot": undefined;
}>;
type I9i66md365gdq9 = AnonymousEnum$2<{
    /**
     * The phase is not signed.
     */
    "PhaseNotSigned": undefined;
    /**
     * The submission is a duplicate.
     */
    "Duplicate": undefined;
    /**
     * The queue is full.
     */
    "QueueFull": undefined;
    /**
     * The page index is out of bounds.
     */
    "BadPageIndex": undefined;
    /**
     * The account is not registered.
     */
    "NotRegistered": undefined;
    /**
     * No submission found.
     */
    "NoSubmission": undefined;
    /**
     * Round is not yet over.
     */
    "RoundNotOver": undefined;
    /**
     * Bad witness data provided.
     */
    "BadWitnessData": undefined;
    /**
     * Too many invulnerable accounts are provided,
     */
    "TooManyInvulnerables": undefined;
}>;
type Idfa8k8ikssbsf = AnonymousEnum$2<{
    /**
     * Poll is not ongoing.
     */
    "NotOngoing": undefined;
    /**
     * The given account did not vote on the poll.
     */
    "NotVoter": undefined;
    /**
     * The actor has no permission to conduct the action.
     */
    "NoPermission": undefined;
    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     */
    "NoPermissionYet": undefined;
    /**
     * The account is already delegating.
     */
    "AlreadyDelegating": undefined;
    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed through `remove_vote`.
     */
    "AlreadyVoting": undefined;
    /**
     * Too high a balance was provided that the account cannot afford.
     */
    "InsufficientFunds": undefined;
    /**
     * The account is not currently delegating.
     */
    "NotDelegating": undefined;
    /**
     * Delegation to oneself makes no sense.
     */
    "Nonsense": undefined;
    /**
     * Maximum number of votes reached.
     */
    "MaxVotesReached": undefined;
    /**
     * The class must be supplied since it is not easily determinable from the state.
     */
    "ClassNeeded": undefined;
    /**
     * The class ID supplied is invalid.
     */
    "BadClass": undefined;
}>;
type I84u4ul208g742 = AnonymousEnum$2<{
    /**
     * Referendum is not ongoing.
     */
    "NotOngoing": undefined;
    /**
     * Referendum's decision deposit is already paid.
     */
    "HasDeposit": undefined;
    /**
     * The track identifier given was invalid.
     */
    "BadTrack": undefined;
    /**
     * There are already a full complement of referenda in progress for this track.
     */
    "Full": undefined;
    /**
     * The queue of the track is empty.
     */
    "QueueEmpty": undefined;
    /**
     * The referendum index provided is invalid in this context.
     */
    "BadReferendum": undefined;
    /**
     * There was nothing to do in the advancement.
     */
    "NothingToDo": undefined;
    /**
     * No track exists for the proposal origin.
     */
    "NoTrack": undefined;
    /**
     * Any deposit cannot be refunded until after the decision is over.
     */
    "Unfinished": undefined;
    /**
     * The deposit refunder is not the depositor.
     */
    "NoPermission": undefined;
    /**
     * The deposit cannot be refunded since none was made.
     */
    "NoDeposit": undefined;
    /**
     * The referendum status is invalid for this operation.
     */
    "BadStatus": undefined;
    /**
     * The preimage does not exist.
     */
    "PreimageNotExist": undefined;
    /**
     * The preimage is stored with a different length than the one provided.
     */
    "PreimageStoredWithDifferentLength": undefined;
}>;
type I15nctscutpbeh = AnonymousEnum$2<{
    /**
     * The preimage of the call hash could not be loaded.
     */
    "UnavailablePreImage": undefined;
    /**
     * The call could not be decoded.
     */
    "UndecodableCall": undefined;
    /**
     * The weight of the decoded call was higher than the witness.
     */
    "InvalidCallWeightWitness": undefined;
    /**
     * The call was not whitelisted.
     */
    "CallIsNotWhitelisted": undefined;
    /**
     * The call was already whitelisted; No-Op.
     */
    "CallAlreadyWhitelisted": undefined;
}>;
type I36uss0m9fpcsf = AnonymousEnum$2<{
    /**
     * No proposal, bounty or spend at that index.
     */
    "InvalidIndex": undefined;
    /**
     * Too many approvals in the queue.
     */
    "TooManyApprovals": undefined;
    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     */
    "InsufficientPermission": undefined;
    /**
     * Proposal has not been approved.
     */
    "ProposalNotApproved": undefined;
    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     */
    "FailedToConvertBalance": undefined;
    /**
     * The spend has expired and cannot be claimed.
     */
    "SpendExpired": undefined;
    /**
     * The spend is not yet eligible for payout.
     */
    "EarlyPayout": undefined;
    /**
     * The payment has already been attempted.
     */
    "AlreadyAttempted": undefined;
    /**
     * There was some issue with the mechanism of payment.
     */
    "PayoutError": undefined;
    /**
     * The payout was not yet attempted/claimed.
     */
    "NotAttempted": undefined;
    /**
     * The payment has neither failed nor succeeded yet.
     */
    "Inconclusive": undefined;
}>;
type I3qgd61cgli6cp = AnonymousEnum$2<{
    /**
     * The given asset ID is unknown.
     */
    "UnknownAssetKind": undefined;
    /**
     * The given asset ID already has an assigned conversion rate and cannot be re-created.
     */
    "AlreadyExists": undefined;
    /**
     * Overflow ocurred when calculating the inverse rate.
     */
    "Overflow": undefined;
}>;
type I1t0slqjho4lh4 = AnonymousEnum$2<{
    /**
     * Provided asset pair is not supported for pool.
     */
    "InvalidAssetPair": undefined;
    /**
     * The pool doesn't exist.
     */
    "PoolNotFound": undefined;
    /**
     * Pool's balance cannot be zero.
     */
    "ZeroBalance": undefined;
    /**
     * Indicates a partial transfer of balance to the new account during a migration.
     */
    "PartialTransfer": undefined;
}>;
type I1gr2ar7q1k29k = AnonymousEnum$2<{
    /**
     * Either no lease deposit or already unreserved.
     */
    "NoLeaseReserve": undefined;
    /**
     * Either no crowdloan contribution or already withdrawn.
     */
    "NoCrowdloanContribution": undefined;
    /**
     * Either no crowdloan reserve or already unreserved.
     */
    "NoCrowdloanReserve": undefined;
    /**
     * Failed to withdraw crowdloan contribution.
     */
    "FailedToWithdrawCrowdloanContribution": undefined;
    /**
     * Block number is not yet reached.
     */
    "NotYet": undefined;
    /**
     * Not all contributions are withdrawn.
     */
    "ContributionsRemaining": undefined;
    /**
     * Passed account IDs are not matching unmigrated child and sibling accounts.
     */
    "WrongSovereignTranslation": undefined;
    /**
     * The account is not a derived account.
     */
    "WrongDerivedTranslation": undefined;
    /**
     * Account cannot be migrated since it is not a sovereign parachain account.
     */
    "NotSovereign": undefined;
    /**
     * Internal error, please bug report.
     */
    "InternalError": undefined;
    /**
     * The migrated account would get reaped in the process.
     */
    "WouldReap": undefined;
    /**
     * Failed to put a hold on an account.
     */
    "FailedToPutHold": undefined;
    /**
     * Failed to release a hold from an account.
     */
    "FailedToReleaseHold": undefined;
    /**
     * Failed to thaw a frozen balance.
     */
    "FailedToThaw": undefined;
    /**
     * Failed to set a freeze on an account.
     */
    "FailedToSetFreeze": undefined;
    /**
     * Failed to transfer a balance.
     */
    "FailedToTransfer": undefined;
    /**
     * Failed to reserve a balance.
     */
    "FailedToReserve": undefined;
    /**
     * Failed to unreserve the full balance.
     */
    "CannotUnreserve": undefined;
    /**
     * The from and to accounts are identical.
     */
    "AccountIdentical": undefined;
}>;
type I4totqt881mlti = FixedSizeArray<4, bigint>;
type Iasb8k6ash5mjn = (Anonymize$2<I4q39t5hn830vp>) | undefined;
type I35p85j063s0il = (bigint) | undefined;
type I53qpha1qg0fl0 = {
    "gas_consumed": Anonymize$2<I4q39t5hn830vp>;
    "gas_required": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit": Anonymize$2<If7bmpttbdmqu4>;
    "result": ResultPayload<Anonymize$2<I620n7irgfspm4>, Anonymize$2<Ia2qi2m2k5aith>>;
};
type If7bmpttbdmqu4 = AnonymousEnum$2<{
    "Refund": bigint;
    "Charge": bigint;
}>;
type I620n7irgfspm4 = {
    "flags": number;
    "data": Binary;
};
type Ia2qi2m2k5aith = AnonymousEnum$2<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize$2<I5o0s7c8q1cc9b>;
        "ParachainSystem": Anonymize$2<Icjkr35j4tmg7k>;
        "MultiBlockMigrations": Anonymize$2<Iaaqq5jevtahm8>;
        "Preimage": Anonymize$2<I4cfhml1prt4lu>;
        "Scheduler": Anonymize$2<If7oa8fprnilo5>;
        "Sudo": Anonymize$2<Iaug04qjhbli00>;
        "Balances": Anonymize$2<Idj13i7adlomht>;
        "Vesting": Anonymize$2<Icof2acl69lq3c>;
        "CollatorSelection": Anonymize$2<I36bcffk2387dv>;
        "Session": Anonymize$2<I1e07dgbaqd1sq>;
        "XcmpQueue": Anonymize$2<Idnnbndsjjeqqs>;
        "PolkadotXcm": Anonymize$2<I4vcvo9od6afmt>;
        "MessageQueue": Anonymize$2<I5iupade5ag2dp>;
        "SnowbridgeSystemFrontend": Anonymize$2<Idqkarp7hi55vf>;
        "Utility": Anonymize$2<I8dt2g2hcrgh36>;
        "Multisig": Anonymize$2<Ia76qmhhg4jvb9>;
        "Proxy": Anonymize$2<Iuvt54ei4cehc>;
        "Indices": Anonymize$2<Icq1825fru3di2>;
        "Assets": Anonymize$2<Ieqmcndp78shme>;
        "Uniques": Anonymize$2<Ie9ou99obd2hgv>;
        "Nfts": Anonymize$2<I58r1150kmj18u>;
        "ForeignAssets": Anonymize$2<Ieqmcndp78shme>;
        "NftFractionalization": Anonymize$2<Ib24bvufha821j>;
        "PoolAssets": Anonymize$2<Ieqmcndp78shme>;
        "AssetConversion": Anonymize$2<I4u78hb23uhvi2>;
        "AssetsFreezer": Anonymize$2<I4dd4ctqfnk5kr>;
        "ForeignAssetsFreezer": Anonymize$2<I4dd4ctqfnk5kr>;
        "PoolAssetsFreezer": Anonymize$2<I4dd4ctqfnk5kr>;
        "Revive": Anonymize$2<Id1qlto7be0ig7>;
        "AssetRewards": Anonymize$2<I1vqs5qaqr6h6>;
        "StateTrieMigration": Anonymize$2<I96objte63brjr>;
        "Staking": Anonymize$2<Icftpn34uf5f21>;
        "NominationPools": Anonymize$2<Iuudu4kursojc>;
        "FastUnstake": Anonymize$2<Iau9bur8dc3bec>;
        "VoterList": Anonymize$2<I2e4fekrkcdej2>;
        "DelegatedStaking": Anonymize$2<Iaogv3iimefnis>;
        "MultiBlockElection": Anonymize$2<I6gonitoaqpiua>;
        "MultiBlockElectionSigned": Anonymize$2<I9i66md365gdq9>;
        "ConvictionVoting": Anonymize$2<Idfa8k8ikssbsf>;
        "Referenda": Anonymize$2<I84u4ul208g742>;
        "Whitelist": Anonymize$2<I15nctscutpbeh>;
        "Treasury": Anonymize$2<I36uss0m9fpcsf>;
        "AssetRate": Anonymize$2<I3qgd61cgli6cp>;
        "AssetConversionMigration": Anonymize$2<I1t0slqjho4lh4>;
        "AhOps": Anonymize$2<I1gr2ar7q1k29k>;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize$2<Idh4cj79bvroj8>;
}>;
type TokenError = Enum<{
    "FundsUnavailable": undefined;
    "OnlyProvider": undefined;
    "BelowMinimum": undefined;
    "CannotCreate": undefined;
    "UnknownAsset": undefined;
    "Frozen": undefined;
    "Unsupported": undefined;
    "CannotCreateHold": undefined;
    "NotExpendable": undefined;
    "Blocked": undefined;
}>;
declare const TokenError: GetEnum<TokenError>;
type ArithmeticError = Enum<{
    "Underflow": undefined;
    "Overflow": undefined;
    "DivisionByZero": undefined;
}>;
declare const ArithmeticError: GetEnum<ArithmeticError>;
type TransactionalError = Enum<{
    "LimitReached": undefined;
    "NoLayer": undefined;
}>;
declare const TransactionalError: GetEnum<TransactionalError>;
type Idh4cj79bvroj8 = AnonymousEnum$2<{
    "InvalidStateRoot": undefined;
    "IncompleteDatabase": undefined;
    "ValueAtIncompleteKey": undefined;
    "DecoderError": undefined;
    "InvalidHash": undefined;
    "DuplicateKey": undefined;
    "ExtraneousNode": undefined;
    "ExtraneousValue": undefined;
    "ExtraneousHashReference": undefined;
    "InvalidChildReference": undefined;
    "ValueMismatch": undefined;
    "IncompleteProof": undefined;
    "RootMismatch": undefined;
    "DecodeError": undefined;
}>;
type I9sijb8gfrns29 = AnonymousEnum$2<{
    "Upload": Binary;
    "Existing": FixedSizeBinary<32>;
}>;
type If06re1ps6fbbl = {
    "gas_consumed": Anonymize$2<I4q39t5hn830vp>;
    "gas_required": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit": Anonymize$2<If7bmpttbdmqu4>;
    "result": ResultPayload<Anonymize$2<I6cm3omaniofs7>, Anonymize$2<Ia2qi2m2k5aith>>;
};
type I6cm3omaniofs7 = {
    "result": Anonymize$2<I620n7irgfspm4>;
    "addr": FixedSizeBinary<20>;
};
type Iehnkjehe1oeva = ResultPayload<Anonymize$2<Iabpgqcjikia83>, Enum<{
    "DoesntExist": undefined;
    "KeyDecodingFailed": undefined;
}>>;
type Iabpgqcjikia83 = (Binary) | undefined;
type I6f9v7emp7t5ba = {
    "access_list"?: (Array<{
        "address": FixedSizeBinary<20>;
        "storage_keys": Anonymize$2<Ic5m5lp1oioo8r>;
    }>) | undefined;
    "authorization_list": Array<{
        "chain_id": Anonymize$2<I4totqt881mlti>;
        "address": FixedSizeBinary<20>;
        "nonce": Anonymize$2<I4totqt881mlti>;
        "y_parity": Anonymize$2<I4totqt881mlti>;
        "r": Anonymize$2<I4totqt881mlti>;
        "s": Anonymize$2<I4totqt881mlti>;
    }>;
    "blob_versioned_hashes": Anonymize$2<Ic5m5lp1oioo8r>;
    "blobs": Anonymize$2<Itom7fk49o0c9>;
    "chain_id"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "from"?: (FixedSizeBinary<20>) | undefined;
    "gas"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "gas_price"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "input": {
        "input"?: Anonymize$2<Iabpgqcjikia83>;
        "data"?: Anonymize$2<Iabpgqcjikia83>;
    };
    "max_fee_per_blob_gas"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "max_fee_per_gas"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "max_priority_fee_per_gas"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "to"?: (FixedSizeBinary<20>) | undefined;
    "r#type"?: Anonymize$2<I4arjljr6dpflb>;
    "value"?: Anonymize$2<Ic4rgfgksgmm3e>;
};
type Ic5m5lp1oioo8r = Array<FixedSizeBinary<32>>;
type Itom7fk49o0c9 = Array<Binary>;
type Ic4rgfgksgmm3e = (Anonymize$2<I4totqt881mlti>) | undefined;
type I4arjljr6dpflb = (number) | undefined;
type I63nhnkgg114n5 = AnonymousEnum$2<{
    "CallTracer"?: ({
        "with_logs": boolean;
        "only_top_call": boolean;
    }) | undefined;
    "PrestateTracer"?: ({
        "diff_mode": boolean;
        "disable_storage": boolean;
        "disable_code": boolean;
    }) | undefined;
}>;
type Icifup6o102f4c = ResultPayload<Enum<{
    "Call": Anonymize$2<Ibem6ug2es1tq1>;
    "Prestate": Enum<{
        "Prestate": Anonymize$2<I4ra24jtob05ku>;
        "DiffMode": {
            "pre": Anonymize$2<I4ra24jtob05ku>;
            "post": Anonymize$2<I4ra24jtob05ku>;
        };
    }>;
}>, Enum<{
    "Data": Binary;
    "Message": string;
}>>;
type Ibem6ug2es1tq1 = {
    "from": FixedSizeBinary<20>;
    "gas": Anonymize$2<I4totqt881mlti>;
    "gas_used": Anonymize$2<I4totqt881mlti>;
    "to": FixedSizeBinary<20>;
    "input": Binary;
    "output": Binary;
    "error"?: (string) | undefined;
    "revert_reason"?: (string) | undefined;
    "calls": Array<Anonymize$2<Ibem6ug2es1tq1>>;
    "logs": Array<{
        "address": FixedSizeBinary<20>;
        "topics": Anonymize$2<Ic5m5lp1oioo8r>;
        "data": Binary;
        "position": number;
    }>;
    "value"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "call_type": Enum<{
        "Call": undefined;
        "StaticCall": undefined;
        "DelegateCall": undefined;
        "Create": undefined;
        "Create2": undefined;
    }>;
};
type I4ra24jtob05ku = Array<[FixedSizeBinary<20>, {
    "balance"?: Anonymize$2<Ic4rgfgksgmm3e>;
    "nonce"?: Anonymize$2<I4arjljr6dpflb>;
    "code"?: Anonymize$2<Iabpgqcjikia83>;
    "storage": Array<[Binary, Anonymize$2<Iabpgqcjikia83>]>;
}]>;
type I15vf5oinmcgps = {
    "block_number": bigint;
    "block_hash": FixedSizeBinary<32>;
};
type I623eo8t3jrbeo = {
    "chain_id": bigint;
};
type I15lht6t53odo4 = {
    "length": number;
    "data": FixedSizeBinary<32>;
};
type I518fbtnclg1oc = {
    "id": XcmV3JunctionBodyId;
    "part": XcmV2JunctionBodyPart;
};
type XcmV3JunctionBodyId = Enum<{
    "Unit": undefined;
    "Moniker": FixedSizeBinary<4>;
    "Index": number;
    "Executive": undefined;
    "Technical": undefined;
    "Legislative": undefined;
    "Judicial": undefined;
    "Defense": undefined;
    "Administration": undefined;
    "Treasury": undefined;
}>;
declare const XcmV3JunctionBodyId: GetEnum<XcmV3JunctionBodyId>;
type XcmV2JunctionBodyPart = Enum<{
    "Voice": undefined;
    "Members": {
        "count": number;
    };
    "Fraction": {
        "nom": number;
        "denom": number;
    };
    "AtLeastProportion": {
        "nom": number;
        "denom": number;
    };
    "MoreThanProportion": {
        "nom": number;
        "denom": number;
    };
}>;
declare const XcmV2JunctionBodyPart: GetEnum<XcmV2JunctionBodyPart>;
type If9iqq7i64mur8 = {
    "parents": number;
    "interior": XcmV5Junctions;
};
type XcmV5Junctions = Enum<{
    "Here": undefined;
    "X1": XcmV5Junction;
    "X2": FixedSizeArray<2, XcmV5Junction>;
    "X3": FixedSizeArray<3, XcmV5Junction>;
    "X4": FixedSizeArray<4, XcmV5Junction>;
    "X5": FixedSizeArray<5, XcmV5Junction>;
    "X6": FixedSizeArray<6, XcmV5Junction>;
    "X7": FixedSizeArray<7, XcmV5Junction>;
    "X8": FixedSizeArray<8, XcmV5Junction>;
}>;
declare const XcmV5Junctions: GetEnum<XcmV5Junctions>;
type XcmV5Junction = Enum<{
    "Parachain": number;
    "AccountId32": {
        "network"?: Anonymize$2<I97pd2rst02a7r>;
        "id": FixedSizeBinary<32>;
    };
    "AccountIndex64": {
        "network"?: Anonymize$2<I97pd2rst02a7r>;
        "index": bigint;
    };
    "AccountKey20": {
        "network"?: Anonymize$2<I97pd2rst02a7r>;
        "key": FixedSizeBinary<20>;
    };
    "PalletInstance": number;
    "GeneralIndex": bigint;
    "GeneralKey": Anonymize$2<I15lht6t53odo4>;
    "OnlyChild": undefined;
    "Plurality": Anonymize$2<I518fbtnclg1oc>;
    "GlobalConsensus": XcmV5NetworkId;
}>;
declare const XcmV5Junction: GetEnum<XcmV5Junction>;
type I97pd2rst02a7r = (XcmV5NetworkId) | undefined;
type XcmV5NetworkId = Enum<{
    "ByGenesis": FixedSizeBinary<32>;
    "ByFork": Anonymize$2<I15vf5oinmcgps>;
    "Polkadot": undefined;
    "Kusama": undefined;
    "Ethereum": Anonymize$2<I623eo8t3jrbeo>;
    "BitcoinCore": undefined;
    "BitcoinCash": undefined;
    "PolkadotBulletin": undefined;
}>;
declare const XcmV5NetworkId: GetEnum<XcmV5NetworkId>;
type Ifo4pcqnbvdvrg = {
    "gas_consumed": Anonymize$2<I4q39t5hn830vp>;
    "gas_required": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit": Anonymize$2<If7bmpttbdmqu4>;
    "result": ResultPayload<Anonymize$2<I620n7irgfspm4>, Anonymize$2<I2hj070niqub8a>>;
};
type I2hj070niqub8a = AnonymousEnum$2<{
    "Other": undefined;
    "CannotLookup": undefined;
    "BadOrigin": undefined;
    "Module": Enum<{
        "System": Anonymize$2<I5o0s7c8q1cc9b>;
        "ParachainSystem": Anonymize$2<Icjkr35j4tmg7k>;
        "MultiBlockMigrations": Anonymize$2<Iaaqq5jevtahm8>;
        "Balances": Anonymize$2<Idj13i7adlomht>;
        "CollatorSelection": Anonymize$2<I36bcffk2387dv>;
        "Session": Anonymize$2<I1e07dgbaqd1sq>;
        "XcmpQueue": Anonymize$2<Idnnbndsjjeqqs>;
        "PolkadotXcm": Anonymize$2<I4vcvo9od6afmt>;
        "MessageQueue": Anonymize$2<I5iupade5ag2dp>;
        "SnowbridgeSystemFrontend": Anonymize$2<Idqkarp7hi55vf>;
        "Utility": Anonymize$2<I8dt2g2hcrgh36>;
        "Multisig": Anonymize$2<Ia76qmhhg4jvb9>;
        "Proxy": Anonymize$2<Iuvt54ei4cehc>;
        "Assets": Anonymize$2<Ieqmcndp78shme>;
        "Uniques": Anonymize$2<Ie9ou99obd2hgv>;
        "Nfts": Anonymize$2<I58r1150kmj18u>;
        "ForeignAssets": Anonymize$2<Ieqmcndp78shme>;
        "NftFractionalization": Anonymize$2<Ib24bvufha821j>;
        "PoolAssets": Anonymize$2<Ieqmcndp78shme>;
        "AssetConversion": Anonymize$2<I4u78hb23uhvi2>;
        "AssetsFreezer": Anonymize$2<I4dd4ctqfnk5kr>;
        "ForeignAssetsFreezer": Anonymize$2<I4dd4ctqfnk5kr>;
        "PoolAssetsFreezer": Anonymize$2<I4dd4ctqfnk5kr>;
        "Revive": Anonymize$2<Id1qlto7be0ig7>;
        "AssetRewards": Anonymize$2<I1vqs5qaqr6h6>;
        "StateTrieMigration": Anonymize$2<I96objte63brjr>;
        "AssetConversionMigration": Anonymize$2<I1t0slqjho4lh4>;
        "Sudo": Anonymize$2<Iaug04qjhbli00>;
    }>;
    "ConsumerRemaining": undefined;
    "NoProviders": undefined;
    "TooManyConsumers": undefined;
    "Token": TokenError;
    "Arithmetic": ArithmeticError;
    "Transactional": TransactionalError;
    "Exhausted": undefined;
    "Corruption": undefined;
    "Unavailable": undefined;
    "RootNotAllowed": undefined;
    "Trie": Anonymize$2<Idh4cj79bvroj8>;
}>;
type Ici6p8aaddmsqt = {
    "gas_consumed": Anonymize$2<I4q39t5hn830vp>;
    "gas_required": Anonymize$2<I4q39t5hn830vp>;
    "storage_deposit": Anonymize$2<If7bmpttbdmqu4>;
    "result": ResultPayload<Anonymize$2<I6cm3omaniofs7>, Anonymize$2<I2hj070niqub8a>>;
};

type AnonymousEnum$1<T extends {}> = T & {
    __anonymous: true;
};
type MyTuple$1<T> = [T, ...T[]];
type SeparateUndefined$1<T> = undefined extends T ? undefined | Exclude<T, undefined> : T;
type Anonymize$1<T> = SeparateUndefined$1<T extends FixedSizeBinary<infer L> ? number extends L ? Binary : FixedSizeBinary<L> : T extends string | number | bigint | boolean | void | undefined | null | symbol | Uint8Array | Enum<any> ? T : T extends AnonymousEnum$1<infer V> ? Enum<V> : T extends MyTuple$1<any> ? {
    [K in keyof T]: T[K];
} : T extends [] ? [] : T extends FixedSizeArray<infer L, infer T> ? number extends L ? Array<T> : FixedSizeArray<L, T> : {
    [K in keyof T & string]: T[K];
}>;
type IStorage$1 = {
    System: {
        /**
         * The full account information for a particular account ID.
         */
        Account: StorageDescriptor<[Key: SS58String], Anonymize$1<I5sesotjlssv2d>, false, never>;
    };
    Revive: {
        /**
         * A mapping from a contract's code hash to its code.
         * The code's size is bounded by [`crate::limits::BLOB_BYTES`] for PVM and
         * [`revm::primitives::eip170::MAX_CODE_SIZE`] for EVM bytecode.
         */
        PristineCode: StorageDescriptor<[Key: FixedSizeBinary<32>], Binary, true, never>;
        /**
         * The data associated to a contract or externally owned account.
         */
        AccountInfoOf: StorageDescriptor<[Key: FixedSizeBinary<20>], Anonymize$1<I14i9pui8lc778>, true, never>;
        /**
         * Map a Ethereum address to its original `AccountId32`.
         *
         * When deriving a `H160` from an `AccountId32` we use a hash function. In order to
         * reconstruct the original account we need to store the reverse mapping here.
         * Register your `AccountId32` using [`Pallet::map_account`] in order to
         * use it with this pallet.
         */
        OriginalAccount: StorageDescriptor<[Key: FixedSizeBinary<20>], SS58String, true, never>;
    };
};
type ICalls$1 = {
    Revive: {
        /**
         * Makes a call to an account, optionally transferring some balance.
         *
         * # Parameters
         *
         * * `dest`: Address of the contract to call.
         * * `value`: The balance to transfer from the `origin` to `dest`.
         * * `gas_limit`: The gas limit enforced when executing the constructor.
         * * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
         * caller to pay for the storage consumed.
         * * `data`: The input data to pass to the contract.
         *
         * * If the account is a smart-contract account, the associated code will be
         * executed and any value will be transferred.
         * * If the account is a regular account, any value will be transferred.
         * * If no account exists and the call value is not less than `existential_deposit`,
         * a regular account will be created and any value will be transferred.
         */
        call: TxDescriptor<Anonymize$1<Idsg8aod8e8fqn>>;
        /**
         * Instantiates a contract from a previously deployed vm binary.
         *
         * This function is identical to [`Self::instantiate_with_code`] but without the
         * code deployment step. Instead, the `code_hash` of an on-chain deployed vm binary
         * must be supplied.
         */
        instantiate: TxDescriptor<Anonymize$1<I46nktn22m6hbi>>;
        /**
         * Instantiates a new contract from the supplied `code` optionally transferring
         * some balance.
         *
         * This dispatchable has the same effect as calling [`Self::upload_code`] +
         * [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
         * also check the documentation of [`Self::upload_code`].
         *
         * # Parameters
         *
         * * `value`: The balance to transfer from the `origin` to the newly created contract.
         * * `gas_limit`: The gas limit enforced when executing the constructor.
         * * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
         * from the caller to pay for the storage consumed.
         * * `code`: The contract code to deploy in raw bytes.
         * * `data`: The input data to pass to the contract constructor.
         * * `salt`: Used for the address derivation. If `Some` is supplied then `CREATE2`
         * semantics are used. If `None` then `CRATE1` is used.
         *
         *
         * Instantiation is executed as follows:
         *
         * - The supplied `code` is deployed, and a `code_hash` is created for that code.
         * - If the `code_hash` already exists on the chain the underlying `code` will be shared.
         * - The destination address is computed based on the sender, code_hash and the salt.
         * - The smart-contract account is created at the computed address.
         * - The `value` is transferred to the new account.
         * - The `deploy` function is executed in the context of the newly-created account.
         */
        instantiate_with_code: TxDescriptor<Anonymize$1<Ibgj1cthra7lte>>;
    };
};
type IEvent$1 = {};
type IError$1 = {
    System: {
        /**
         * The name of specification does not match between the current runtime
         * and the new runtime.
         */
        InvalidSpecName: PlainDescriptor<undefined>;
        /**
         * The specification version is not allowed to decrease between the current runtime
         * and the new runtime.
         */
        SpecVersionNeedsToIncrease: PlainDescriptor<undefined>;
        /**
         * Failed to extract the runtime version from the new runtime.
         *
         * Either calling `Core_version` or decoding `RuntimeVersion` failed.
         */
        FailedToExtractRuntimeVersion: PlainDescriptor<undefined>;
        /**
         * Suicide called when the account has non-default composite data.
         */
        NonDefaultComposite: PlainDescriptor<undefined>;
        /**
         * There is a non-zero reference count preventing the account from being purged.
         */
        NonZeroRefCount: PlainDescriptor<undefined>;
        /**
         * The origin filter prevent the call to be dispatched.
         */
        CallFiltered: PlainDescriptor<undefined>;
        /**
         * A multi-block migration is ongoing and prevents the current code from being replaced.
         */
        MultiBlockMigrationsOngoing: PlainDescriptor<undefined>;
        /**
         * No upgrade authorized.
         */
        NothingAuthorized: PlainDescriptor<undefined>;
        /**
         * The submitted code is not authorized.
         */
        Unauthorized: PlainDescriptor<undefined>;
    };
    ParachainSystem: {
        /**
         * Attempt to upgrade validation function while existing upgrade pending.
         */
        OverlappingUpgrades: PlainDescriptor<undefined>;
        /**
         * Polkadot currently prohibits this parachain from upgrading its validation function.
         */
        ProhibitedByPolkadot: PlainDescriptor<undefined>;
        /**
         * The supplied validation function has compiled into a blob larger than Polkadot is
         * willing to run.
         */
        TooBig: PlainDescriptor<undefined>;
        /**
         * The inherent which supplies the validation data did not run this block.
         */
        ValidationDataNotAvailable: PlainDescriptor<undefined>;
        /**
         * The inherent which supplies the host configuration did not run this block.
         */
        HostConfigurationNotAvailable: PlainDescriptor<undefined>;
        /**
         * No validation function upgrade is currently scheduled.
         */
        NotScheduled: PlainDescriptor<undefined>;
    };
    MultiBlockMigrations: {
        /**
         * The operation cannot complete since some MBMs are ongoing.
         */
        Ongoing: PlainDescriptor<undefined>;
    };
    Preimage: {
        /**
         * Preimage is too large to store on-chain.
         */
        TooBig: PlainDescriptor<undefined>;
        /**
         * Preimage has already been noted on-chain.
         */
        AlreadyNoted: PlainDescriptor<undefined>;
        /**
         * The user is not authorized to perform this action.
         */
        NotAuthorized: PlainDescriptor<undefined>;
        /**
         * The preimage cannot be removed since it has not yet been noted.
         */
        NotNoted: PlainDescriptor<undefined>;
        /**
         * A preimage may not be removed when there are outstanding requests.
         */
        Requested: PlainDescriptor<undefined>;
        /**
         * The preimage request cannot be removed since no outstanding requests exist.
         */
        NotRequested: PlainDescriptor<undefined>;
        /**
         * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
         */
        TooMany: PlainDescriptor<undefined>;
        /**
         * Too few hashes were requested to be upgraded (i.e. zero).
         */
        TooFew: PlainDescriptor<undefined>;
    };
    Scheduler: {
        /**
         * Failed to schedule a call
         */
        FailedToSchedule: PlainDescriptor<undefined>;
        /**
         * Cannot find the scheduled call.
         */
        NotFound: PlainDescriptor<undefined>;
        /**
         * Given target block number is in the past.
         */
        TargetBlockNumberInPast: PlainDescriptor<undefined>;
        /**
         * Reschedule failed because it does not change scheduled time.
         */
        RescheduleNoChange: PlainDescriptor<undefined>;
        /**
         * Attempt to use a non-named function on a named task.
         */
        Named: PlainDescriptor<undefined>;
    };
    Sudo: {
        /**
         * Sender must be the Sudo account.
         */
        RequireSudo: PlainDescriptor<undefined>;
    };
    Balances: {
        /**
         * Vesting balance too high to send value.
         */
        VestingBalance: PlainDescriptor<undefined>;
        /**
         * Account liquidity restrictions prevent withdrawal.
         */
        LiquidityRestrictions: PlainDescriptor<undefined>;
        /**
         * Balance too low to send value.
         */
        InsufficientBalance: PlainDescriptor<undefined>;
        /**
         * Value too low to create account due to existential deposit.
         */
        ExistentialDeposit: PlainDescriptor<undefined>;
        /**
         * Transfer/payment would kill account.
         */
        Expendability: PlainDescriptor<undefined>;
        /**
         * A vesting schedule already exists for this account.
         */
        ExistingVestingSchedule: PlainDescriptor<undefined>;
        /**
         * Beneficiary account must pre-exist.
         */
        DeadAccount: PlainDescriptor<undefined>;
        /**
         * Number of named reserves exceed `MaxReserves`.
         */
        TooManyReserves: PlainDescriptor<undefined>;
        /**
         * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
         */
        TooManyHolds: PlainDescriptor<undefined>;
        /**
         * Number of freezes exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
        /**
         * The issuance cannot be modified since it is already deactivated.
         */
        IssuanceDeactivated: PlainDescriptor<undefined>;
        /**
         * The delta cannot be zero.
         */
        DeltaZero: PlainDescriptor<undefined>;
    };
    Vesting: {
        /**
         * The account given is not vesting.
         */
        NotVesting: PlainDescriptor<undefined>;
        /**
         * The account already has `MaxVestingSchedules` count of schedules and thus
         * cannot add another one. Consider merging existing schedules in order to add another.
         */
        AtMaxVestingSchedules: PlainDescriptor<undefined>;
        /**
         * Amount being transferred is too low to create a vesting schedule.
         */
        AmountLow: PlainDescriptor<undefined>;
        /**
         * An index was out of bounds of the vesting schedules.
         */
        ScheduleIndexOutOfBounds: PlainDescriptor<undefined>;
        /**
         * Failed to create a new schedule because some parameter was invalid.
         */
        InvalidScheduleParams: PlainDescriptor<undefined>;
    };
    CollatorSelection: {
        /**
         * The pallet has too many candidates.
         */
        TooManyCandidates: PlainDescriptor<undefined>;
        /**
         * Leaving would result in too few candidates.
         */
        TooFewEligibleCollators: PlainDescriptor<undefined>;
        /**
         * Account is already a candidate.
         */
        AlreadyCandidate: PlainDescriptor<undefined>;
        /**
         * Account is not a candidate.
         */
        NotCandidate: PlainDescriptor<undefined>;
        /**
         * There are too many Invulnerables.
         */
        TooManyInvulnerables: PlainDescriptor<undefined>;
        /**
         * Account is already an Invulnerable.
         */
        AlreadyInvulnerable: PlainDescriptor<undefined>;
        /**
         * Account is not an Invulnerable.
         */
        NotInvulnerable: PlainDescriptor<undefined>;
        /**
         * Account has no associated validator ID.
         */
        NoAssociatedValidatorId: PlainDescriptor<undefined>;
        /**
         * Validator ID is not yet registered.
         */
        ValidatorNotRegistered: PlainDescriptor<undefined>;
        /**
         * Could not insert in the candidate list.
         */
        InsertToCandidateListFailed: PlainDescriptor<undefined>;
        /**
         * Could not remove from the candidate list.
         */
        RemoveFromCandidateListFailed: PlainDescriptor<undefined>;
        /**
         * New deposit amount would be below the minimum candidacy bond.
         */
        DepositTooLow: PlainDescriptor<undefined>;
        /**
         * Could not update the candidate list.
         */
        UpdateCandidateListFailed: PlainDescriptor<undefined>;
        /**
         * Deposit amount is too low to take the target's slot in the candidate list.
         */
        InsufficientBond: PlainDescriptor<undefined>;
        /**
         * The target account to be replaced in the candidate list is not a candidate.
         */
        TargetIsNotCandidate: PlainDescriptor<undefined>;
        /**
         * The updated deposit amount is equal to the amount already reserved.
         */
        IdenticalDeposit: PlainDescriptor<undefined>;
        /**
         * Cannot lower candidacy bond while occupying a future collator slot in the list.
         */
        InvalidUnreserve: PlainDescriptor<undefined>;
    };
    Session: {
        /**
         * Invalid ownership proof.
         */
        InvalidProof: PlainDescriptor<undefined>;
        /**
         * No associated validator ID for account.
         */
        NoAssociatedValidatorId: PlainDescriptor<undefined>;
        /**
         * Registered duplicate key.
         */
        DuplicatedKey: PlainDescriptor<undefined>;
        /**
         * No keys are associated with this account.
         */
        NoKeys: PlainDescriptor<undefined>;
        /**
         * Key setting account is not live, so it's impossible to associate keys.
         */
        NoAccount: PlainDescriptor<undefined>;
    };
    XcmpQueue: {
        /**
         * Setting the queue config failed since one of its values was invalid.
         */
        BadQueueConfig: PlainDescriptor<undefined>;
        /**
         * The execution is already suspended.
         */
        AlreadySuspended: PlainDescriptor<undefined>;
        /**
         * The execution is already resumed.
         */
        AlreadyResumed: PlainDescriptor<undefined>;
        /**
         * There are too many active outbound channels.
         */
        TooManyActiveOutboundChannels: PlainDescriptor<undefined>;
        /**
         * The message is too big.
         */
        TooBig: PlainDescriptor<undefined>;
    };
    PolkadotXcm: {
        /**
         * The desired destination was unreachable, generally because there is a no way of routing
         * to it.
         */
        Unreachable: PlainDescriptor<undefined>;
        /**
         * There was some other issue (i.e. not to do with routing) in sending the message.
         * Perhaps a lack of space for buffering the message.
         */
        SendFailure: PlainDescriptor<undefined>;
        /**
         * The message execution fails the filter.
         */
        Filtered: PlainDescriptor<undefined>;
        /**
         * The message's weight could not be determined.
         */
        UnweighableMessage: PlainDescriptor<undefined>;
        /**
         * The destination `Location` provided cannot be inverted.
         */
        DestinationNotInvertible: PlainDescriptor<undefined>;
        /**
         * The assets to be sent are empty.
         */
        Empty: PlainDescriptor<undefined>;
        /**
         * Could not re-anchor the assets to declare the fees for the destination chain.
         */
        CannotReanchor: PlainDescriptor<undefined>;
        /**
         * Too many assets have been attempted for transfer.
         */
        TooManyAssets: PlainDescriptor<undefined>;
        /**
         * Origin is invalid for sending.
         */
        InvalidOrigin: PlainDescriptor<undefined>;
        /**
         * The version of the `Versioned` value used is not able to be interpreted.
         */
        BadVersion: PlainDescriptor<undefined>;
        /**
         * The given location could not be used (e.g. because it cannot be expressed in the
         * desired version of XCM).
         */
        BadLocation: PlainDescriptor<undefined>;
        /**
         * The referenced subscription could not be found.
         */
        NoSubscription: PlainDescriptor<undefined>;
        /**
         * The location is invalid since it already has a subscription from us.
         */
        AlreadySubscribed: PlainDescriptor<undefined>;
        /**
         * Could not check-out the assets for teleportation to the destination chain.
         */
        CannotCheckOutTeleport: PlainDescriptor<undefined>;
        /**
         * The owner does not own (all) of the asset that they wish to do the operation on.
         */
        LowBalance: PlainDescriptor<undefined>;
        /**
         * The asset owner has too many locks on the asset.
         */
        TooManyLocks: PlainDescriptor<undefined>;
        /**
         * The given account is not an identifiable sovereign account for any location.
         */
        AccountNotSovereign: PlainDescriptor<undefined>;
        /**
         * The operation required fees to be paid which the initiator could not meet.
         */
        FeesNotMet: PlainDescriptor<undefined>;
        /**
         * A remote lock with the corresponding data could not be found.
         */
        LockNotFound: PlainDescriptor<undefined>;
        /**
         * The unlock operation cannot succeed because there are still consumers of the lock.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid asset, reserve chain could not be determined for it.
         */
        InvalidAssetUnknownReserve: PlainDescriptor<undefined>;
        /**
         * Invalid asset, do not support remote asset reserves with different fees reserves.
         */
        InvalidAssetUnsupportedReserve: PlainDescriptor<undefined>;
        /**
         * Too many assets with different reserve locations have been attempted for transfer.
         */
        TooManyReserves: PlainDescriptor<undefined>;
        /**
         * Local XCM execution incomplete.
         */
        LocalExecutionIncomplete: PlainDescriptor<undefined>;
        /**
         * Too many locations authorized to alias origin.
         */
        TooManyAuthorizedAliases: PlainDescriptor<undefined>;
        /**
         * Expiry block number is in the past.
         */
        ExpiresInPast: PlainDescriptor<undefined>;
        /**
         * The alias to remove authorization for was not found.
         */
        AliasNotFound: PlainDescriptor<undefined>;
        /**
         * Local XCM execution incomplete with the actual XCM error and the index of the
         * instruction that caused the error.
         */
        LocalExecutionIncompleteWithError: PlainDescriptor<Anonymize$1<I5r8t4iaend96p>>;
    };
    MessageQueue: {
        /**
         * Page is not reapable because it has items remaining to be processed and is not old
         * enough.
         */
        NotReapable: PlainDescriptor<undefined>;
        /**
         * Page to be reaped does not exist.
         */
        NoPage: PlainDescriptor<undefined>;
        /**
         * The referenced message could not be found.
         */
        NoMessage: PlainDescriptor<undefined>;
        /**
         * The message was already processed and cannot be processed again.
         */
        AlreadyProcessed: PlainDescriptor<undefined>;
        /**
         * The message is queued for future execution.
         */
        Queued: PlainDescriptor<undefined>;
        /**
         * There is temporarily not enough weight to continue servicing messages.
         */
        InsufficientWeight: PlainDescriptor<undefined>;
        /**
         * This message is temporarily unprocessable.
         *
         * Such errors are expected, but not guaranteed, to resolve themselves eventually through
         * retrying.
         */
        TemporarilyUnprocessable: PlainDescriptor<undefined>;
        /**
         * The queue is paused and no message can be executed from it.
         *
         * This can change at any time and may resolve in the future by re-trying.
         */
        QueuePaused: PlainDescriptor<undefined>;
        /**
         * Another call is in progress and needs to finish before this call can happen.
         */
        RecursiveDisallowed: PlainDescriptor<undefined>;
    };
    SnowbridgeSystemFrontend: {
        /**
         * Convert versioned location failure
         */
        UnsupportedLocationVersion: PlainDescriptor<undefined>;
        /**
         * Check location failure, should start from the dispatch origin as owner
         */
        InvalidAssetOwner: PlainDescriptor<undefined>;
        /**
         * Send xcm message failure
         */
        SendFailure: PlainDescriptor<undefined>;
        /**
         * Withdraw fee asset failure
         */
        FeesNotMet: PlainDescriptor<undefined>;
        /**
         * Convert to reanchored location failure
         */
        LocationConversionFailed: PlainDescriptor<undefined>;
        /**
         * Message export is halted
         */
        Halted: PlainDescriptor<undefined>;
        /**
         * The desired destination was unreachable, generally because there is a no way of routing
         * to it.
         */
        Unreachable: PlainDescriptor<undefined>;
        /**
         * The asset provided for the tip is unsupported.
         */
        UnsupportedAsset: PlainDescriptor<undefined>;
        /**
         * Unable to withdraw asset.
         */
        WithdrawError: PlainDescriptor<undefined>;
        /**
         * Account could not be converted to a location.
         */
        InvalidAccount: PlainDescriptor<undefined>;
        /**
         * Provided tip asset could not be swapped for ether.
         */
        SwapError: PlainDescriptor<undefined>;
        /**
         * Ether could not be burned.
         */
        BurnError: PlainDescriptor<undefined>;
        /**
         * The tip provided is zero.
         */
        TipAmountZero: PlainDescriptor<undefined>;
    };
    Utility: {
        /**
         * Too many calls batched.
         */
        TooManyCalls: PlainDescriptor<undefined>;
    };
    Multisig: {
        /**
         * Threshold must be 2 or greater.
         */
        MinimumThreshold: PlainDescriptor<undefined>;
        /**
         * Call is already approved by this signatory.
         */
        AlreadyApproved: PlainDescriptor<undefined>;
        /**
         * Call doesn't need any (more) approvals.
         */
        NoApprovalsNeeded: PlainDescriptor<undefined>;
        /**
         * There are too few signatories in the list.
         */
        TooFewSignatories: PlainDescriptor<undefined>;
        /**
         * There are too many signatories in the list.
         */
        TooManySignatories: PlainDescriptor<undefined>;
        /**
         * The signatories were provided out of order; they should be ordered.
         */
        SignatoriesOutOfOrder: PlainDescriptor<undefined>;
        /**
         * The sender was contained in the other signatories; it shouldn't be.
         */
        SenderInSignatories: PlainDescriptor<undefined>;
        /**
         * Multisig operation not found in storage.
         */
        NotFound: PlainDescriptor<undefined>;
        /**
         * Only the account that originally created the multisig is able to cancel it or update
         * its deposits.
         */
        NotOwner: PlainDescriptor<undefined>;
        /**
         * No timepoint was given, yet the multisig operation is already underway.
         */
        NoTimepoint: PlainDescriptor<undefined>;
        /**
         * A different timepoint was given to the multisig operation that is underway.
         */
        WrongTimepoint: PlainDescriptor<undefined>;
        /**
         * A timepoint was given, yet no multisig operation is underway.
         */
        UnexpectedTimepoint: PlainDescriptor<undefined>;
        /**
         * The maximum weight information provided was too low.
         */
        MaxWeightTooLow: PlainDescriptor<undefined>;
        /**
         * The data to be stored is already stored.
         */
        AlreadyStored: PlainDescriptor<undefined>;
    };
    Proxy: {
        /**
         * There are too many proxies registered or too many announcements pending.
         */
        TooMany: PlainDescriptor<undefined>;
        /**
         * Proxy registration not found.
         */
        NotFound: PlainDescriptor<undefined>;
        /**
         * Sender is not a proxy of the account to be proxied.
         */
        NotProxy: PlainDescriptor<undefined>;
        /**
         * A call which is incompatible with the proxy type's filter was attempted.
         */
        Unproxyable: PlainDescriptor<undefined>;
        /**
         * Account is already a proxy.
         */
        Duplicate: PlainDescriptor<undefined>;
        /**
         * Call may not be made by proxy because it may escalate its privileges.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * Announcement, if made at all, was made too recently.
         */
        Unannounced: PlainDescriptor<undefined>;
        /**
         * Cannot add self as proxy.
         */
        NoSelfProxy: PlainDescriptor<undefined>;
    };
    Indices: {
        /**
         * The index was not already assigned.
         */
        NotAssigned: PlainDescriptor<undefined>;
        /**
         * The index is assigned to another account.
         */
        NotOwner: PlainDescriptor<undefined>;
        /**
         * The index was not available.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * The source and destination accounts are identical.
         */
        NotTransfer: PlainDescriptor<undefined>;
        /**
         * The index is permanent and may not be freed/changed.
         */
        Permanent: PlainDescriptor<undefined>;
    };
    Assets: {
        /**
         * Account balance must be greater than or equal to the transfer amount.
         */
        BalanceLow: PlainDescriptor<undefined>;
        /**
         * The account to alter does not exist.
         */
        NoAccount: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given asset ID is unknown.
         */
        Unknown: PlainDescriptor<undefined>;
        /**
         * The origin account is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The asset ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Minimum balance should be non-zero.
         */
        MinBalanceZero: PlainDescriptor<undefined>;
        /**
         * Unable to increment the consumer reference counters on the account. Either no provider
         * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
         * fewer then the maximum number of consumers has been reached.
         */
        UnavailableConsumer: PlainDescriptor<undefined>;
        /**
         * Invalid metadata given.
         */
        BadMetadata: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The source account would not survive the transfer and it needs to stay alive.
         */
        WouldDie: PlainDescriptor<undefined>;
        /**
         * The asset-account already exists.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The asset-account doesn't have an associated deposit.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The operation would result in funds being burned.
         */
        WouldBurn: PlainDescriptor<undefined>;
        /**
         * The asset is a live asset and is actively being used. Usually emit for operations such
         * as `start_destroy` which require the asset to be in a destroying state.
         */
        LiveAsset: PlainDescriptor<undefined>;
        /**
         * The asset is not live, and likely being destroyed.
         */
        AssetNotLive: PlainDescriptor<undefined>;
        /**
         * The asset status is not the expected status.
         */
        IncorrectStatus: PlainDescriptor<undefined>;
        /**
         * The asset should be frozen before the given operation.
         */
        NotFrozen: PlainDescriptor<undefined>;
        /**
         * Callback action resulted in error
         */
        CallbackFailed: PlainDescriptor<undefined>;
        /**
         * The asset ID must be equal to the [`NextAssetId`].
         */
        BadAssetId: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain freezes.
         */
        ContainsFreezes: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain holds.
         */
        ContainsHolds: PlainDescriptor<undefined>;
    };
    Uniques: {
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownCollection: PlainDescriptor<undefined>;
        /**
         * The item ID has already been used for an item.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The owner turned out to be different to what was expected.
         */
        WrongOwner: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * The item ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * The item or collection is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The delegate turned out to be different to what was expected.
         */
        WrongDelegate: PlainDescriptor<undefined>;
        /**
         * There is no delegate approved.
         */
        NoDelegate: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The named owner has not signed ownership of the collection is acceptable.
         */
        Unaccepted: PlainDescriptor<undefined>;
        /**
         * The item is locked.
         */
        Locked: PlainDescriptor<undefined>;
        /**
         * All items have been minted.
         */
        MaxSupplyReached: PlainDescriptor<undefined>;
        /**
         * The max supply has already been set.
         */
        MaxSupplyAlreadySet: PlainDescriptor<undefined>;
        /**
         * The provided max supply is less to the amount of items a collection already has.
         */
        MaxSupplyTooSmall: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownItem: PlainDescriptor<undefined>;
        /**
         * Item is not for sale.
         */
        NotForSale: PlainDescriptor<undefined>;
        /**
         * The provided bid is too low.
         */
        BidTooLow: PlainDescriptor<undefined>;
        /**
         * No metadata is found.
         */
        NoMetadata: PlainDescriptor<undefined>;
        /**
         * Wrong metadata key/value bytes supplied.
         */
        WrongMetadata: PlainDescriptor<undefined>;
        /**
         * An attribute is not found.
         */
        AttributeNotFound: PlainDescriptor<undefined>;
        /**
         * Wrong attribute key/value bytes supplied.
         */
        WrongAttribute: PlainDescriptor<undefined>;
    };
    Nfts: {
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownCollection: PlainDescriptor<undefined>;
        /**
         * The item ID has already been used for an item.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The approval had a deadline that expired, so the approval isn't valid anymore.
         */
        ApprovalExpired: PlainDescriptor<undefined>;
        /**
         * The owner turned out to be different to what was expected.
         */
        WrongOwner: PlainDescriptor<undefined>;
        /**
         * The witness data given does not match the current state of the chain.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Collection ID is already taken.
         */
        CollectionIdInUse: PlainDescriptor<undefined>;
        /**
         * Items within that collection are non-transferable.
         */
        ItemsNonTransferable: PlainDescriptor<undefined>;
        /**
         * The provided account is not a delegate.
         */
        NotDelegate: PlainDescriptor<undefined>;
        /**
         * The delegate turned out to be different to what was expected.
         */
        WrongDelegate: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The named owner has not signed ownership acceptance of the collection.
         */
        Unaccepted: PlainDescriptor<undefined>;
        /**
         * The item is locked (non-transferable).
         */
        ItemLocked: PlainDescriptor<undefined>;
        /**
         * Item's attributes are locked.
         */
        LockedItemAttributes: PlainDescriptor<undefined>;
        /**
         * Collection's attributes are locked.
         */
        LockedCollectionAttributes: PlainDescriptor<undefined>;
        /**
         * Item's metadata is locked.
         */
        LockedItemMetadata: PlainDescriptor<undefined>;
        /**
         * Collection's metadata is locked.
         */
        LockedCollectionMetadata: PlainDescriptor<undefined>;
        /**
         * All items have been minted.
         */
        MaxSupplyReached: PlainDescriptor<undefined>;
        /**
         * The max supply is locked and can't be changed.
         */
        MaxSupplyLocked: PlainDescriptor<undefined>;
        /**
         * The provided max supply is less than the number of items a collection already has.
         */
        MaxSupplyTooSmall: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownItem: PlainDescriptor<undefined>;
        /**
         * Swap doesn't exist.
         */
        UnknownSwap: PlainDescriptor<undefined>;
        /**
         * The given item has no metadata set.
         */
        MetadataNotFound: PlainDescriptor<undefined>;
        /**
         * The provided attribute can't be found.
         */
        AttributeNotFound: PlainDescriptor<undefined>;
        /**
         * Item is not for sale.
         */
        NotForSale: PlainDescriptor<undefined>;
        /**
         * The provided bid is too low.
         */
        BidTooLow: PlainDescriptor<undefined>;
        /**
         * The item has reached its approval limit.
         */
        ReachedApprovalLimit: PlainDescriptor<undefined>;
        /**
         * The deadline has already expired.
         */
        DeadlineExpired: PlainDescriptor<undefined>;
        /**
         * The duration provided should be less than or equal to `MaxDeadlineDuration`.
         */
        WrongDuration: PlainDescriptor<undefined>;
        /**
         * The method is disabled by system settings.
         */
        MethodDisabled: PlainDescriptor<undefined>;
        /**
         * The provided setting can't be set.
         */
        WrongSetting: PlainDescriptor<undefined>;
        /**
         * Item's config already exists and should be equal to the provided one.
         */
        InconsistentItemConfig: PlainDescriptor<undefined>;
        /**
         * Config for a collection or an item can't be found.
         */
        NoConfig: PlainDescriptor<undefined>;
        /**
         * Some roles were not cleared.
         */
        RolesNotCleared: PlainDescriptor<undefined>;
        /**
         * Mint has not started yet.
         */
        MintNotStarted: PlainDescriptor<undefined>;
        /**
         * Mint has already ended.
         */
        MintEnded: PlainDescriptor<undefined>;
        /**
         * The provided Item was already used for claiming.
         */
        AlreadyClaimed: PlainDescriptor<undefined>;
        /**
         * The provided data is incorrect.
         */
        IncorrectData: PlainDescriptor<undefined>;
        /**
         * The extrinsic was sent by the wrong origin.
         */
        WrongOrigin: PlainDescriptor<undefined>;
        /**
         * The provided signature is incorrect.
         */
        WrongSignature: PlainDescriptor<undefined>;
        /**
         * The provided metadata might be too long.
         */
        IncorrectMetadata: PlainDescriptor<undefined>;
        /**
         * Can't set more attributes per one call.
         */
        MaxAttributesLimitReached: PlainDescriptor<undefined>;
        /**
         * The provided namespace isn't supported in this call.
         */
        WrongNamespace: PlainDescriptor<undefined>;
        /**
         * Can't delete non-empty collections.
         */
        CollectionNotEmpty: PlainDescriptor<undefined>;
        /**
         * The witness data should be provided.
         */
        WitnessRequired: PlainDescriptor<undefined>;
    };
    ForeignAssets: {
        /**
         * Account balance must be greater than or equal to the transfer amount.
         */
        BalanceLow: PlainDescriptor<undefined>;
        /**
         * The account to alter does not exist.
         */
        NoAccount: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given asset ID is unknown.
         */
        Unknown: PlainDescriptor<undefined>;
        /**
         * The origin account is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The asset ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Minimum balance should be non-zero.
         */
        MinBalanceZero: PlainDescriptor<undefined>;
        /**
         * Unable to increment the consumer reference counters on the account. Either no provider
         * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
         * fewer then the maximum number of consumers has been reached.
         */
        UnavailableConsumer: PlainDescriptor<undefined>;
        /**
         * Invalid metadata given.
         */
        BadMetadata: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The source account would not survive the transfer and it needs to stay alive.
         */
        WouldDie: PlainDescriptor<undefined>;
        /**
         * The asset-account already exists.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The asset-account doesn't have an associated deposit.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The operation would result in funds being burned.
         */
        WouldBurn: PlainDescriptor<undefined>;
        /**
         * The asset is a live asset and is actively being used. Usually emit for operations such
         * as `start_destroy` which require the asset to be in a destroying state.
         */
        LiveAsset: PlainDescriptor<undefined>;
        /**
         * The asset is not live, and likely being destroyed.
         */
        AssetNotLive: PlainDescriptor<undefined>;
        /**
         * The asset status is not the expected status.
         */
        IncorrectStatus: PlainDescriptor<undefined>;
        /**
         * The asset should be frozen before the given operation.
         */
        NotFrozen: PlainDescriptor<undefined>;
        /**
         * Callback action resulted in error
         */
        CallbackFailed: PlainDescriptor<undefined>;
        /**
         * The asset ID must be equal to the [`NextAssetId`].
         */
        BadAssetId: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain freezes.
         */
        ContainsFreezes: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain holds.
         */
        ContainsHolds: PlainDescriptor<undefined>;
    };
    NftFractionalization: {
        /**
         * Asset ID does not correspond to locked NFT.
         */
        IncorrectAssetId: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * NFT doesn't exist.
         */
        NftNotFound: PlainDescriptor<undefined>;
        /**
         * NFT has not yet been fractionalised.
         */
        NftNotFractionalized: PlainDescriptor<undefined>;
    };
    PoolAssets: {
        /**
         * Account balance must be greater than or equal to the transfer amount.
         */
        BalanceLow: PlainDescriptor<undefined>;
        /**
         * The account to alter does not exist.
         */
        NoAccount: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given asset ID is unknown.
         */
        Unknown: PlainDescriptor<undefined>;
        /**
         * The origin account is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The asset ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Minimum balance should be non-zero.
         */
        MinBalanceZero: PlainDescriptor<undefined>;
        /**
         * Unable to increment the consumer reference counters on the account. Either no provider
         * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
         * fewer then the maximum number of consumers has been reached.
         */
        UnavailableConsumer: PlainDescriptor<undefined>;
        /**
         * Invalid metadata given.
         */
        BadMetadata: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The source account would not survive the transfer and it needs to stay alive.
         */
        WouldDie: PlainDescriptor<undefined>;
        /**
         * The asset-account already exists.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The asset-account doesn't have an associated deposit.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The operation would result in funds being burned.
         */
        WouldBurn: PlainDescriptor<undefined>;
        /**
         * The asset is a live asset and is actively being used. Usually emit for operations such
         * as `start_destroy` which require the asset to be in a destroying state.
         */
        LiveAsset: PlainDescriptor<undefined>;
        /**
         * The asset is not live, and likely being destroyed.
         */
        AssetNotLive: PlainDescriptor<undefined>;
        /**
         * The asset status is not the expected status.
         */
        IncorrectStatus: PlainDescriptor<undefined>;
        /**
         * The asset should be frozen before the given operation.
         */
        NotFrozen: PlainDescriptor<undefined>;
        /**
         * Callback action resulted in error
         */
        CallbackFailed: PlainDescriptor<undefined>;
        /**
         * The asset ID must be equal to the [`NextAssetId`].
         */
        BadAssetId: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain freezes.
         */
        ContainsFreezes: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain holds.
         */
        ContainsHolds: PlainDescriptor<undefined>;
    };
    AssetConversion: {
        /**
         * Provided asset pair is not supported for pool.
         */
        InvalidAssetPair: PlainDescriptor<undefined>;
        /**
         * Pool already exists.
         */
        PoolExists: PlainDescriptor<undefined>;
        /**
         * Desired amount can't be zero.
         */
        WrongDesiredAmount: PlainDescriptor<undefined>;
        /**
         * Provided amount should be greater than or equal to the existential deposit/asset's
         * minimal amount.
         */
        AmountOneLessThanMinimal: PlainDescriptor<undefined>;
        /**
         * Provided amount should be greater than or equal to the existential deposit/asset's
         * minimal amount.
         */
        AmountTwoLessThanMinimal: PlainDescriptor<undefined>;
        /**
         * Reserve needs to always be greater than or equal to the existential deposit/asset's
         * minimal amount.
         */
        ReserveLeftLessThanMinimal: PlainDescriptor<undefined>;
        /**
         * Desired amount can't be equal to the pool reserve.
         */
        AmountOutTooHigh: PlainDescriptor<undefined>;
        /**
         * The pool doesn't exist.
         */
        PoolNotFound: PlainDescriptor<undefined>;
        /**
         * An overflow happened.
         */
        Overflow: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the first token in the pair wasn't met.
         */
        AssetOneDepositDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the second token in the pair wasn't met.
         */
        AssetTwoDepositDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the first token in the pair wasn't met.
         */
        AssetOneWithdrawalDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the second token in the pair wasn't met.
         */
        AssetTwoWithdrawalDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * Optimal calculated amount is less than desired.
         */
        OptimalAmountLessThanDesired: PlainDescriptor<undefined>;
        /**
         * Insufficient liquidity minted.
         */
        InsufficientLiquidityMinted: PlainDescriptor<undefined>;
        /**
         * Requested liquidity can't be zero.
         */
        ZeroLiquidity: PlainDescriptor<undefined>;
        /**
         * Amount can't be zero.
         */
        ZeroAmount: PlainDescriptor<undefined>;
        /**
         * Calculated amount out is less than provided minimum amount.
         */
        ProvidedMinimumNotSufficientForSwap: PlainDescriptor<undefined>;
        /**
         * Provided maximum amount is not sufficient for swap.
         */
        ProvidedMaximumNotSufficientForSwap: PlainDescriptor<undefined>;
        /**
         * The provided path must consists of 2 assets at least.
         */
        InvalidPath: PlainDescriptor<undefined>;
        /**
         * The provided path must consists of unique assets.
         */
        NonUniquePath: PlainDescriptor<undefined>;
        /**
         * It was not possible to get or increment the Id of the pool.
         */
        IncorrectPoolAssetId: PlainDescriptor<undefined>;
        /**
         * The destination account cannot exist with the swapped funds.
         */
        BelowMinimum: PlainDescriptor<undefined>;
    };
    AssetsFreezer: {
        /**
         * Number of freezes on an account would exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
    };
    ForeignAssetsFreezer: {
        /**
         * Number of freezes on an account would exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
    };
    PoolAssetsFreezer: {
        /**
         * Number of freezes on an account would exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
    };
    Revive: {
        /**
         * Invalid schedule supplied, e.g. with zero weight of a basic operation.
         */
        InvalidSchedule: PlainDescriptor<undefined>;
        /**
         * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
         */
        InvalidCallFlags: PlainDescriptor<undefined>;
        /**
         * The executed contract exhausted its gas limit.
         */
        OutOfGas: PlainDescriptor<undefined>;
        /**
         * Performing the requested transfer failed. Probably because there isn't enough
         * free balance in the sender's account.
         */
        TransferFailed: PlainDescriptor<undefined>;
        /**
         * Performing a call was denied because the calling depth reached the limit
         * of what is specified in the schedule.
         */
        MaxCallDepthReached: PlainDescriptor<undefined>;
        /**
         * No contract was found at the specified address.
         */
        ContractNotFound: PlainDescriptor<undefined>;
        /**
         * No code could be found at the supplied code hash.
         */
        CodeNotFound: PlainDescriptor<undefined>;
        /**
         * No code info could be found at the supplied code hash.
         */
        CodeInfoNotFound: PlainDescriptor<undefined>;
        /**
         * A buffer outside of sandbox memory was passed to a contract API function.
         */
        OutOfBounds: PlainDescriptor<undefined>;
        /**
         * Input passed to a contract API function failed to decode as expected type.
         */
        DecodingFailed: PlainDescriptor<undefined>;
        /**
         * Contract trapped during execution.
         */
        ContractTrapped: PlainDescriptor<undefined>;
        /**
         * Event body or storage item exceeds [`limits::PAYLOAD_BYTES`].
         */
        ValueTooLarge: PlainDescriptor<undefined>;
        /**
         * Termination of a contract is not allowed while the contract is already
         * on the call stack. Can be triggered by `seal_terminate`.
         */
        TerminatedWhileReentrant: PlainDescriptor<undefined>;
        /**
         * `seal_call` forwarded this contracts input. It therefore is no longer available.
         */
        InputForwarded: PlainDescriptor<undefined>;
        /**
         * The amount of topics passed to `seal_deposit_events` exceeds the limit.
         */
        TooManyTopics: PlainDescriptor<undefined>;
        /**
         * A contract with the same AccountId already exists.
         */
        DuplicateContract: PlainDescriptor<undefined>;
        /**
         * A contract self destructed in its constructor.
         *
         * This can be triggered by a call to `seal_terminate`.
         */
        TerminatedInConstructor: PlainDescriptor<undefined>;
        /**
         * A call tried to invoke a contract that is flagged as non-reentrant.
         */
        ReentranceDenied: PlainDescriptor<undefined>;
        /**
         * A contract called into the runtime which then called back into this pallet.
         */
        ReenteredPallet: PlainDescriptor<undefined>;
        /**
         * A contract attempted to invoke a state modifying API while being in read-only mode.
         */
        StateChangeDenied: PlainDescriptor<undefined>;
        /**
         * Origin doesn't have enough balance to pay the required storage deposits.
         */
        StorageDepositNotEnoughFunds: PlainDescriptor<undefined>;
        /**
         * More storage was created than allowed by the storage deposit limit.
         */
        StorageDepositLimitExhausted: PlainDescriptor<undefined>;
        /**
         * Code removal was denied because the code is still in use by at least one contract.
         */
        CodeInUse: PlainDescriptor<undefined>;
        /**
         * The contract ran to completion but decided to revert its storage changes.
         * Please note that this error is only returned from extrinsics. When called directly
         * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
         * to determine whether a reversion has taken place.
         */
        ContractReverted: PlainDescriptor<undefined>;
        /**
         * The contract failed to compile or is missing the correct entry points.
         *
         * A more detailed error can be found on the node console if debug messages are enabled
         * by supplying `-lruntime::revive=debug`.
         */
        CodeRejected: PlainDescriptor<undefined>;
        /**
         * The code blob supplied is larger than [`limits::code::BLOB_BYTES`].
         */
        BlobTooLarge: PlainDescriptor<undefined>;
        /**
         * The contract declares too much memory (ro + rw + stack).
         */
        StaticMemoryTooLarge: PlainDescriptor<undefined>;
        /**
         * The program contains a basic block that is larger than allowed.
         */
        BasicBlockTooLarge: PlainDescriptor<undefined>;
        /**
         * The program contains an invalid instruction.
         */
        InvalidInstruction: PlainDescriptor<undefined>;
        /**
         * The contract has reached its maximum number of delegate dependencies.
         */
        MaxDelegateDependenciesReached: PlainDescriptor<undefined>;
        /**
         * The dependency was not found in the contract's delegate dependencies.
         */
        DelegateDependencyNotFound: PlainDescriptor<undefined>;
        /**
         * The contract already depends on the given delegate dependency.
         */
        DelegateDependencyAlreadyExists: PlainDescriptor<undefined>;
        /**
         * Can not add a delegate dependency to the code hash of the contract itself.
         */
        CannotAddSelfAsDelegateDependency: PlainDescriptor<undefined>;
        /**
         * Can not add more data to transient storage.
         */
        OutOfTransientStorage: PlainDescriptor<undefined>;
        /**
         * The contract tried to call a syscall which does not exist (at its current api level).
         */
        InvalidSyscall: PlainDescriptor<undefined>;
        /**
         * Invalid storage flags were passed to one of the storage syscalls.
         */
        InvalidStorageFlags: PlainDescriptor<undefined>;
        /**
         * PolkaVM failed during code execution. Probably due to a malformed program.
         */
        ExecutionFailed: PlainDescriptor<undefined>;
        /**
         * Failed to convert a U256 to a Balance.
         */
        BalanceConversionFailed: PlainDescriptor<undefined>;
        /**
         * Immutable data can only be set during deploys and only be read during calls.
         * Additionally, it is only valid to set the data once and it must not be empty.
         */
        InvalidImmutableAccess: PlainDescriptor<undefined>;
        /**
         * An `AccountID32` account tried to interact with the pallet without having a mapping.
         *
         * Call [`Pallet::map_account`] in order to create a mapping for the account.
         */
        AccountUnmapped: PlainDescriptor<undefined>;
        /**
         * Tried to map an account that is already mapped.
         */
        AccountAlreadyMapped: PlainDescriptor<undefined>;
        /**
         * The transaction used to dry-run a contract is invalid.
         */
        InvalidGenericTransaction: PlainDescriptor<undefined>;
        /**
         * The refcount of a code either over or underflowed.
         */
        RefcountOverOrUnderflow: PlainDescriptor<undefined>;
        /**
         * Unsupported precompile address.
         */
        UnsupportedPrecompileAddress: PlainDescriptor<undefined>;
        /**
         * The calldata exceeds [`limits::CALLDATA_BYTES`].
         */
        CallDataTooLarge: PlainDescriptor<undefined>;
        /**
         * The return data exceeds [`limits::CALLDATA_BYTES`].
         */
        ReturnDataTooLarge: PlainDescriptor<undefined>;
    };
    AssetRewards: {
        /**
         * The staker does not have enough tokens to perform the operation.
         */
        NotEnoughTokens: PlainDescriptor<undefined>;
        /**
         * An operation was attempted on a non-existent pool.
         */
        NonExistentPool: PlainDescriptor<undefined>;
        /**
         * An operation was attempted for a non-existent staker.
         */
        NonExistentStaker: PlainDescriptor<undefined>;
        /**
         * An operation was attempted with a non-existent asset.
         */
        NonExistentAsset: PlainDescriptor<undefined>;
        /**
         * There was an error converting a block number.
         */
        BlockNumberConversionError: PlainDescriptor<undefined>;
        /**
         * The expiry block must be in the future.
         */
        ExpiryBlockMustBeInTheFuture: PlainDescriptor<undefined>;
        /**
         * Insufficient funds to create the freeze.
         */
        InsufficientFunds: PlainDescriptor<undefined>;
        /**
         * The expiry block can be only extended.
         */
        ExpiryCut: PlainDescriptor<undefined>;
        /**
         * The reward rate per block can be only increased.
         */
        RewardRateCut: PlainDescriptor<undefined>;
        /**
         * The pool still has staked tokens or rewards.
         */
        NonEmptyPool: PlainDescriptor<undefined>;
    };
    StateTrieMigration: {
        /**
         * Max signed limits not respected.
         */
        MaxSignedLimits: PlainDescriptor<undefined>;
        /**
         * A key was longer than the configured maximum.
         *
         * This means that the migration halted at the current [`Progress`] and
         * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
         * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
         * The value should only be increased to avoid a storage migration for the currently
         * stored [`crate::Progress::LastKey`].
         */
        KeyTooLong: PlainDescriptor<undefined>;
        /**
         * submitter does not have enough funds.
         */
        NotEnoughFunds: PlainDescriptor<undefined>;
        /**
         * Bad witness data provided.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Signed migration is not allowed because the maximum limit is not set yet.
         */
        SignedMigrationNotAllowed: PlainDescriptor<undefined>;
        /**
         * Bad child root provided.
         */
        BadChildRoot: PlainDescriptor<undefined>;
    };
    Staking: {
        /**
         * Not a controller account.
         */
        NotController: PlainDescriptor<undefined>;
        /**
         * Not a stash account.
         */
        NotStash: PlainDescriptor<undefined>;
        /**
         * Stash is already bonded.
         */
        AlreadyBonded: PlainDescriptor<undefined>;
        /**
         * Controller is already paired.
         */
        AlreadyPaired: PlainDescriptor<undefined>;
        /**
         * Targets cannot be empty.
         */
        EmptyTargets: PlainDescriptor<undefined>;
        /**
         * Duplicate index.
         */
        DuplicateIndex: PlainDescriptor<undefined>;
        /**
         * Slash record not found.
         */
        InvalidSlashRecord: PlainDescriptor<undefined>;
        /**
         * Cannot bond, nominate or validate with value less than the minimum defined by
         * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
         * intention, `chill` first to remove one's role as validator/nominator.
         */
        InsufficientBond: PlainDescriptor<undefined>;
        /**
         * Can not schedule more unlock chunks.
         */
        NoMoreChunks: PlainDescriptor<undefined>;
        /**
         * Can not rebond without unlocking chunks.
         */
        NoUnlockChunk: PlainDescriptor<undefined>;
        /**
         * Attempting to target a stash that still has funds.
         */
        FundedTarget: PlainDescriptor<undefined>;
        /**
         * Invalid era to reward.
         */
        InvalidEraToReward: PlainDescriptor<undefined>;
        /**
         * Invalid number of nominations.
         */
        InvalidNumberOfNominations: PlainDescriptor<undefined>;
        /**
         * Rewards for this era have already been claimed for this validator.
         */
        AlreadyClaimed: PlainDescriptor<undefined>;
        /**
         * No nominators exist on this page.
         */
        InvalidPage: PlainDescriptor<undefined>;
        /**
         * Incorrect previous history depth input provided.
         */
        IncorrectHistoryDepth: PlainDescriptor<undefined>;
        /**
         * Internal state has become somehow corrupted and the operation cannot continue.
         */
        BadState: PlainDescriptor<undefined>;
        /**
         * Too many nomination targets supplied.
         */
        TooManyTargets: PlainDescriptor<undefined>;
        /**
         * A nomination target was supplied that was blocked or otherwise not a validator.
         */
        BadTarget: PlainDescriptor<undefined>;
        /**
         * The user has enough bond and thus cannot be chilled forcefully by an external person.
         */
        CannotChillOther: PlainDescriptor<undefined>;
        /**
         * There are too many nominators in the system. Governance needs to adjust the staking
         * settings to keep things safe for the runtime.
         */
        TooManyNominators: PlainDescriptor<undefined>;
        /**
         * There are too many validator candidates in the system. Governance needs to adjust the
         * staking settings to keep things safe for the runtime.
         */
        TooManyValidators: PlainDescriptor<undefined>;
        /**
         * Commission is too low. Must be at least `MinCommission`.
         */
        CommissionTooLow: PlainDescriptor<undefined>;
        /**
         * Some bound is not met.
         */
        BoundNotMet: PlainDescriptor<undefined>;
        /**
         * Used when attempting to use deprecated controller account logic.
         */
        ControllerDeprecated: PlainDescriptor<undefined>;
        /**
         * Cannot reset a ledger.
         */
        CannotRestoreLedger: PlainDescriptor<undefined>;
        /**
         * Provided reward destination is not allowed.
         */
        RewardDestinationRestricted: PlainDescriptor<undefined>;
        /**
         * Not enough funds available to withdraw.
         */
        NotEnoughFunds: PlainDescriptor<undefined>;
        /**
         * Operation not allowed for virtual stakers.
         */
        VirtualStakerNotAllowed: PlainDescriptor<undefined>;
        /**
         * Stash could not be reaped as other pallet might depend on it.
         */
        CannotReapStash: PlainDescriptor<undefined>;
        /**
         * The stake of this account is already migrated to `Fungible` holds.
         */
        AlreadyMigrated: PlainDescriptor<undefined>;
        /**
         * Era not yet started.
         */
        EraNotStarted: PlainDescriptor<undefined>;
        /**
         * Account is restricted from participation in staking. This may happen if the account is
         * staking in another way already, such as via pool.
         */
        Restricted: PlainDescriptor<undefined>;
        /**
         * Unapplied slashes in the recently concluded era is blocking this operation.
         * See `Call::apply_slash` to apply them.
         */
        UnappliedSlashesInPreviousEra: PlainDescriptor<undefined>;
        /**
         * The era is not eligible for pruning.
         */
        EraNotPrunable: PlainDescriptor<undefined>;
        /**
         * The slash has been cancelled and cannot be applied.
         */
        CancelledSlash: PlainDescriptor<undefined>;
    };
    NominationPools: {
        /**
         * A (bonded) pool id does not exist.
         */
        PoolNotFound: PlainDescriptor<undefined>;
        /**
         * An account is not a member.
         */
        PoolMemberNotFound: PlainDescriptor<undefined>;
        /**
         * A reward pool does not exist. In all cases this is a system logic error.
         */
        RewardPoolNotFound: PlainDescriptor<undefined>;
        /**
         * A sub pool does not exist.
         */
        SubPoolsNotFound: PlainDescriptor<undefined>;
        /**
         * An account is already delegating in another pool. An account may only belong to one
         * pool at a time.
         */
        AccountBelongsToOtherPool: PlainDescriptor<undefined>;
        /**
         * The member is fully unbonded (and thus cannot access the bonded and reward pool
         * anymore to, for example, collect rewards).
         */
        FullyUnbonding: PlainDescriptor<undefined>;
        /**
         * The member cannot unbond further chunks due to reaching the limit.
         */
        MaxUnbondingLimit: PlainDescriptor<undefined>;
        /**
         * None of the funds can be withdrawn yet because the bonding duration has not passed.
         */
        CannotWithdrawAny: PlainDescriptor<undefined>;
        /**
         * The amount does not meet the minimum bond to either join or create a pool.
         *
         * The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
         * caller does not have nominating permissions for the pool. Members can never unbond to a
         * value below `MinJoinBond`.
         */
        MinimumBondNotMet: PlainDescriptor<undefined>;
        /**
         * The transaction could not be executed due to overflow risk for the pool.
         */
        OverflowRisk: PlainDescriptor<undefined>;
        /**
         * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
         * other members to be permissionlessly unbonded.
         */
        NotDestroying: PlainDescriptor<undefined>;
        /**
         * The caller does not have nominating permissions for the pool.
         */
        NotNominator: PlainDescriptor<undefined>;
        /**
         * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
         */
        NotKickerOrDestroying: PlainDescriptor<undefined>;
        /**
         * The pool is not open to join
         */
        NotOpen: PlainDescriptor<undefined>;
        /**
         * The system is maxed out on pools.
         */
        MaxPools: PlainDescriptor<undefined>;
        /**
         * Too many members in the pool or system.
         */
        MaxPoolMembers: PlainDescriptor<undefined>;
        /**
         * The pools state cannot be changed.
         */
        CanNotChangeState: PlainDescriptor<undefined>;
        /**
         * The caller does not have adequate permissions.
         */
        DoesNotHavePermission: PlainDescriptor<undefined>;
        /**
         * Metadata exceeds [`Config::MaxMetadataLen`]
         */
        MetadataExceedsMaxLen: PlainDescriptor<undefined>;
        /**
         * Some error occurred that should never happen. This should be reported to the
         * maintainers.
         */
        Defensive: PlainDescriptor<Anonymize$1<Ie2db4l6126rkt>>;
        /**
         * Partial unbonding now allowed permissionlessly.
         */
        PartialUnbondNotAllowedPermissionlessly: PlainDescriptor<undefined>;
        /**
         * The pool's max commission cannot be set higher than the existing value.
         */
        MaxCommissionRestricted: PlainDescriptor<undefined>;
        /**
         * The supplied commission exceeds the max allowed commission.
         */
        CommissionExceedsMaximum: PlainDescriptor<undefined>;
        /**
         * The supplied commission exceeds global maximum commission.
         */
        CommissionExceedsGlobalMaximum: PlainDescriptor<undefined>;
        /**
         * Not enough blocks have surpassed since the last commission update.
         */
        CommissionChangeThrottled: PlainDescriptor<undefined>;
        /**
         * The submitted changes to commission change rate are not allowed.
         */
        CommissionChangeRateNotAllowed: PlainDescriptor<undefined>;
        /**
         * There is no pending commission to claim.
         */
        NoPendingCommission: PlainDescriptor<undefined>;
        /**
         * No commission current has been set.
         */
        NoCommissionCurrentSet: PlainDescriptor<undefined>;
        /**
         * Pool id currently in use.
         */
        PoolIdInUse: PlainDescriptor<undefined>;
        /**
         * Pool id provided is not correct/usable.
         */
        InvalidPoolId: PlainDescriptor<undefined>;
        /**
         * Bonding extra is restricted to the exact pending reward amount.
         */
        BondExtraRestricted: PlainDescriptor<undefined>;
        /**
         * No imbalance in the ED deposit for the pool.
         */
        NothingToAdjust: PlainDescriptor<undefined>;
        /**
         * No slash pending that can be applied to the member.
         */
        NothingToSlash: PlainDescriptor<undefined>;
        /**
         * The slash amount is too low to be applied.
         */
        SlashTooLow: PlainDescriptor<undefined>;
        /**
         * The pool or member delegation has already migrated to delegate stake.
         */
        AlreadyMigrated: PlainDescriptor<undefined>;
        /**
         * The pool or member delegation has not migrated yet to delegate stake.
         */
        NotMigrated: PlainDescriptor<undefined>;
        /**
         * This call is not allowed in the current state of the pallet.
         */
        NotSupported: PlainDescriptor<undefined>;
        /**
         * Account is restricted from participation in pools. This may happen if the account is
         * staking in another way already.
         */
        Restricted: PlainDescriptor<undefined>;
    };
    FastUnstake: {
        /**
         * The provided Controller account was not found.
         *
         * This means that the given account is not bonded.
         */
        NotController: PlainDescriptor<undefined>;
        /**
         * The bonded account has already been queued.
         */
        AlreadyQueued: PlainDescriptor<undefined>;
        /**
         * The bonded account has active unlocking chunks.
         */
        NotFullyBonded: PlainDescriptor<undefined>;
        /**
         * The provided un-staker is not in the `Queue`.
         */
        NotQueued: PlainDescriptor<undefined>;
        /**
         * The provided un-staker is already in Head, and cannot deregister.
         */
        AlreadyHead: PlainDescriptor<undefined>;
        /**
         * The call is not allowed at this point because the pallet is not active.
         */
        CallNotAllowed: PlainDescriptor<undefined>;
    };
    VoterList: {
        /**
         * A error in the list interface implementation.
         */
        List: PlainDescriptor<Anonymize$1<Ictkqqlhdjt761>>;
        /**
         * Could not update a node, because the pallet is locked.
         */
        Locked: PlainDescriptor<undefined>;
    };
    DelegatedStaking: {
        /**
         * The account cannot perform this operation.
         */
        NotAllowed: PlainDescriptor<undefined>;
        /**
         * An existing staker cannot perform this action.
         */
        AlreadyStaking: PlainDescriptor<undefined>;
        /**
         * Reward Destination cannot be same as `Agent` account.
         */
        InvalidRewardDestination: PlainDescriptor<undefined>;
        /**
         * Delegation conditions are not met.
         *
         * Possible issues are
         * 1) Cannot delegate to self,
         * 2) Cannot delegate to multiple delegates.
         */
        InvalidDelegation: PlainDescriptor<undefined>;
        /**
         * The account does not have enough funds to perform the operation.
         */
        NotEnoughFunds: PlainDescriptor<undefined>;
        /**
         * Not an existing `Agent` account.
         */
        NotAgent: PlainDescriptor<undefined>;
        /**
         * Not a Delegator account.
         */
        NotDelegator: PlainDescriptor<undefined>;
        /**
         * Some corruption in internal state.
         */
        BadState: PlainDescriptor<undefined>;
        /**
         * Unapplied pending slash restricts operation on `Agent`.
         */
        UnappliedSlash: PlainDescriptor<undefined>;
        /**
         * `Agent` has no pending slash to be applied.
         */
        NothingToSlash: PlainDescriptor<undefined>;
        /**
         * Failed to withdraw amount from Core Staking.
         */
        WithdrawFailed: PlainDescriptor<undefined>;
        /**
         * Operation not supported by this pallet.
         */
        NotSupported: PlainDescriptor<undefined>;
    };
    MultiBlockElection: {
        /**
         * Triggering the `Fallback` failed.
         */
        Fallback: PlainDescriptor<undefined>;
        /**
         * Unexpected phase
         */
        UnexpectedPhase: PlainDescriptor<undefined>;
        /**
         * Snapshot was unavailable.
         */
        Snapshot: PlainDescriptor<undefined>;
    };
    MultiBlockElectionSigned: {
        /**
         * The phase is not signed.
         */
        PhaseNotSigned: PlainDescriptor<undefined>;
        /**
         * The submission is a duplicate.
         */
        Duplicate: PlainDescriptor<undefined>;
        /**
         * The queue is full.
         */
        QueueFull: PlainDescriptor<undefined>;
        /**
         * The page index is out of bounds.
         */
        BadPageIndex: PlainDescriptor<undefined>;
        /**
         * The account is not registered.
         */
        NotRegistered: PlainDescriptor<undefined>;
        /**
         * No submission found.
         */
        NoSubmission: PlainDescriptor<undefined>;
        /**
         * Round is not yet over.
         */
        RoundNotOver: PlainDescriptor<undefined>;
        /**
         * Bad witness data provided.
         */
        BadWitnessData: PlainDescriptor<undefined>;
        /**
         * Too many invulnerable accounts are provided,
         */
        TooManyInvulnerables: PlainDescriptor<undefined>;
    };
    ConvictionVoting: {
        /**
         * Poll is not ongoing.
         */
        NotOngoing: PlainDescriptor<undefined>;
        /**
         * The given account did not vote on the poll.
         */
        NotVoter: PlainDescriptor<undefined>;
        /**
         * The actor has no permission to conduct the action.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The actor has no permission to conduct the action right now but will do in the future.
         */
        NoPermissionYet: PlainDescriptor<undefined>;
        /**
         * The account is already delegating.
         */
        AlreadyDelegating: PlainDescriptor<undefined>;
        /**
         * The account currently has votes attached to it and the operation cannot succeed until
         * these are removed through `remove_vote`.
         */
        AlreadyVoting: PlainDescriptor<undefined>;
        /**
         * Too high a balance was provided that the account cannot afford.
         */
        InsufficientFunds: PlainDescriptor<undefined>;
        /**
         * The account is not currently delegating.
         */
        NotDelegating: PlainDescriptor<undefined>;
        /**
         * Delegation to oneself makes no sense.
         */
        Nonsense: PlainDescriptor<undefined>;
        /**
         * Maximum number of votes reached.
         */
        MaxVotesReached: PlainDescriptor<undefined>;
        /**
         * The class must be supplied since it is not easily determinable from the state.
         */
        ClassNeeded: PlainDescriptor<undefined>;
        /**
         * The class ID supplied is invalid.
         */
        BadClass: PlainDescriptor<undefined>;
    };
    Referenda: {
        /**
         * Referendum is not ongoing.
         */
        NotOngoing: PlainDescriptor<undefined>;
        /**
         * Referendum's decision deposit is already paid.
         */
        HasDeposit: PlainDescriptor<undefined>;
        /**
         * The track identifier given was invalid.
         */
        BadTrack: PlainDescriptor<undefined>;
        /**
         * There are already a full complement of referenda in progress for this track.
         */
        Full: PlainDescriptor<undefined>;
        /**
         * The queue of the track is empty.
         */
        QueueEmpty: PlainDescriptor<undefined>;
        /**
         * The referendum index provided is invalid in this context.
         */
        BadReferendum: PlainDescriptor<undefined>;
        /**
         * There was nothing to do in the advancement.
         */
        NothingToDo: PlainDescriptor<undefined>;
        /**
         * No track exists for the proposal origin.
         */
        NoTrack: PlainDescriptor<undefined>;
        /**
         * Any deposit cannot be refunded until after the decision is over.
         */
        Unfinished: PlainDescriptor<undefined>;
        /**
         * The deposit refunder is not the depositor.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The deposit cannot be refunded since none was made.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The referendum status is invalid for this operation.
         */
        BadStatus: PlainDescriptor<undefined>;
        /**
         * The preimage does not exist.
         */
        PreimageNotExist: PlainDescriptor<undefined>;
        /**
         * The preimage is stored with a different length than the one provided.
         */
        PreimageStoredWithDifferentLength: PlainDescriptor<undefined>;
    };
    Whitelist: {
        /**
         * The preimage of the call hash could not be loaded.
         */
        UnavailablePreImage: PlainDescriptor<undefined>;
        /**
         * The call could not be decoded.
         */
        UndecodableCall: PlainDescriptor<undefined>;
        /**
         * The weight of the decoded call was higher than the witness.
         */
        InvalidCallWeightWitness: PlainDescriptor<undefined>;
        /**
         * The call was not whitelisted.
         */
        CallIsNotWhitelisted: PlainDescriptor<undefined>;
        /**
         * The call was already whitelisted; No-Op.
         */
        CallAlreadyWhitelisted: PlainDescriptor<undefined>;
    };
    Treasury: {
        /**
         * No proposal, bounty or spend at that index.
         */
        InvalidIndex: PlainDescriptor<undefined>;
        /**
         * Too many approvals in the queue.
         */
        TooManyApprovals: PlainDescriptor<undefined>;
        /**
         * The spend origin is valid but the amount it is allowed to spend is lower than the
         * amount to be spent.
         */
        InsufficientPermission: PlainDescriptor<undefined>;
        /**
         * Proposal has not been approved.
         */
        ProposalNotApproved: PlainDescriptor<undefined>;
        /**
         * The balance of the asset kind is not convertible to the balance of the native asset.
         */
        FailedToConvertBalance: PlainDescriptor<undefined>;
        /**
         * The spend has expired and cannot be claimed.
         */
        SpendExpired: PlainDescriptor<undefined>;
        /**
         * The spend is not yet eligible for payout.
         */
        EarlyPayout: PlainDescriptor<undefined>;
        /**
         * The payment has already been attempted.
         */
        AlreadyAttempted: PlainDescriptor<undefined>;
        /**
         * There was some issue with the mechanism of payment.
         */
        PayoutError: PlainDescriptor<undefined>;
        /**
         * The payout was not yet attempted/claimed.
         */
        NotAttempted: PlainDescriptor<undefined>;
        /**
         * The payment has neither failed nor succeeded yet.
         */
        Inconclusive: PlainDescriptor<undefined>;
    };
    AssetRate: {
        /**
         * The given asset ID is unknown.
         */
        UnknownAssetKind: PlainDescriptor<undefined>;
        /**
         * The given asset ID already has an assigned conversion rate and cannot be re-created.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * Overflow ocurred when calculating the inverse rate.
         */
        Overflow: PlainDescriptor<undefined>;
    };
    AssetConversionMigration: {
        /**
         * Provided asset pair is not supported for pool.
         */
        InvalidAssetPair: PlainDescriptor<undefined>;
        /**
         * The pool doesn't exist.
         */
        PoolNotFound: PlainDescriptor<undefined>;
        /**
         * Pool's balance cannot be zero.
         */
        ZeroBalance: PlainDescriptor<undefined>;
        /**
         * Indicates a partial transfer of balance to the new account during a migration.
         */
        PartialTransfer: PlainDescriptor<undefined>;
    };
    AhOps: {
        /**
         * Either no lease deposit or already unreserved.
         */
        NoLeaseReserve: PlainDescriptor<undefined>;
        /**
         * Either no crowdloan contribution or already withdrawn.
         */
        NoCrowdloanContribution: PlainDescriptor<undefined>;
        /**
         * Either no crowdloan reserve or already unreserved.
         */
        NoCrowdloanReserve: PlainDescriptor<undefined>;
        /**
         * Failed to withdraw crowdloan contribution.
         */
        FailedToWithdrawCrowdloanContribution: PlainDescriptor<undefined>;
        /**
         * Block number is not yet reached.
         */
        NotYet: PlainDescriptor<undefined>;
        /**
         * Not all contributions are withdrawn.
         */
        ContributionsRemaining: PlainDescriptor<undefined>;
        /**
         * Passed account IDs are not matching unmigrated child and sibling accounts.
         */
        WrongSovereignTranslation: PlainDescriptor<undefined>;
        /**
         * The account is not a derived account.
         */
        WrongDerivedTranslation: PlainDescriptor<undefined>;
        /**
         * Account cannot be migrated since it is not a sovereign parachain account.
         */
        NotSovereign: PlainDescriptor<undefined>;
        /**
         * Internal error, please bug report.
         */
        InternalError: PlainDescriptor<undefined>;
        /**
         * The migrated account would get reaped in the process.
         */
        WouldReap: PlainDescriptor<undefined>;
        /**
         * Failed to put a hold on an account.
         */
        FailedToPutHold: PlainDescriptor<undefined>;
        /**
         * Failed to release a hold from an account.
         */
        FailedToReleaseHold: PlainDescriptor<undefined>;
        /**
         * Failed to thaw a frozen balance.
         */
        FailedToThaw: PlainDescriptor<undefined>;
        /**
         * Failed to set a freeze on an account.
         */
        FailedToSetFreeze: PlainDescriptor<undefined>;
        /**
         * Failed to transfer a balance.
         */
        FailedToTransfer: PlainDescriptor<undefined>;
        /**
         * Failed to reserve a balance.
         */
        FailedToReserve: PlainDescriptor<undefined>;
        /**
         * Failed to unreserve the full balance.
         */
        CannotUnreserve: PlainDescriptor<undefined>;
        /**
         * The from and to accounts are identical.
         */
        AccountIdentical: PlainDescriptor<undefined>;
    };
};
type IConstants$1 = {
    Revive: {
        /**
         * The ratio between the decimal representation of the native token and the ETH token.
         */
        NativeToEthRatio: PlainDescriptor<number>;
    };
};
type IViewFns$1 = {};
type IRuntimeCalls$1 = {
    /**
     * The API used to dry-run contract interactions.
     */
    ReviveApi: {
        /**
         * Returns the free balance of the given `[H160]` address, using EVM decimals.
         */
        balance: RuntimeDescriptor<[address: FixedSizeBinary<20>], Anonymize$1<I4totqt881mlti>>;
        /**
         * Perform a call from a specified account to a given contract.
         *
         * See [`crate::Pallet::bare_call`].
         */
        call: RuntimeDescriptor<[origin: SS58String, dest: FixedSizeBinary<20>, value: bigint, gas_limit: Anonymize$1<Iasb8k6ash5mjn>, storage_deposit_limit: Anonymize$1<I35p85j063s0il>, input_data: Binary], Anonymize$1<I53qpha1qg0fl0>>;
        /**
         * Instantiate a new contract.
         *
         * See `[crate::Pallet::bare_instantiate]`.
         */
        instantiate: RuntimeDescriptor<[origin: SS58String, value: bigint, gas_limit: Anonymize$1<Iasb8k6ash5mjn>, storage_deposit_limit: Anonymize$1<I35p85j063s0il>, code: Anonymize$1<I9sijb8gfrns29>, data: Binary, salt: Anonymize$1<I4s6vifaf8k998>], Anonymize$1<If06re1ps6fbbl>>;
        /**
         * Query a given storage key in a given contract.
         *
         * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
         * specified account and `Ok(None)` if it doesn't. If the account specified by the address
         * doesn't exist, or doesn't have a contract then `Err` is returned.
         */
        get_storage: RuntimeDescriptor<[address: FixedSizeBinary<20>, key: FixedSizeBinary<32>], Anonymize$1<Iehnkjehe1oeva>>;
        /**
         * Query a given variable-sized storage key in a given contract.
         *
         * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
         * specified account and `Ok(None)` if it doesn't. If the account specified by the address
         * doesn't exist, or doesn't have a contract then `Err` is returned.
         */
        get_storage_var_key: RuntimeDescriptor<[address: FixedSizeBinary<20>, key: Binary], Anonymize$1<Iehnkjehe1oeva>>;
        /**
         * Dry run and return the trace of the given call.
         *
         * See eth-rpc `debug_traceCall` for usage.
         */
        trace_call: RuntimeDescriptor<[tx: Anonymize$1<I6f9v7emp7t5ba>, config: Anonymize$1<I63nhnkgg114n5>], Anonymize$1<Icifup6o102f4c>>;
    };
};
type IAsset$1 = PlainDescriptor<Anonymize$1<If9iqq7i64mur8>>;
type PalletsTypedef$1 = {
    __storage: IStorage$1;
    __tx: ICalls$1;
    __event: IEvent$1;
    __error: IError$1;
    __const: IConstants$1;
    __view: IViewFns$1;
};
type WndAh = {
    descriptors: {
        pallets: PalletsTypedef$1;
        apis: IRuntimeCalls$1;
    } & Promise<any>;
    metadataTypes: Promise<Uint8Array>;
    asset: IAsset$1;
    getMetadata: () => Promise<Uint8Array>;
    genesis: string | undefined;
};

type AnonymousEnum<T extends {}> = T & {
    __anonymous: true;
};
type MyTuple<T> = [T, ...T[]];
type SeparateUndefined<T> = undefined extends T ? undefined | Exclude<T, undefined> : T;
type Anonymize<T> = SeparateUndefined<T extends FixedSizeBinary<infer L> ? number extends L ? Binary : FixedSizeBinary<L> : T extends string | number | bigint | boolean | void | undefined | null | symbol | Uint8Array | Enum<any> ? T : T extends AnonymousEnum<infer V> ? Enum<V> : T extends MyTuple<any> ? {
    [K in keyof T]: T[K];
} : T extends [] ? [] : T extends FixedSizeArray<infer L, infer T> ? number extends L ? Array<T> : FixedSizeArray<L, T> : {
    [K in keyof T & string]: T[K];
}>;
type IStorage = {
    System: {
        /**
         * The full account information for a particular account ID.
         */
        Account: StorageDescriptor<[Key: SS58String], Anonymize<I5sesotjlssv2d>, false, never>;
    };
    Revive: {
        /**
         * A mapping from a contract's code hash to its code.
         * The code's size is bounded by [`crate::limits::BLOB_BYTES`] for PVM and
         * [`revm::primitives::eip170::MAX_CODE_SIZE`] for EVM bytecode.
         */
        PristineCode: StorageDescriptor<[Key: FixedSizeBinary<32>], Binary, true, never>;
        /**
         * The data associated to a contract or externally owned account.
         */
        AccountInfoOf: StorageDescriptor<[Key: FixedSizeBinary<20>], Anonymize<I14i9pui8lc778>, true, never>;
        /**
         * Map a Ethereum address to its original `AccountId32`.
         *
         * When deriving a `H160` from an `AccountId32` we use a hash function. In order to
         * reconstruct the original account we need to store the reverse mapping here.
         * Register your `AccountId32` using [`Pallet::map_account`] in order to
         * use it with this pallet.
         */
        OriginalAccount: StorageDescriptor<[Key: FixedSizeBinary<20>], SS58String, true, never>;
    };
};
type ICalls = {
    Revive: {
        /**
         * Makes a call to an account, optionally transferring some balance.
         *
         * # Parameters
         *
         * * `dest`: Address of the contract to call.
         * * `value`: The balance to transfer from the `origin` to `dest`.
         * * `gas_limit`: The gas limit enforced when executing the constructor.
         * * `storage_deposit_limit`: The maximum amount of balance that can be charged from the
         * caller to pay for the storage consumed.
         * * `data`: The input data to pass to the contract.
         *
         * * If the account is a smart-contract account, the associated code will be
         * executed and any value will be transferred.
         * * If the account is a regular account, any value will be transferred.
         * * If no account exists and the call value is not less than `existential_deposit`,
         * a regular account will be created and any value will be transferred.
         */
        call: TxDescriptor<Anonymize<Idsg8aod8e8fqn>>;
        /**
         * Instantiates a contract from a previously deployed vm binary.
         *
         * This function is identical to [`Self::instantiate_with_code`] but without the
         * code deployment step. Instead, the `code_hash` of an on-chain deployed vm binary
         * must be supplied.
         */
        instantiate: TxDescriptor<Anonymize<I46nktn22m6hbi>>;
        /**
         * Instantiates a new contract from the supplied `code` optionally transferring
         * some balance.
         *
         * This dispatchable has the same effect as calling [`Self::upload_code`] +
         * [`Self::instantiate`]. Bundling them together provides efficiency gains. Please
         * also check the documentation of [`Self::upload_code`].
         *
         * # Parameters
         *
         * * `value`: The balance to transfer from the `origin` to the newly created contract.
         * * `gas_limit`: The gas limit enforced when executing the constructor.
         * * `storage_deposit_limit`: The maximum amount of balance that can be charged/reserved
         * from the caller to pay for the storage consumed.
         * * `code`: The contract code to deploy in raw bytes.
         * * `data`: The input data to pass to the contract constructor.
         * * `salt`: Used for the address derivation. If `Some` is supplied then `CREATE2`
         * semantics are used. If `None` then `CRATE1` is used.
         *
         *
         * Instantiation is executed as follows:
         *
         * - The supplied `code` is deployed, and a `code_hash` is created for that code.
         * - If the `code_hash` already exists on the chain the underlying `code` will be shared.
         * - The destination address is computed based on the sender, code_hash and the salt.
         * - The smart-contract account is created at the computed address.
         * - The `value` is transferred to the new account.
         * - The `deploy` function is executed in the context of the newly-created account.
         */
        instantiate_with_code: TxDescriptor<Anonymize<Ibgj1cthra7lte>>;
    };
};
type IEvent = {};
type IError = {
    System: {
        /**
         * The name of specification does not match between the current runtime
         * and the new runtime.
         */
        InvalidSpecName: PlainDescriptor<undefined>;
        /**
         * The specification version is not allowed to decrease between the current runtime
         * and the new runtime.
         */
        SpecVersionNeedsToIncrease: PlainDescriptor<undefined>;
        /**
         * Failed to extract the runtime version from the new runtime.
         *
         * Either calling `Core_version` or decoding `RuntimeVersion` failed.
         */
        FailedToExtractRuntimeVersion: PlainDescriptor<undefined>;
        /**
         * Suicide called when the account has non-default composite data.
         */
        NonDefaultComposite: PlainDescriptor<undefined>;
        /**
         * There is a non-zero reference count preventing the account from being purged.
         */
        NonZeroRefCount: PlainDescriptor<undefined>;
        /**
         * The origin filter prevent the call to be dispatched.
         */
        CallFiltered: PlainDescriptor<undefined>;
        /**
         * A multi-block migration is ongoing and prevents the current code from being replaced.
         */
        MultiBlockMigrationsOngoing: PlainDescriptor<undefined>;
        /**
         * No upgrade authorized.
         */
        NothingAuthorized: PlainDescriptor<undefined>;
        /**
         * The submitted code is not authorized.
         */
        Unauthorized: PlainDescriptor<undefined>;
    };
    ParachainSystem: {
        /**
         * Attempt to upgrade validation function while existing upgrade pending.
         */
        OverlappingUpgrades: PlainDescriptor<undefined>;
        /**
         * Polkadot currently prohibits this parachain from upgrading its validation function.
         */
        ProhibitedByPolkadot: PlainDescriptor<undefined>;
        /**
         * The supplied validation function has compiled into a blob larger than Polkadot is
         * willing to run.
         */
        TooBig: PlainDescriptor<undefined>;
        /**
         * The inherent which supplies the validation data did not run this block.
         */
        ValidationDataNotAvailable: PlainDescriptor<undefined>;
        /**
         * The inherent which supplies the host configuration did not run this block.
         */
        HostConfigurationNotAvailable: PlainDescriptor<undefined>;
        /**
         * No validation function upgrade is currently scheduled.
         */
        NotScheduled: PlainDescriptor<undefined>;
    };
    MultiBlockMigrations: {
        /**
         * The operation cannot complete since some MBMs are ongoing.
         */
        Ongoing: PlainDescriptor<undefined>;
    };
    Balances: {
        /**
         * Vesting balance too high to send value.
         */
        VestingBalance: PlainDescriptor<undefined>;
        /**
         * Account liquidity restrictions prevent withdrawal.
         */
        LiquidityRestrictions: PlainDescriptor<undefined>;
        /**
         * Balance too low to send value.
         */
        InsufficientBalance: PlainDescriptor<undefined>;
        /**
         * Value too low to create account due to existential deposit.
         */
        ExistentialDeposit: PlainDescriptor<undefined>;
        /**
         * Transfer/payment would kill account.
         */
        Expendability: PlainDescriptor<undefined>;
        /**
         * A vesting schedule already exists for this account.
         */
        ExistingVestingSchedule: PlainDescriptor<undefined>;
        /**
         * Beneficiary account must pre-exist.
         */
        DeadAccount: PlainDescriptor<undefined>;
        /**
         * Number of named reserves exceed `MaxReserves`.
         */
        TooManyReserves: PlainDescriptor<undefined>;
        /**
         * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
         */
        TooManyHolds: PlainDescriptor<undefined>;
        /**
         * Number of freezes exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
        /**
         * The issuance cannot be modified since it is already deactivated.
         */
        IssuanceDeactivated: PlainDescriptor<undefined>;
        /**
         * The delta cannot be zero.
         */
        DeltaZero: PlainDescriptor<undefined>;
    };
    CollatorSelection: {
        /**
         * The pallet has too many candidates.
         */
        TooManyCandidates: PlainDescriptor<undefined>;
        /**
         * Leaving would result in too few candidates.
         */
        TooFewEligibleCollators: PlainDescriptor<undefined>;
        /**
         * Account is already a candidate.
         */
        AlreadyCandidate: PlainDescriptor<undefined>;
        /**
         * Account is not a candidate.
         */
        NotCandidate: PlainDescriptor<undefined>;
        /**
         * There are too many Invulnerables.
         */
        TooManyInvulnerables: PlainDescriptor<undefined>;
        /**
         * Account is already an Invulnerable.
         */
        AlreadyInvulnerable: PlainDescriptor<undefined>;
        /**
         * Account is not an Invulnerable.
         */
        NotInvulnerable: PlainDescriptor<undefined>;
        /**
         * Account has no associated validator ID.
         */
        NoAssociatedValidatorId: PlainDescriptor<undefined>;
        /**
         * Validator ID is not yet registered.
         */
        ValidatorNotRegistered: PlainDescriptor<undefined>;
        /**
         * Could not insert in the candidate list.
         */
        InsertToCandidateListFailed: PlainDescriptor<undefined>;
        /**
         * Could not remove from the candidate list.
         */
        RemoveFromCandidateListFailed: PlainDescriptor<undefined>;
        /**
         * New deposit amount would be below the minimum candidacy bond.
         */
        DepositTooLow: PlainDescriptor<undefined>;
        /**
         * Could not update the candidate list.
         */
        UpdateCandidateListFailed: PlainDescriptor<undefined>;
        /**
         * Deposit amount is too low to take the target's slot in the candidate list.
         */
        InsufficientBond: PlainDescriptor<undefined>;
        /**
         * The target account to be replaced in the candidate list is not a candidate.
         */
        TargetIsNotCandidate: PlainDescriptor<undefined>;
        /**
         * The updated deposit amount is equal to the amount already reserved.
         */
        IdenticalDeposit: PlainDescriptor<undefined>;
        /**
         * Cannot lower candidacy bond while occupying a future collator slot in the list.
         */
        InvalidUnreserve: PlainDescriptor<undefined>;
    };
    Session: {
        /**
         * Invalid ownership proof.
         */
        InvalidProof: PlainDescriptor<undefined>;
        /**
         * No associated validator ID for account.
         */
        NoAssociatedValidatorId: PlainDescriptor<undefined>;
        /**
         * Registered duplicate key.
         */
        DuplicatedKey: PlainDescriptor<undefined>;
        /**
         * No keys are associated with this account.
         */
        NoKeys: PlainDescriptor<undefined>;
        /**
         * Key setting account is not live, so it's impossible to associate keys.
         */
        NoAccount: PlainDescriptor<undefined>;
    };
    XcmpQueue: {
        /**
         * Setting the queue config failed since one of its values was invalid.
         */
        BadQueueConfig: PlainDescriptor<undefined>;
        /**
         * The execution is already suspended.
         */
        AlreadySuspended: PlainDescriptor<undefined>;
        /**
         * The execution is already resumed.
         */
        AlreadyResumed: PlainDescriptor<undefined>;
        /**
         * There are too many active outbound channels.
         */
        TooManyActiveOutboundChannels: PlainDescriptor<undefined>;
        /**
         * The message is too big.
         */
        TooBig: PlainDescriptor<undefined>;
    };
    PolkadotXcm: {
        /**
         * The desired destination was unreachable, generally because there is a no way of routing
         * to it.
         */
        Unreachable: PlainDescriptor<undefined>;
        /**
         * There was some other issue (i.e. not to do with routing) in sending the message.
         * Perhaps a lack of space for buffering the message.
         */
        SendFailure: PlainDescriptor<undefined>;
        /**
         * The message execution fails the filter.
         */
        Filtered: PlainDescriptor<undefined>;
        /**
         * The message's weight could not be determined.
         */
        UnweighableMessage: PlainDescriptor<undefined>;
        /**
         * The destination `Location` provided cannot be inverted.
         */
        DestinationNotInvertible: PlainDescriptor<undefined>;
        /**
         * The assets to be sent are empty.
         */
        Empty: PlainDescriptor<undefined>;
        /**
         * Could not re-anchor the assets to declare the fees for the destination chain.
         */
        CannotReanchor: PlainDescriptor<undefined>;
        /**
         * Too many assets have been attempted for transfer.
         */
        TooManyAssets: PlainDescriptor<undefined>;
        /**
         * Origin is invalid for sending.
         */
        InvalidOrigin: PlainDescriptor<undefined>;
        /**
         * The version of the `Versioned` value used is not able to be interpreted.
         */
        BadVersion: PlainDescriptor<undefined>;
        /**
         * The given location could not be used (e.g. because it cannot be expressed in the
         * desired version of XCM).
         */
        BadLocation: PlainDescriptor<undefined>;
        /**
         * The referenced subscription could not be found.
         */
        NoSubscription: PlainDescriptor<undefined>;
        /**
         * The location is invalid since it already has a subscription from us.
         */
        AlreadySubscribed: PlainDescriptor<undefined>;
        /**
         * Could not check-out the assets for teleportation to the destination chain.
         */
        CannotCheckOutTeleport: PlainDescriptor<undefined>;
        /**
         * The owner does not own (all) of the asset that they wish to do the operation on.
         */
        LowBalance: PlainDescriptor<undefined>;
        /**
         * The asset owner has too many locks on the asset.
         */
        TooManyLocks: PlainDescriptor<undefined>;
        /**
         * The given account is not an identifiable sovereign account for any location.
         */
        AccountNotSovereign: PlainDescriptor<undefined>;
        /**
         * The operation required fees to be paid which the initiator could not meet.
         */
        FeesNotMet: PlainDescriptor<undefined>;
        /**
         * A remote lock with the corresponding data could not be found.
         */
        LockNotFound: PlainDescriptor<undefined>;
        /**
         * The unlock operation cannot succeed because there are still consumers of the lock.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid asset, reserve chain could not be determined for it.
         */
        InvalidAssetUnknownReserve: PlainDescriptor<undefined>;
        /**
         * Invalid asset, do not support remote asset reserves with different fees reserves.
         */
        InvalidAssetUnsupportedReserve: PlainDescriptor<undefined>;
        /**
         * Too many assets with different reserve locations have been attempted for transfer.
         */
        TooManyReserves: PlainDescriptor<undefined>;
        /**
         * Local XCM execution incomplete.
         */
        LocalExecutionIncomplete: PlainDescriptor<undefined>;
        /**
         * Too many locations authorized to alias origin.
         */
        TooManyAuthorizedAliases: PlainDescriptor<undefined>;
        /**
         * Expiry block number is in the past.
         */
        ExpiresInPast: PlainDescriptor<undefined>;
        /**
         * The alias to remove authorization for was not found.
         */
        AliasNotFound: PlainDescriptor<undefined>;
        /**
         * Local XCM execution incomplete with the actual XCM error and the index of the
         * instruction that caused the error.
         */
        LocalExecutionIncompleteWithError: PlainDescriptor<Anonymize<I5r8t4iaend96p>>;
    };
    MessageQueue: {
        /**
         * Page is not reapable because it has items remaining to be processed and is not old
         * enough.
         */
        NotReapable: PlainDescriptor<undefined>;
        /**
         * Page to be reaped does not exist.
         */
        NoPage: PlainDescriptor<undefined>;
        /**
         * The referenced message could not be found.
         */
        NoMessage: PlainDescriptor<undefined>;
        /**
         * The message was already processed and cannot be processed again.
         */
        AlreadyProcessed: PlainDescriptor<undefined>;
        /**
         * The message is queued for future execution.
         */
        Queued: PlainDescriptor<undefined>;
        /**
         * There is temporarily not enough weight to continue servicing messages.
         */
        InsufficientWeight: PlainDescriptor<undefined>;
        /**
         * This message is temporarily unprocessable.
         *
         * Such errors are expected, but not guaranteed, to resolve themselves eventually through
         * retrying.
         */
        TemporarilyUnprocessable: PlainDescriptor<undefined>;
        /**
         * The queue is paused and no message can be executed from it.
         *
         * This can change at any time and may resolve in the future by re-trying.
         */
        QueuePaused: PlainDescriptor<undefined>;
        /**
         * Another call is in progress and needs to finish before this call can happen.
         */
        RecursiveDisallowed: PlainDescriptor<undefined>;
    };
    SnowbridgeSystemFrontend: {
        /**
         * Convert versioned location failure
         */
        UnsupportedLocationVersion: PlainDescriptor<undefined>;
        /**
         * Check location failure, should start from the dispatch origin as owner
         */
        InvalidAssetOwner: PlainDescriptor<undefined>;
        /**
         * Send xcm message failure
         */
        SendFailure: PlainDescriptor<undefined>;
        /**
         * Withdraw fee asset failure
         */
        FeesNotMet: PlainDescriptor<undefined>;
        /**
         * Convert to reanchored location failure
         */
        LocationConversionFailed: PlainDescriptor<undefined>;
        /**
         * Message export is halted
         */
        Halted: PlainDescriptor<undefined>;
        /**
         * The desired destination was unreachable, generally because there is a no way of routing
         * to it.
         */
        Unreachable: PlainDescriptor<undefined>;
        /**
         * The asset provided for the tip is unsupported.
         */
        UnsupportedAsset: PlainDescriptor<undefined>;
        /**
         * Unable to withdraw asset.
         */
        WithdrawError: PlainDescriptor<undefined>;
        /**
         * Account could not be converted to a location.
         */
        InvalidAccount: PlainDescriptor<undefined>;
        /**
         * Provided tip asset could not be swapped for ether.
         */
        SwapError: PlainDescriptor<undefined>;
        /**
         * Ether could not be burned.
         */
        BurnError: PlainDescriptor<undefined>;
        /**
         * The tip provided is zero.
         */
        TipAmountZero: PlainDescriptor<undefined>;
    };
    Utility: {
        /**
         * Too many calls batched.
         */
        TooManyCalls: PlainDescriptor<undefined>;
    };
    Multisig: {
        /**
         * Threshold must be 2 or greater.
         */
        MinimumThreshold: PlainDescriptor<undefined>;
        /**
         * Call is already approved by this signatory.
         */
        AlreadyApproved: PlainDescriptor<undefined>;
        /**
         * Call doesn't need any (more) approvals.
         */
        NoApprovalsNeeded: PlainDescriptor<undefined>;
        /**
         * There are too few signatories in the list.
         */
        TooFewSignatories: PlainDescriptor<undefined>;
        /**
         * There are too many signatories in the list.
         */
        TooManySignatories: PlainDescriptor<undefined>;
        /**
         * The signatories were provided out of order; they should be ordered.
         */
        SignatoriesOutOfOrder: PlainDescriptor<undefined>;
        /**
         * The sender was contained in the other signatories; it shouldn't be.
         */
        SenderInSignatories: PlainDescriptor<undefined>;
        /**
         * Multisig operation not found in storage.
         */
        NotFound: PlainDescriptor<undefined>;
        /**
         * Only the account that originally created the multisig is able to cancel it or update
         * its deposits.
         */
        NotOwner: PlainDescriptor<undefined>;
        /**
         * No timepoint was given, yet the multisig operation is already underway.
         */
        NoTimepoint: PlainDescriptor<undefined>;
        /**
         * A different timepoint was given to the multisig operation that is underway.
         */
        WrongTimepoint: PlainDescriptor<undefined>;
        /**
         * A timepoint was given, yet no multisig operation is underway.
         */
        UnexpectedTimepoint: PlainDescriptor<undefined>;
        /**
         * The maximum weight information provided was too low.
         */
        MaxWeightTooLow: PlainDescriptor<undefined>;
        /**
         * The data to be stored is already stored.
         */
        AlreadyStored: PlainDescriptor<undefined>;
    };
    Proxy: {
        /**
         * There are too many proxies registered or too many announcements pending.
         */
        TooMany: PlainDescriptor<undefined>;
        /**
         * Proxy registration not found.
         */
        NotFound: PlainDescriptor<undefined>;
        /**
         * Sender is not a proxy of the account to be proxied.
         */
        NotProxy: PlainDescriptor<undefined>;
        /**
         * A call which is incompatible with the proxy type's filter was attempted.
         */
        Unproxyable: PlainDescriptor<undefined>;
        /**
         * Account is already a proxy.
         */
        Duplicate: PlainDescriptor<undefined>;
        /**
         * Call may not be made by proxy because it may escalate its privileges.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * Announcement, if made at all, was made too recently.
         */
        Unannounced: PlainDescriptor<undefined>;
        /**
         * Cannot add self as proxy.
         */
        NoSelfProxy: PlainDescriptor<undefined>;
    };
    Assets: {
        /**
         * Account balance must be greater than or equal to the transfer amount.
         */
        BalanceLow: PlainDescriptor<undefined>;
        /**
         * The account to alter does not exist.
         */
        NoAccount: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given asset ID is unknown.
         */
        Unknown: PlainDescriptor<undefined>;
        /**
         * The origin account is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The asset ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Minimum balance should be non-zero.
         */
        MinBalanceZero: PlainDescriptor<undefined>;
        /**
         * Unable to increment the consumer reference counters on the account. Either no provider
         * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
         * fewer then the maximum number of consumers has been reached.
         */
        UnavailableConsumer: PlainDescriptor<undefined>;
        /**
         * Invalid metadata given.
         */
        BadMetadata: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The source account would not survive the transfer and it needs to stay alive.
         */
        WouldDie: PlainDescriptor<undefined>;
        /**
         * The asset-account already exists.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The asset-account doesn't have an associated deposit.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The operation would result in funds being burned.
         */
        WouldBurn: PlainDescriptor<undefined>;
        /**
         * The asset is a live asset and is actively being used. Usually emit for operations such
         * as `start_destroy` which require the asset to be in a destroying state.
         */
        LiveAsset: PlainDescriptor<undefined>;
        /**
         * The asset is not live, and likely being destroyed.
         */
        AssetNotLive: PlainDescriptor<undefined>;
        /**
         * The asset status is not the expected status.
         */
        IncorrectStatus: PlainDescriptor<undefined>;
        /**
         * The asset should be frozen before the given operation.
         */
        NotFrozen: PlainDescriptor<undefined>;
        /**
         * Callback action resulted in error
         */
        CallbackFailed: PlainDescriptor<undefined>;
        /**
         * The asset ID must be equal to the [`NextAssetId`].
         */
        BadAssetId: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain freezes.
         */
        ContainsFreezes: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain holds.
         */
        ContainsHolds: PlainDescriptor<undefined>;
    };
    Uniques: {
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownCollection: PlainDescriptor<undefined>;
        /**
         * The item ID has already been used for an item.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The owner turned out to be different to what was expected.
         */
        WrongOwner: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * The item ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * The item or collection is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The delegate turned out to be different to what was expected.
         */
        WrongDelegate: PlainDescriptor<undefined>;
        /**
         * There is no delegate approved.
         */
        NoDelegate: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The named owner has not signed ownership of the collection is acceptable.
         */
        Unaccepted: PlainDescriptor<undefined>;
        /**
         * The item is locked.
         */
        Locked: PlainDescriptor<undefined>;
        /**
         * All items have been minted.
         */
        MaxSupplyReached: PlainDescriptor<undefined>;
        /**
         * The max supply has already been set.
         */
        MaxSupplyAlreadySet: PlainDescriptor<undefined>;
        /**
         * The provided max supply is less to the amount of items a collection already has.
         */
        MaxSupplyTooSmall: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownItem: PlainDescriptor<undefined>;
        /**
         * Item is not for sale.
         */
        NotForSale: PlainDescriptor<undefined>;
        /**
         * The provided bid is too low.
         */
        BidTooLow: PlainDescriptor<undefined>;
        /**
         * No metadata is found.
         */
        NoMetadata: PlainDescriptor<undefined>;
        /**
         * Wrong metadata key/value bytes supplied.
         */
        WrongMetadata: PlainDescriptor<undefined>;
        /**
         * An attribute is not found.
         */
        AttributeNotFound: PlainDescriptor<undefined>;
        /**
         * Wrong attribute key/value bytes supplied.
         */
        WrongAttribute: PlainDescriptor<undefined>;
    };
    Nfts: {
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownCollection: PlainDescriptor<undefined>;
        /**
         * The item ID has already been used for an item.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The approval had a deadline that expired, so the approval isn't valid anymore.
         */
        ApprovalExpired: PlainDescriptor<undefined>;
        /**
         * The owner turned out to be different to what was expected.
         */
        WrongOwner: PlainDescriptor<undefined>;
        /**
         * The witness data given does not match the current state of the chain.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Collection ID is already taken.
         */
        CollectionIdInUse: PlainDescriptor<undefined>;
        /**
         * Items within that collection are non-transferable.
         */
        ItemsNonTransferable: PlainDescriptor<undefined>;
        /**
         * The provided account is not a delegate.
         */
        NotDelegate: PlainDescriptor<undefined>;
        /**
         * The delegate turned out to be different to what was expected.
         */
        WrongDelegate: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The named owner has not signed ownership acceptance of the collection.
         */
        Unaccepted: PlainDescriptor<undefined>;
        /**
         * The item is locked (non-transferable).
         */
        ItemLocked: PlainDescriptor<undefined>;
        /**
         * Item's attributes are locked.
         */
        LockedItemAttributes: PlainDescriptor<undefined>;
        /**
         * Collection's attributes are locked.
         */
        LockedCollectionAttributes: PlainDescriptor<undefined>;
        /**
         * Item's metadata is locked.
         */
        LockedItemMetadata: PlainDescriptor<undefined>;
        /**
         * Collection's metadata is locked.
         */
        LockedCollectionMetadata: PlainDescriptor<undefined>;
        /**
         * All items have been minted.
         */
        MaxSupplyReached: PlainDescriptor<undefined>;
        /**
         * The max supply is locked and can't be changed.
         */
        MaxSupplyLocked: PlainDescriptor<undefined>;
        /**
         * The provided max supply is less than the number of items a collection already has.
         */
        MaxSupplyTooSmall: PlainDescriptor<undefined>;
        /**
         * The given item ID is unknown.
         */
        UnknownItem: PlainDescriptor<undefined>;
        /**
         * Swap doesn't exist.
         */
        UnknownSwap: PlainDescriptor<undefined>;
        /**
         * The given item has no metadata set.
         */
        MetadataNotFound: PlainDescriptor<undefined>;
        /**
         * The provided attribute can't be found.
         */
        AttributeNotFound: PlainDescriptor<undefined>;
        /**
         * Item is not for sale.
         */
        NotForSale: PlainDescriptor<undefined>;
        /**
         * The provided bid is too low.
         */
        BidTooLow: PlainDescriptor<undefined>;
        /**
         * The item has reached its approval limit.
         */
        ReachedApprovalLimit: PlainDescriptor<undefined>;
        /**
         * The deadline has already expired.
         */
        DeadlineExpired: PlainDescriptor<undefined>;
        /**
         * The duration provided should be less than or equal to `MaxDeadlineDuration`.
         */
        WrongDuration: PlainDescriptor<undefined>;
        /**
         * The method is disabled by system settings.
         */
        MethodDisabled: PlainDescriptor<undefined>;
        /**
         * The provided setting can't be set.
         */
        WrongSetting: PlainDescriptor<undefined>;
        /**
         * Item's config already exists and should be equal to the provided one.
         */
        InconsistentItemConfig: PlainDescriptor<undefined>;
        /**
         * Config for a collection or an item can't be found.
         */
        NoConfig: PlainDescriptor<undefined>;
        /**
         * Some roles were not cleared.
         */
        RolesNotCleared: PlainDescriptor<undefined>;
        /**
         * Mint has not started yet.
         */
        MintNotStarted: PlainDescriptor<undefined>;
        /**
         * Mint has already ended.
         */
        MintEnded: PlainDescriptor<undefined>;
        /**
         * The provided Item was already used for claiming.
         */
        AlreadyClaimed: PlainDescriptor<undefined>;
        /**
         * The provided data is incorrect.
         */
        IncorrectData: PlainDescriptor<undefined>;
        /**
         * The extrinsic was sent by the wrong origin.
         */
        WrongOrigin: PlainDescriptor<undefined>;
        /**
         * The provided signature is incorrect.
         */
        WrongSignature: PlainDescriptor<undefined>;
        /**
         * The provided metadata might be too long.
         */
        IncorrectMetadata: PlainDescriptor<undefined>;
        /**
         * Can't set more attributes per one call.
         */
        MaxAttributesLimitReached: PlainDescriptor<undefined>;
        /**
         * The provided namespace isn't supported in this call.
         */
        WrongNamespace: PlainDescriptor<undefined>;
        /**
         * Can't delete non-empty collections.
         */
        CollectionNotEmpty: PlainDescriptor<undefined>;
        /**
         * The witness data should be provided.
         */
        WitnessRequired: PlainDescriptor<undefined>;
    };
    ForeignAssets: {
        /**
         * Account balance must be greater than or equal to the transfer amount.
         */
        BalanceLow: PlainDescriptor<undefined>;
        /**
         * The account to alter does not exist.
         */
        NoAccount: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given asset ID is unknown.
         */
        Unknown: PlainDescriptor<undefined>;
        /**
         * The origin account is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The asset ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Minimum balance should be non-zero.
         */
        MinBalanceZero: PlainDescriptor<undefined>;
        /**
         * Unable to increment the consumer reference counters on the account. Either no provider
         * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
         * fewer then the maximum number of consumers has been reached.
         */
        UnavailableConsumer: PlainDescriptor<undefined>;
        /**
         * Invalid metadata given.
         */
        BadMetadata: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The source account would not survive the transfer and it needs to stay alive.
         */
        WouldDie: PlainDescriptor<undefined>;
        /**
         * The asset-account already exists.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The asset-account doesn't have an associated deposit.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The operation would result in funds being burned.
         */
        WouldBurn: PlainDescriptor<undefined>;
        /**
         * The asset is a live asset and is actively being used. Usually emit for operations such
         * as `start_destroy` which require the asset to be in a destroying state.
         */
        LiveAsset: PlainDescriptor<undefined>;
        /**
         * The asset is not live, and likely being destroyed.
         */
        AssetNotLive: PlainDescriptor<undefined>;
        /**
         * The asset status is not the expected status.
         */
        IncorrectStatus: PlainDescriptor<undefined>;
        /**
         * The asset should be frozen before the given operation.
         */
        NotFrozen: PlainDescriptor<undefined>;
        /**
         * Callback action resulted in error
         */
        CallbackFailed: PlainDescriptor<undefined>;
        /**
         * The asset ID must be equal to the [`NextAssetId`].
         */
        BadAssetId: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain freezes.
         */
        ContainsFreezes: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain holds.
         */
        ContainsHolds: PlainDescriptor<undefined>;
    };
    NftFractionalization: {
        /**
         * Asset ID does not correspond to locked NFT.
         */
        IncorrectAssetId: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * NFT doesn't exist.
         */
        NftNotFound: PlainDescriptor<undefined>;
        /**
         * NFT has not yet been fractionalised.
         */
        NftNotFractionalized: PlainDescriptor<undefined>;
    };
    PoolAssets: {
        /**
         * Account balance must be greater than or equal to the transfer amount.
         */
        BalanceLow: PlainDescriptor<undefined>;
        /**
         * The account to alter does not exist.
         */
        NoAccount: PlainDescriptor<undefined>;
        /**
         * The signing account has no permission to do the operation.
         */
        NoPermission: PlainDescriptor<undefined>;
        /**
         * The given asset ID is unknown.
         */
        Unknown: PlainDescriptor<undefined>;
        /**
         * The origin account is frozen.
         */
        Frozen: PlainDescriptor<undefined>;
        /**
         * The asset ID is already taken.
         */
        InUse: PlainDescriptor<undefined>;
        /**
         * Invalid witness data given.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Minimum balance should be non-zero.
         */
        MinBalanceZero: PlainDescriptor<undefined>;
        /**
         * Unable to increment the consumer reference counters on the account. Either no provider
         * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
         * fewer then the maximum number of consumers has been reached.
         */
        UnavailableConsumer: PlainDescriptor<undefined>;
        /**
         * Invalid metadata given.
         */
        BadMetadata: PlainDescriptor<undefined>;
        /**
         * No approval exists that would allow the transfer.
         */
        Unapproved: PlainDescriptor<undefined>;
        /**
         * The source account would not survive the transfer and it needs to stay alive.
         */
        WouldDie: PlainDescriptor<undefined>;
        /**
         * The asset-account already exists.
         */
        AlreadyExists: PlainDescriptor<undefined>;
        /**
         * The asset-account doesn't have an associated deposit.
         */
        NoDeposit: PlainDescriptor<undefined>;
        /**
         * The operation would result in funds being burned.
         */
        WouldBurn: PlainDescriptor<undefined>;
        /**
         * The asset is a live asset and is actively being used. Usually emit for operations such
         * as `start_destroy` which require the asset to be in a destroying state.
         */
        LiveAsset: PlainDescriptor<undefined>;
        /**
         * The asset is not live, and likely being destroyed.
         */
        AssetNotLive: PlainDescriptor<undefined>;
        /**
         * The asset status is not the expected status.
         */
        IncorrectStatus: PlainDescriptor<undefined>;
        /**
         * The asset should be frozen before the given operation.
         */
        NotFrozen: PlainDescriptor<undefined>;
        /**
         * Callback action resulted in error
         */
        CallbackFailed: PlainDescriptor<undefined>;
        /**
         * The asset ID must be equal to the [`NextAssetId`].
         */
        BadAssetId: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain freezes.
         */
        ContainsFreezes: PlainDescriptor<undefined>;
        /**
         * The asset cannot be destroyed because some accounts for this asset contain holds.
         */
        ContainsHolds: PlainDescriptor<undefined>;
    };
    AssetConversion: {
        /**
         * Provided asset pair is not supported for pool.
         */
        InvalidAssetPair: PlainDescriptor<undefined>;
        /**
         * Pool already exists.
         */
        PoolExists: PlainDescriptor<undefined>;
        /**
         * Desired amount can't be zero.
         */
        WrongDesiredAmount: PlainDescriptor<undefined>;
        /**
         * Provided amount should be greater than or equal to the existential deposit/asset's
         * minimal amount.
         */
        AmountOneLessThanMinimal: PlainDescriptor<undefined>;
        /**
         * Provided amount should be greater than or equal to the existential deposit/asset's
         * minimal amount.
         */
        AmountTwoLessThanMinimal: PlainDescriptor<undefined>;
        /**
         * Reserve needs to always be greater than or equal to the existential deposit/asset's
         * minimal amount.
         */
        ReserveLeftLessThanMinimal: PlainDescriptor<undefined>;
        /**
         * Desired amount can't be equal to the pool reserve.
         */
        AmountOutTooHigh: PlainDescriptor<undefined>;
        /**
         * The pool doesn't exist.
         */
        PoolNotFound: PlainDescriptor<undefined>;
        /**
         * An overflow happened.
         */
        Overflow: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the first token in the pair wasn't met.
         */
        AssetOneDepositDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the second token in the pair wasn't met.
         */
        AssetTwoDepositDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the first token in the pair wasn't met.
         */
        AssetOneWithdrawalDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * The minimal amount requirement for the second token in the pair wasn't met.
         */
        AssetTwoWithdrawalDidNotMeetMinimum: PlainDescriptor<undefined>;
        /**
         * Optimal calculated amount is less than desired.
         */
        OptimalAmountLessThanDesired: PlainDescriptor<undefined>;
        /**
         * Insufficient liquidity minted.
         */
        InsufficientLiquidityMinted: PlainDescriptor<undefined>;
        /**
         * Requested liquidity can't be zero.
         */
        ZeroLiquidity: PlainDescriptor<undefined>;
        /**
         * Amount can't be zero.
         */
        ZeroAmount: PlainDescriptor<undefined>;
        /**
         * Calculated amount out is less than provided minimum amount.
         */
        ProvidedMinimumNotSufficientForSwap: PlainDescriptor<undefined>;
        /**
         * Provided maximum amount is not sufficient for swap.
         */
        ProvidedMaximumNotSufficientForSwap: PlainDescriptor<undefined>;
        /**
         * The provided path must consists of 2 assets at least.
         */
        InvalidPath: PlainDescriptor<undefined>;
        /**
         * The provided path must consists of unique assets.
         */
        NonUniquePath: PlainDescriptor<undefined>;
        /**
         * It was not possible to get or increment the Id of the pool.
         */
        IncorrectPoolAssetId: PlainDescriptor<undefined>;
        /**
         * The destination account cannot exist with the swapped funds.
         */
        BelowMinimum: PlainDescriptor<undefined>;
    };
    AssetsFreezer: {
        /**
         * Number of freezes on an account would exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
    };
    ForeignAssetsFreezer: {
        /**
         * Number of freezes on an account would exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
    };
    PoolAssetsFreezer: {
        /**
         * Number of freezes on an account would exceed `MaxFreezes`.
         */
        TooManyFreezes: PlainDescriptor<undefined>;
    };
    Revive: {
        /**
         * Invalid schedule supplied, e.g. with zero weight of a basic operation.
         */
        InvalidSchedule: PlainDescriptor<undefined>;
        /**
         * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
         */
        InvalidCallFlags: PlainDescriptor<undefined>;
        /**
         * The executed contract exhausted its gas limit.
         */
        OutOfGas: PlainDescriptor<undefined>;
        /**
         * Performing the requested transfer failed. Probably because there isn't enough
         * free balance in the sender's account.
         */
        TransferFailed: PlainDescriptor<undefined>;
        /**
         * Performing a call was denied because the calling depth reached the limit
         * of what is specified in the schedule.
         */
        MaxCallDepthReached: PlainDescriptor<undefined>;
        /**
         * No contract was found at the specified address.
         */
        ContractNotFound: PlainDescriptor<undefined>;
        /**
         * No code could be found at the supplied code hash.
         */
        CodeNotFound: PlainDescriptor<undefined>;
        /**
         * No code info could be found at the supplied code hash.
         */
        CodeInfoNotFound: PlainDescriptor<undefined>;
        /**
         * A buffer outside of sandbox memory was passed to a contract API function.
         */
        OutOfBounds: PlainDescriptor<undefined>;
        /**
         * Input passed to a contract API function failed to decode as expected type.
         */
        DecodingFailed: PlainDescriptor<undefined>;
        /**
         * Contract trapped during execution.
         */
        ContractTrapped: PlainDescriptor<undefined>;
        /**
         * Event body or storage item exceeds [`limits::PAYLOAD_BYTES`].
         */
        ValueTooLarge: PlainDescriptor<undefined>;
        /**
         * Termination of a contract is not allowed while the contract is already
         * on the call stack. Can be triggered by `seal_terminate`.
         */
        TerminatedWhileReentrant: PlainDescriptor<undefined>;
        /**
         * `seal_call` forwarded this contracts input. It therefore is no longer available.
         */
        InputForwarded: PlainDescriptor<undefined>;
        /**
         * The amount of topics passed to `seal_deposit_events` exceeds the limit.
         */
        TooManyTopics: PlainDescriptor<undefined>;
        /**
         * A contract with the same AccountId already exists.
         */
        DuplicateContract: PlainDescriptor<undefined>;
        /**
         * A contract self destructed in its constructor.
         *
         * This can be triggered by a call to `seal_terminate`.
         */
        TerminatedInConstructor: PlainDescriptor<undefined>;
        /**
         * A call tried to invoke a contract that is flagged as non-reentrant.
         */
        ReentranceDenied: PlainDescriptor<undefined>;
        /**
         * A contract called into the runtime which then called back into this pallet.
         */
        ReenteredPallet: PlainDescriptor<undefined>;
        /**
         * A contract attempted to invoke a state modifying API while being in read-only mode.
         */
        StateChangeDenied: PlainDescriptor<undefined>;
        /**
         * Origin doesn't have enough balance to pay the required storage deposits.
         */
        StorageDepositNotEnoughFunds: PlainDescriptor<undefined>;
        /**
         * More storage was created than allowed by the storage deposit limit.
         */
        StorageDepositLimitExhausted: PlainDescriptor<undefined>;
        /**
         * Code removal was denied because the code is still in use by at least one contract.
         */
        CodeInUse: PlainDescriptor<undefined>;
        /**
         * The contract ran to completion but decided to revert its storage changes.
         * Please note that this error is only returned from extrinsics. When called directly
         * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
         * to determine whether a reversion has taken place.
         */
        ContractReverted: PlainDescriptor<undefined>;
        /**
         * The contract failed to compile or is missing the correct entry points.
         *
         * A more detailed error can be found on the node console if debug messages are enabled
         * by supplying `-lruntime::revive=debug`.
         */
        CodeRejected: PlainDescriptor<undefined>;
        /**
         * The code blob supplied is larger than [`limits::code::BLOB_BYTES`].
         */
        BlobTooLarge: PlainDescriptor<undefined>;
        /**
         * The contract declares too much memory (ro + rw + stack).
         */
        StaticMemoryTooLarge: PlainDescriptor<undefined>;
        /**
         * The program contains a basic block that is larger than allowed.
         */
        BasicBlockTooLarge: PlainDescriptor<undefined>;
        /**
         * The program contains an invalid instruction.
         */
        InvalidInstruction: PlainDescriptor<undefined>;
        /**
         * The contract has reached its maximum number of delegate dependencies.
         */
        MaxDelegateDependenciesReached: PlainDescriptor<undefined>;
        /**
         * The dependency was not found in the contract's delegate dependencies.
         */
        DelegateDependencyNotFound: PlainDescriptor<undefined>;
        /**
         * The contract already depends on the given delegate dependency.
         */
        DelegateDependencyAlreadyExists: PlainDescriptor<undefined>;
        /**
         * Can not add a delegate dependency to the code hash of the contract itself.
         */
        CannotAddSelfAsDelegateDependency: PlainDescriptor<undefined>;
        /**
         * Can not add more data to transient storage.
         */
        OutOfTransientStorage: PlainDescriptor<undefined>;
        /**
         * The contract tried to call a syscall which does not exist (at its current api level).
         */
        InvalidSyscall: PlainDescriptor<undefined>;
        /**
         * Invalid storage flags were passed to one of the storage syscalls.
         */
        InvalidStorageFlags: PlainDescriptor<undefined>;
        /**
         * PolkaVM failed during code execution. Probably due to a malformed program.
         */
        ExecutionFailed: PlainDescriptor<undefined>;
        /**
         * Failed to convert a U256 to a Balance.
         */
        BalanceConversionFailed: PlainDescriptor<undefined>;
        /**
         * Immutable data can only be set during deploys and only be read during calls.
         * Additionally, it is only valid to set the data once and it must not be empty.
         */
        InvalidImmutableAccess: PlainDescriptor<undefined>;
        /**
         * An `AccountID32` account tried to interact with the pallet without having a mapping.
         *
         * Call [`Pallet::map_account`] in order to create a mapping for the account.
         */
        AccountUnmapped: PlainDescriptor<undefined>;
        /**
         * Tried to map an account that is already mapped.
         */
        AccountAlreadyMapped: PlainDescriptor<undefined>;
        /**
         * The transaction used to dry-run a contract is invalid.
         */
        InvalidGenericTransaction: PlainDescriptor<undefined>;
        /**
         * The refcount of a code either over or underflowed.
         */
        RefcountOverOrUnderflow: PlainDescriptor<undefined>;
        /**
         * Unsupported precompile address.
         */
        UnsupportedPrecompileAddress: PlainDescriptor<undefined>;
        /**
         * The calldata exceeds [`limits::CALLDATA_BYTES`].
         */
        CallDataTooLarge: PlainDescriptor<undefined>;
        /**
         * The return data exceeds [`limits::CALLDATA_BYTES`].
         */
        ReturnDataTooLarge: PlainDescriptor<undefined>;
    };
    AssetRewards: {
        /**
         * The staker does not have enough tokens to perform the operation.
         */
        NotEnoughTokens: PlainDescriptor<undefined>;
        /**
         * An operation was attempted on a non-existent pool.
         */
        NonExistentPool: PlainDescriptor<undefined>;
        /**
         * An operation was attempted for a non-existent staker.
         */
        NonExistentStaker: PlainDescriptor<undefined>;
        /**
         * An operation was attempted with a non-existent asset.
         */
        NonExistentAsset: PlainDescriptor<undefined>;
        /**
         * There was an error converting a block number.
         */
        BlockNumberConversionError: PlainDescriptor<undefined>;
        /**
         * The expiry block must be in the future.
         */
        ExpiryBlockMustBeInTheFuture: PlainDescriptor<undefined>;
        /**
         * Insufficient funds to create the freeze.
         */
        InsufficientFunds: PlainDescriptor<undefined>;
        /**
         * The expiry block can be only extended.
         */
        ExpiryCut: PlainDescriptor<undefined>;
        /**
         * The reward rate per block can be only increased.
         */
        RewardRateCut: PlainDescriptor<undefined>;
        /**
         * The pool still has staked tokens or rewards.
         */
        NonEmptyPool: PlainDescriptor<undefined>;
    };
    StateTrieMigration: {
        /**
         * Max signed limits not respected.
         */
        MaxSignedLimits: PlainDescriptor<undefined>;
        /**
         * A key was longer than the configured maximum.
         *
         * This means that the migration halted at the current [`Progress`] and
         * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
         * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
         * The value should only be increased to avoid a storage migration for the currently
         * stored [`crate::Progress::LastKey`].
         */
        KeyTooLong: PlainDescriptor<undefined>;
        /**
         * submitter does not have enough funds.
         */
        NotEnoughFunds: PlainDescriptor<undefined>;
        /**
         * Bad witness data provided.
         */
        BadWitness: PlainDescriptor<undefined>;
        /**
         * Signed migration is not allowed because the maximum limit is not set yet.
         */
        SignedMigrationNotAllowed: PlainDescriptor<undefined>;
        /**
         * Bad child root provided.
         */
        BadChildRoot: PlainDescriptor<undefined>;
    };
    AssetConversionMigration: {
        /**
         * Provided asset pair is not supported for pool.
         */
        InvalidAssetPair: PlainDescriptor<undefined>;
        /**
         * The pool doesn't exist.
         */
        PoolNotFound: PlainDescriptor<undefined>;
        /**
         * Pool's balance cannot be zero.
         */
        ZeroBalance: PlainDescriptor<undefined>;
        /**
         * Indicates a partial transfer of balance to the new account during a migration.
         */
        PartialTransfer: PlainDescriptor<undefined>;
    };
    Sudo: {
        /**
         * Sender must be the Sudo account.
         */
        RequireSudo: PlainDescriptor<undefined>;
    };
};
type IConstants = {
    Revive: {
        /**
         * The ratio between the decimal representation of the native token and the ETH token.
         */
        NativeToEthRatio: PlainDescriptor<number>;
    };
};
type IViewFns = {};
type IRuntimeCalls = {
    /**
     * The API used to dry-run contract interactions.
     */
    ReviveApi: {
        /**
         * Returns the free balance of the given `[H160]` address, using EVM decimals.
         */
        balance: RuntimeDescriptor<[address: FixedSizeBinary<20>], Anonymize<I4totqt881mlti>>;
        /**
         * Perform a call from a specified account to a given contract.
         *
         * See [`crate::Pallet::bare_call`].
         */
        call: RuntimeDescriptor<[origin: SS58String, dest: FixedSizeBinary<20>, value: bigint, gas_limit: Anonymize<Iasb8k6ash5mjn>, storage_deposit_limit: Anonymize<I35p85j063s0il>, input_data: Binary], Anonymize<Ifo4pcqnbvdvrg>>;
        /**
         * Instantiate a new contract.
         *
         * See `[crate::Pallet::bare_instantiate]`.
         */
        instantiate: RuntimeDescriptor<[origin: SS58String, value: bigint, gas_limit: Anonymize<Iasb8k6ash5mjn>, storage_deposit_limit: Anonymize<I35p85j063s0il>, code: Anonymize<I9sijb8gfrns29>, data: Binary, salt: Anonymize<I4s6vifaf8k998>], Anonymize<Ici6p8aaddmsqt>>;
        /**
         * Query a given storage key in a given contract.
         *
         * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
         * specified account and `Ok(None)` if it doesn't. If the account specified by the address
         * doesn't exist, or doesn't have a contract then `Err` is returned.
         */
        get_storage: RuntimeDescriptor<[address: FixedSizeBinary<20>, key: FixedSizeBinary<32>], Anonymize<Iehnkjehe1oeva>>;
        /**
         * Query a given variable-sized storage key in a given contract.
         *
         * Returns `Ok(Some(Vec<u8>))` if the storage value exists under the given key in the
         * specified account and `Ok(None)` if it doesn't. If the account specified by the address
         * doesn't exist, or doesn't have a contract then `Err` is returned.
         */
        get_storage_var_key: RuntimeDescriptor<[address: FixedSizeBinary<20>, key: Binary], Anonymize<Iehnkjehe1oeva>>;
        /**
         * Dry run and return the trace of the given call.
         *
         * See eth-rpc `debug_traceCall` for usage.
         */
        trace_call: RuntimeDescriptor<[tx: Anonymize<I6f9v7emp7t5ba>, config: Anonymize<I63nhnkgg114n5>], Anonymize<Icifup6o102f4c>>;
    };
};
type IAsset = PlainDescriptor<Anonymize<If9iqq7i64mur8>>;
type PalletsTypedef = {
    __storage: IStorage;
    __tx: ICalls;
    __event: IEvent;
    __error: IError;
    __const: IConstants;
    __view: IViewFns;
};
type Passet = {
    descriptors: {
        pallets: PalletsTypedef;
        apis: IRuntimeCalls;
    } & Promise<any>;
    metadataTypes: Promise<Uint8Array>;
    asset: IAsset;
    getMetadata: () => Promise<Uint8Array>;
    genesis: string | undefined;
};

type SdkStorage<S extends InkStorageDescriptor, StorageErr> = NestedStorage<S, StorageErr> & RootStorage<S, StorageErr>;
type NestedStorage<S extends InkStorageDescriptor, StorageErr> = Exclude<keyof S, ""> extends never ? {} : {
    getNested<L extends string & Exclude<keyof S, "">>(label: L, ...args: S[L]["key"] extends undefined ? [] : [key: S[L]["key"]]): Promise<ResultPayload<S[L]["value"], StorageErr>>;
};
type RootStorage<S extends InkStorageDescriptor, StorageErr> = "" extends keyof S ? {
    getRoot(): Promise<ResultPayload<S[""]["value"] & UnNest<Omit<S, "">>, StorageErr>>;
} : {};
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type BuildNested<K extends string, V> = K extends `${infer P}.${infer Rest}` ? {
    [Key in P]: BuildNested<Rest, V>;
} : K extends "" ? V : {
    [Key in K]: V;
};
type UnNest<S extends InkStorageDescriptor> = UnionToIntersection<{
    [K in string & keyof S]: BuildNested<K, (...args: S[K]["key"] extends undefined ? [] : [key: S[K]["key"]]) => Promise<ResultPayload<S[K]["value"], StorageError>>>;
}[string & keyof S]>;

type CommonTypedApi = TypedApi<Passet> | TypedApi<WndAh>;
type ReadDeployerEvents<D extends GenericInkDescriptors, Addr> = (events?: Array<GenericEvent & {
    topics: FixedSizeBinary<number>[];
}>) => Array<{
    address: Addr;
    contractEvents: Array<D["__types"]["event"]>;
}>;
interface InkV5Sdk<T extends InkSdkTypedApi | ReviveSdkTypedApi, D extends GenericInkDescriptors, Addr, StorageErr> {
    getContract(adddress: Addr): Contract<T, D, Addr, StorageErr>;
    getDeployer(code: Binary): Deployer<T, D, Addr>;
    readDeploymentEvents: ReadDeployerEvents<D, Addr>;
}
/**
 * @deprecated Old interface, will be removed in a future version
 */
interface ReviveSdk<T extends ReviveSdkTypedApi, D extends GenericInkDescriptors, Addr, StorageErr> extends InkV5Sdk<T, D, Addr, StorageErr> {
    addressIsMapped: (address: SS58String) => Promise<boolean>;
}
type ContractSdk<D extends GenericInkDescriptors> = Contract<CommonTypedApi, D, HexString, ReviveStorageError>;
type DeployerSdk<D extends GenericInkDescriptors> = Deployer<CommonTypedApi, D, HexString>;
interface InkSdk {
    addressIsMapped: (address: SS58String) => Promise<boolean>;
    getContract: GetContract;
    getDeployer: <D extends GenericInkDescriptors>(contractDescriptors: D, code: Binary) => DeployerSdk<D>;
    readDeploymentEvents: <D extends GenericInkDescriptors>(contractDescriptors: D, events?: Array<GenericEvent & {
        topics: FixedSizeBinary<number>[];
    }>) => Array<{
        address: HexString;
        contractEvents: Array<D["__types"]["event"]>;
    }>;
}
interface GetContract {
    <D extends GenericInkDescriptors>(contractDescriptors: D): (address: HexString) => ContractSdk<D>;
    <D extends GenericInkDescriptors>(contractDescriptors: D, address: HexString): ContractSdk<D>;
}
interface InkSdkOptions {
    /**
     * Target the latest block instead of the finalized block for any query or dry-run operation.
     *
     * This makes it possible to have quicker updates, but be mindful that the data returned might become
     * invalid at any point, e.g. a contract that apparently was successfully deployed might suddenly
     * disappear, just to reappear a few seconds later, or maybe never? Be really mindful
     * you can get inconsistencies.
     */
    atBest: boolean;
}
type DryRunDeployFn<T extends InkSdkTypedApi | ReviveSdkTypedApi, Addr, D extends GenericInkDescriptors> = <L extends string & keyof D["__types"]["constructors"]>(constructor: L, args: DryRunDeployArgs<D["__types"]["constructors"][L]["message"]>) => Promise<ResultPayload<{
    address: Addr;
    response: FlattenValues<D["__types"]["messages"][L]["response"]>;
    events: D["__types"]["event"][];
    gasRequired: Gas;
    storageDeposit: bigint;
    deploy: () => AsyncTransaction<any, any, any, any>;
}, GetErr<T> | FlattenErrors<D["__types"]["messages"][L]["response"]>>>;
type DeployFn<D extends GenericInkDescriptors> = <L extends string & keyof D["__types"]["constructors"]>(constructor: L, args: DeployArgs<D["__types"]["constructors"][L]["message"]>) => AsyncTransaction<any, any, any, any>;
type EstimateAddrFn<D extends GenericInkDescriptors, Addr> = <L extends string & keyof D["__types"]["constructors"]>(constructor: L, args: Data<D["__types"]["constructors"][L]["message"]> & {
    origin: SS58String;
    value?: bigint;
    nonce?: number;
    salt?: FixedSizeBinary<32>;
}) => Promise<Addr | null>;
interface Deployer<T extends InkSdkTypedApi | ReviveSdkTypedApi, D extends GenericInkDescriptors, Addr> {
    dryRun: DryRunDeployFn<T, Addr, D>;
    deploy: DeployFn<D>;
    estimateAddress: EstimateAddrFn<D, Addr>;
}
type GetErr<T> = T extends TypedApi<SdkDefinition<InkSdkPallets, InkSdkApis<any, infer R>>> ? R : T extends TypedApi<SdkDefinition<ReviveSdkPallets<any>, ReviveSdkApis<any, infer R>>> ? R : any;
interface Contract<T extends InkSdkTypedApi | ReviveSdkTypedApi, D extends GenericInkDescriptors, Addr, StorageErr> {
    accountId: SS58String;
    getBalance(): Promise<bigint>;
    isCompatible(): Promise<boolean>;
    getStorage(): SdkStorage<D["__types"]["storage"], StorageErr>;
    query: <L extends string & keyof D["__types"]["messages"]>(message: L, args: QueryArgs<D["__types"]["messages"][L]["message"]>) => Promise<ResultPayload<{
        response: FlattenValues<D["__types"]["messages"][L]["response"]>;
        events: D["__types"]["event"][];
        gasRequired: Gas;
        storageDeposit: bigint;
        send: () => AsyncTransaction<any, any, any, any>;
    }, GetErr<T> | FlattenErrors<D["__types"]["messages"][L]["response"]> | {
        type: "FlagReverted";
        value: {
            message: string;
            raw: Binary;
            gasRequired: Gas;
            storageDeposit: bigint;
            send: () => AsyncTransaction<any, any, any, any>;
        };
    }>>;
    send: <L extends string & keyof D["__types"]["messages"]>(message: L, args: SendArgs<D["__types"]["messages"][L]["message"]>) => AsyncTransaction<any, any, any, any>;
    dryRunRedeploy: DryRunDeployFn<T, Addr, D>;
    redeploy: DeployFn<D>;
    filterEvents: (events?: Array<{
        event: GenericEvent;
        topics: Binary[];
    } | (GenericEvent & {
        topics: Binary[];
    })>) => Array<D["__types"]["event"]>;
}
type QueryOptions = Partial<{
    gasLimit: Gas;
    storageDepositLimit: bigint;
}>;
type Data<D> = {} extends D ? {
    data?: D;
} : {
    data: D;
};
type QueryArgs<D> = Data<D> & {
    options?: QueryOptions;
    value?: bigint;
    origin: SS58String;
};
type GasInput = {
    origin: SS58String;
} | {
    gasLimit: Gas;
    storageDepositLimit: bigint;
};
type SendArgs<D> = Data<D> & {
    value?: bigint;
} & GasInput;
type DeployOptions = Partial<{
    gasLimit: Gas;
    storageDepositLimit: bigint;
    salt: FixedSizeBinary<32>;
}>;
type DryRunDeployArgs<D> = Data<D> & {
    options?: DeployOptions;
    value?: bigint;
    origin: SS58String;
};
type DeployArgs<D> = Data<D> & {
    options?: Omit<DeployOptions, "gasLimit" | "storageDepositLimit">;
    value?: bigint;
} & GasInput;

declare const createInkV5Sdk: <T extends InkSdkTypedApi, D extends GenericInkDescriptors>(typedApi: T, contractDescriptors: D, options?: Partial<InkSdkOptions>) => InkV5Sdk<T, D, SS58String, StorageError>;

declare const createInkSdk: (client: PolkadotClient, options?: Partial<InkSdkOptions>) => InkSdk;

/**
 * @deprecated use `createInkSdk(client)` instead
 */
declare const createReviveSdk: <T extends ReviveSdkTypedApi, D extends GenericInkDescriptors>(typedApi: T, contractDescriptors: D, options?: Partial<InkSdkOptions>) => ReviveSdk<T, D, HexString, ReviveStorageError>;

declare const ss58ToEthereum: (address: SS58String) => Binary;
/**
 * @deprecated Use `createInkSdk(client).addressIsMapped(address)` instead.
 */
declare const reviveAddressIsMapped: (typedApi: ReviveSdkTypedApi, address: SS58String) => Promise<boolean>;
declare const getDeploymentAddressWithNonce: (deployer: SS58String | ReviveAddress | HexString, nonce: number) => Binary;

export { createInkSdk, createInkV5Sdk, createReviveSdk, getDeploymentAddressWithNonce, reviveAddressIsMapped, ss58ToEthereum };
export type { ContractSdk, DeployerSdk, DryRunCallParams, DryRunCallResult, DryRunInstantiateParams, DryRunInstantiateResult, Gas, GenericInkDescriptors, GenericTransaction, InkSdk, InkSdkApis, InkSdkDefinition, InkSdkPallets, InkSdkTypedApi, MultiAddress, NewReviveSdkTypedApi, OldReviveSdkTypedApi, ReviveAddress, ReviveSdkApis, ReviveSdkPallets, ReviveSdkTypedApi, ReviveStorageError, StorageError, TraceCallResult, U256 };
