{"version":3,"sources":["../src/metadata.ts","../src/papiConfig.ts","../src/commands/generate.ts","../src/packageManager.ts","../src/commands/add.ts","../src/commands/ink.ts","../src/commands/remove.ts","../src/commands/update.ts","../src/cli.ts","../src/commands/sol.ts"],"sourcesContent":["import { createClient } from \"@polkadot-api/substrate-client\"\nimport type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport * as fs from \"node:fs/promises\"\nimport {\n  HexString,\n  metadata,\n  UnifiedMetadata,\n  unifyMetadata,\n  v15,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getWsProvider } from \"@polkadot-api/ws-provider/node\"\nimport { Worker } from \"node:worker_threads\"\nimport { getObservableClient } from \"@polkadot-api/observable-client\"\nimport {\n  catchError,\n  combineLatest,\n  concatMap,\n  filter,\n  firstValueFrom,\n  from,\n  map,\n  merge,\n  mergeMap,\n  Observable,\n  of,\n  switchMap,\n  take,\n  timer,\n} from \"rxjs\"\nimport { EntryConfig } from \"./papiConfig\"\nimport { dirname } from \"path\"\nimport { fileURLToPath } from \"url\"\nimport * as knownChains from \"@polkadot-api/known-chains\"\nimport { withPolkadotSdkCompat } from \"@polkadot-api/polkadot-sdk-compat\"\nimport { startFromWorker } from \"@polkadot-api/smoldot/from-node-worker\"\nimport { Client as SmoldotClient } from \"@polkadot-api/smoldot\"\nimport { getSmProvider } from \"@polkadot-api/sm-provider\"\nimport { withLegacy } from \"@polkadot-api/legacy-provider\"\n\nconst workerPath = fileURLToPath(\n  import.meta.resolve(\"@polkadot-api/smoldot/node-worker\"),\n)\n\nlet smoldotWorker: [SmoldotClient, Worker] | null\nlet workerRefCount = 0\nasync function getSmoldotWorker() {\n  if (!smoldotWorker) {\n    const worker = new Worker(workerPath, {\n      stdout: true,\n      stderr: true,\n    })\n    const client = startFromWorker(worker)\n    smoldotWorker = [client, worker]\n  }\n  return smoldotWorker\n}\n\ntype GetMetadataPayload = {\n  metadata: UnifiedMetadata\n  metadataRaw: Uint8Array\n  codeHash: string\n  genesis: string\n}\nconst getMetadataCall = (provider: JsonRpcProvider, at?: string) =>\n  new Observable<GetMetadataPayload>((observer) => {\n    const substrateClient = createClient(provider)\n    const client = getObservableClient(substrateClient)\n    const { runtime$, unfollow, genesis$, getRuntime$ } = client.chainHead$()\n    const archive = client.archive(getRuntime$)\n\n    const getRuntimeCtx$ = () => {\n      if (!at) return runtime$.pipe(filter(Boolean))\n      // if it's a number\n      const hash$ =\n        at.length < 32 && /^\\d+$/.test(at)\n          ? from(substrateClient.archive.hashByHeight(Number(at))).pipe(\n              map(([hash]) => {\n                if (!hash) {\n                  throw new Error(`Can't find block number \"${at}\"`)\n                }\n                return hash\n              }),\n            )\n          : of(at)\n      return hash$.pipe(switchMap(archive.getRuntimeContext$))\n    }\n\n    const subscription = combineLatest({\n      runtime: getRuntimeCtx$(),\n      genesis: genesis$,\n    })\n      .pipe(\n        take(1),\n        map(\n          ({\n            runtime: {\n              lookup: { metadata },\n              metadataRaw,\n              codeHash,\n            },\n            genesis,\n          }) => ({\n            metadata,\n            metadataRaw,\n            codeHash,\n            genesis,\n          }),\n        ),\n      )\n      .subscribe(observer)\n\n    subscription.add(() => {\n      try {\n        unfollow()\n        client.destroy()\n      } catch {}\n    })\n\n    return subscription\n  })\n\nconst getChainSpecs = (\n  chain: string,\n): { potentialRelayChainSpecs: string[]; chainSpec: string } => {\n  if (!(chain in knownChains)) {\n    const relayChainName = JSON.parse(chain).relay_chain\n    return {\n      potentialRelayChainSpecs:\n        relayChainName in knownChains\n          ? [knownChains[relayChainName as keyof typeof knownChains]]\n          : [],\n      chainSpec: chain,\n    }\n  }\n\n  const relayChainName = Object.keys(knownChains).find(\n    (c) => c !== chain && chain.startsWith(c),\n  )\n  const potentialRelayChainSpecs = relayChainName\n    ? [knownChains[relayChainName as keyof typeof knownChains]]\n    : []\n  const chainSpec = knownChains[chain as keyof typeof knownChains]\n\n  return {\n    potentialRelayChainSpecs,\n    chainSpec,\n  }\n}\n\nconst getMetadataFromSmoldot = async (chain: string) => {\n  workerRefCount++\n  try {\n    const [smoldot] = await getSmoldotWorker()\n    const chainSpecs = getChainSpecs(chain)\n    const potentialRelayChains = await Promise.all(\n      chainSpecs.potentialRelayChainSpecs.map((chainSpec) =>\n        smoldot.addChain({ chainSpec }),\n      ),\n    )\n    const provider = getSmProvider(\n      smoldot.addChain({\n        chainSpec: chainSpecs.chainSpec,\n        potentialRelayChains,\n      }),\n    )\n    return await firstValueFrom(getMetadataCall(provider))\n  } finally {\n    workerRefCount--\n    if (workerRefCount === 0) {\n      const [smoldot, worker] = smoldotWorker!\n      smoldotWorker = null\n      await smoldot.terminate()\n      await worker.terminate()\n    }\n  }\n}\n\nconst getMetadataCallWithError = (\n  ...input: Parameters<typeof getMetadataCall>\n) =>\n  getMetadataCall(...input).pipe(\n    map((value) => ({ success: true as const, value })),\n    catchError((error) => of({ success: false as const, error })),\n  )\n\nconst getMetadataFromWsURL = (wsURL: string, at?: string) =>\n  firstValueFrom(\n    merge(\n      getMetadataCallWithError(withPolkadotSdkCompat(getWsProvider(wsURL)), at),\n      timer(3_000).pipe(\n        concatMap(() =>\n          getMetadataCallWithError(\n            getWsProvider({\n              endpoints: [wsURL],\n              innerEnhancer: withLegacy(),\n            }),\n            at,\n          ),\n        ),\n      ),\n    ).pipe(\n      mergeMap((x, idx) => {\n        if (x.success) return [x.value]\n        if (idx < 1) return []\n        throw x.error\n      }),\n    ),\n  )\n\nexport async function getMetadata({\n  metadata: metadataFile,\n  codeHash,\n  genesis,\n  ...entry\n}: EntryConfig): Promise<{\n  metadata: UnifiedMetadata\n  metadataRaw: Uint8Array\n  codeHash?: HexString\n  genesis?: HexString\n} | null> {\n  // metadata file always prevails over other entries.\n  // cli's update will update the metadata file when the user requests it.\n  if (metadataFile) {\n    const data = await fs.readFile(metadataFile)\n    const metadataRaw = new Uint8Array(data)\n\n    let meta: UnifiedMetadata\n    try {\n      meta = unifyMetadata(metadata.dec(metadataRaw))\n    } catch (_) {\n      meta = unifyMetadata(v15.dec(metadataRaw))\n    }\n\n    return {\n      metadata: meta,\n      metadataRaw,\n      codeHash,\n      genesis,\n    }\n  }\n\n  if (\"chain\" in entry) {\n    return getMetadataFromSmoldot(entry.chain)\n  }\n\n  if (\"chainSpec\" in entry) {\n    const chainSpec = await fs.readFile(entry.chainSpec, \"utf8\")\n    return getMetadataFromSmoldot(chainSpec)\n  }\n\n  if (\"wsUrl\" in entry) {\n    return getMetadataFromWsURL(entry.wsUrl, entry.at)\n  }\n\n  return null\n}\n\nexport async function writeMetadataToDisk(\n  metadataRaw: Uint8Array,\n  outFile: string,\n) {\n  await fs.mkdir(dirname(outFile), { recursive: true })\n  await fs.writeFile(outFile, metadataRaw)\n}\n","import fsExists from \"fs.promises.exists\"\nimport { readPackage } from \"read-pkg\"\nimport { mkdir, readFile, writeFile } from \"node:fs/promises\"\nimport { join } from \"node:path\"\nimport { existsSync } from \"node:fs\"\n\nexport type EntryConfig =\n  | {\n      metadata: string\n      genesis?: string\n      codeHash?: string\n    }\n  | {\n      chainSpec: string\n      metadata?: string\n      genesis?: string\n      codeHash?: string\n    }\n  | {\n      wsUrl: string\n      at?: string\n      metadata?: string\n      genesis?: string\n      codeHash?: string\n    }\n  | {\n      chain: string\n      metadata?: string\n      genesis?: string\n      codeHash?: string\n    }\ntype Entries = Record<string, EntryConfig>\nexport interface PapiConfigOptions {\n  noDescriptorsPackage?: boolean\n}\nexport type PapiConfig = {\n  version: 0\n  descriptorPath: string\n  entries: Record<string, EntryConfig>\n  ink?: Record<string, string>\n  sol?: Record<string, string>\n  options?: Partial<PapiConfigOptions>\n}\n\nexport const papiFolder = \".papi\"\nconst papiCfgDefaultFile = \"polkadot-api.json\"\nconst packageJsonKey = \"polkadot-api\"\n\nexport const defaultConfig: PapiConfig = {\n  version: 0,\n  descriptorPath: join(papiFolder, \"descriptors\"),\n  entries: {},\n}\n\nexport async function readPapiConfig(\n  configFile: string | undefined,\n): Promise<PapiConfig | null> {\n  if (configFile) return readFromFile(configFile)\n\n  const currentVersionLocation = join(papiFolder, papiCfgDefaultFile)\n  const currentVersionLocationExists = await fsExists(currentVersionLocation)\n\n  const readConfig =\n    (await (currentVersionLocationExists\n      ? readFromFile(currentVersionLocation)\n      : readFromFile(papiCfgDefaultFile))) ?? (await readFromPackageJson())\n\n  // Store into current version location if it wasn't there\n  if (readConfig && !currentVersionLocationExists) {\n    await writePapiConfig(undefined, readConfig)\n  }\n  return readConfig\n}\n\n/**\n * Writes config to configFile. If configFile is not specified, it writes to the\n * default path, by this priority order:\n *\n * 1. Default config file (polkadot-api.json)\n * 2. Package.json If no pre-existing config exists, then it creates a\n * polkadot-api.json file.\n */\nexport async function writePapiConfig(\n  configFile: string | undefined,\n  config: PapiConfig,\n) {\n  if (configFile) return writeToFile(configFile, config)\n\n  if (!existsSync(papiFolder)) {\n    await mkdir(papiFolder)\n  }\n  return writeToFile(join(papiFolder, papiCfgDefaultFile), config)\n}\n\nasync function readFromFile(file: string) {\n  const fileExists = await fsExists(file)\n  if (!fileExists) return null\n\n  return migrate(JSON.parse(await readFile(file, \"utf8\")))\n}\nasync function readFromPackageJson() {\n  const packageJson = await readPackage()\n  if (!(packageJsonKey in packageJson)) return null\n  console.warn(\"Papi config in package.json is deprecated\")\n  return migrate(packageJson[packageJsonKey])\n}\n\nfunction migrate(content: Entries | PapiConfig): PapiConfig {\n  if (typeof content.version === \"number\") {\n    return content as any\n  }\n  return {\n    ...defaultConfig,\n    entries: content as Entries,\n  }\n}\n\nasync function writeToFile(file: string, config: PapiConfig) {\n  if (file === \"package.json\") {\n    throw new Error(\"Papi config in package.json is deprecated\")\n  }\n  return writeFile(file, JSON.stringify(config, null, 2) + \"\\n\")\n}\n","import { getMetadata } from \"@/metadata\"\nimport { readPapiConfig } from \"@/papiConfig\"\nimport {\n  generateInkTypes,\n  generateMultipleDescriptors,\n  generateSolTypes,\n  type KnownTypes,\n} from \"@polkadot-api/codegen\"\nimport { getInkLookup } from \"@polkadot-api/ink-contracts\"\nimport {\n  EntryPointCodec,\n  TypedefCodec,\n} from \"@polkadot-api/metadata-compatibility\"\nimport {\n  Binary,\n  h64,\n  HexString,\n  UnifiedMetadata,\n  Tuple,\n  Vector,\n} from \"@polkadot-api/substrate-bindings\"\nimport { spawn } from \"child_process\"\nimport { existsSync } from \"fs\"\nimport fsExists from \"fs.promises.exists\"\nimport fs, { mkdtemp, rm } from \"fs/promises\"\nimport { tmpdir } from \"os\"\nimport path, { join, posix, win32 } from \"path\"\nimport process from \"process\"\nimport { readPackage } from \"read-pkg\"\nimport tsc from \"tsc-prog\"\nimport tsup from \"tsup\"\nimport { updatePackage } from \"write-package\"\nimport { detectPackageManager } from \"../packageManager\"\nimport { CommonOptions } from \"./commonOptions\"\n\nexport interface GenerateOptions extends CommonOptions {\n  clientLibrary?: string\n}\n\nexport async function generate(opts: GenerateOptions) {\n  if (process.env.PAPI_SKIP_GENERATE) {\n    return\n  }\n\n  const config = await readPapiConfig(opts.config)\n  if (!config) {\n    throw new Error(\"Can't find the Polkadot-API configuration\")\n  }\n  const sources = config.entries\n\n  if (Object.keys(sources).length == 0) {\n    console.log(\"No chains defined in config file\")\n  }\n\n  console.log(`Reading metadata`)\n  const chains = await Promise.all(\n    Object.entries(sources).map(async ([key, source]) => ({\n      key,\n      ...(await getMetadata(source))!,\n      knownTypes: {},\n    })),\n  )\n\n  if (chains.length === 0) {\n    console.log(\"No entries in polkadot-api.json. Nothing to generate.\")\n    return\n  }\n\n  console.log(`Generating descriptors`)\n  await cleanDescriptorsPackage(config.descriptorPath)\n  if (!config.options?.noDescriptorsPackage) {\n    await addDescriptorsToPackageJson(config.descriptorPath)\n  }\n  const descriptorsDir = join(process.cwd(), config.descriptorPath)\n\n  const clientPath = opts.clientLibrary ?? \"polkadot-api\"\n\n  const whitelist = opts.whitelist ? await readWhitelist(opts.whitelist) : null\n  const descriptorSrcDir = join(descriptorsDir, \"src\")\n  const hash = await outputCodegen(\n    chains,\n    descriptorSrcDir,\n    clientPath,\n    whitelist,\n  )\n\n  if (config.ink || config.sol) {\n    outputContractCodegen(config, descriptorSrcDir)\n  }\n\n  await replacePackageJson(descriptorsDir, hash)\n  await compileCodegen(descriptorsDir)\n  await fs.rm(descriptorSrcDir, { recursive: true })\n  if (!config.options?.noDescriptorsPackage) {\n    await runInstall()\n    await flushBundlerCache()\n  }\n}\n\nasync function cleanDescriptorsPackage(path: string) {\n  const descriptorsDir = join(process.cwd(), path)\n  if (!existsSync(descriptorsDir)) {\n    await fs.mkdir(descriptorsDir, { recursive: true })\n\n    // We have to keep the package.json in git because otherwise npm install on a fresh repo would fail\n    await fs.writeFile(\n      join(descriptorsDir, \".gitignore\"),\n      \"*\\n!.gitignore\\n!package.json\\n\",\n    )\n  }\n\n  const distDir = join(descriptorsDir, \"dist\")\n  if (existsSync(distDir)) {\n    await fs.rm(distDir, { recursive: true })\n  }\n}\n\nasync function addDescriptorsToPackageJson(path: string) {\n  const [packageJson, protocol] = await Promise.all([\n    readPackage(),\n    getPackageProtocol(),\n  ])\n\n  const packageSource = `${protocol}:${path}`\n  const currentSource = packageJson.dependencies?.[\"@polkadot-api/descriptors\"]\n  if (currentSource !== packageSource) {\n    await updatePackage({\n      dependencies: {\n        \"@polkadot-api/descriptors\": packageSource,\n      },\n    })\n  }\n}\n\nasync function getPackageProtocol() {\n  const { packageManager, version } = await detectPackageManager()\n\n  switch (packageManager) {\n    case \"yarn\":\n      const yarnMajorVersion = Number(version.split(\".\").at(0))\n\n      return yarnMajorVersion >= 2 ? \"portal\" : \"file\"\n    default:\n      return \"file\"\n  }\n}\n\nasync function runInstall() {\n  const { executable } = await detectPackageManager()\n  console.log(`${executable} install`)\n  const child = spawn(executable, [\"install\"], {\n    stdio: \"inherit\",\n    shell: true,\n    env: {\n      ...process.env,\n      PAPI_SKIP_GENERATE: \"true\",\n    },\n  })\n  await new Promise((resolve) => child.on(\"close\", resolve))\n}\n\nconst generateMetadataExportFile = (input: Uint8Array): string =>\n  `const binMeta: string = \"${Buffer.from(input).toString(\"base64\")}\"; export default binMeta;`\n\nasync function outputCodegen(\n  chains: Array<{\n    key: string\n    metadata: UnifiedMetadata\n    metadataRaw: Uint8Array\n    knownTypes: KnownTypes\n    codeHash?: HexString\n    genesis?: HexString\n  }>,\n  outputFolder: string,\n  clientPath: string,\n  whitelist: string[] | null,\n) {\n  const {\n    commonFileContent,\n    descriptorsFileContent,\n    descriptorTypesFiles,\n    metadataTypes,\n    typesFileContent,\n    publicTypes,\n  } = generateMultipleDescriptors(\n    chains,\n    {\n      client: clientPath,\n      metadataTypes: \"./metadataTypes\",\n      types: \"./common-types\",\n      descriptorValues: \"./descriptors\",\n      common: \"./common\",\n    },\n    {\n      whitelist: whitelist ?? undefined,\n    },\n  )\n\n  const hash = h64(\n    Binary.fromText(\n      Array.from(metadataTypes.checksumToIdx.keys()).join(\"\"),\n    ).asBytes(),\n  )\n\n  const EntryPointsCodec = Vector(EntryPointCodec)\n  const TypedefsCodec = Vector(TypedefCodec)\n  const TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec)\n\n  await fs.mkdir(outputFolder, { recursive: true })\n\n  await fs.writeFile(path.join(outputFolder, \"common.ts\"), commonFileContent)\n  // Going through base64 conversion instead of using binary loader because of esbuild issue\n  // https://github.com/evanw/esbuild/issues/3894\n  const metadataTypesBase64 = Buffer.from(\n    TypesCodec.enc([metadataTypes.entryPoints, metadataTypes.typedefs]),\n  ).toString(\"base64\")\n\n  await fs.writeFile(\n    path.join(outputFolder, \"metadataTypes.ts\"),\n    `\nconst content = \"${metadataTypesBase64}\"\nexport default content\n    `,\n  )\n  await fs.writeFile(\n    path.join(outputFolder, \"descriptors.ts\"),\n    descriptorsFileContent,\n  )\n  await fs.writeFile(\n    path.join(outputFolder, \"common-types.ts\"),\n    typesFileContent,\n  )\n  await Promise.all(\n    chains\n      .map((chain, i) => [\n        fs.writeFile(\n          join(outputFolder, `${chain.key}.ts`),\n          descriptorTypesFiles[i].content,\n        ),\n        fs.writeFile(\n          join(outputFolder, `${chain.key}_metadata.ts`),\n          generateMetadataExportFile(chain.metadataRaw),\n        ),\n      ])\n      .flat(),\n  )\n\n  await generateIndex(\n    outputFolder,\n    chains.map((chain) => chain.key),\n    publicTypes,\n    Object.fromEntries(\n      chains.filter((x) => x.codeHash!!).map((x) => [x.codeHash, x.key]),\n    ),\n  )\n\n  return hash\n}\n\nasync function outputContractCodegen(\n  contracts: {\n    ink?: Record<string, string>\n    sol?: Record<string, string>\n  },\n  outputFolder: string,\n) {\n  console.log(\"Generating smart contract types\")\n\n  const contractsFolder = join(outputFolder, \"contracts\")\n  if (!existsSync(contractsFolder))\n    await fs.mkdir(contractsFolder, { recursive: true })\n\n  const imports: string[] = []\n  for (const [key, metadata] of Object.entries(contracts.ink ?? {})) {\n    try {\n      const types = generateInkTypes(\n        getInkLookup(JSON.parse(await fs.readFile(metadata, \"utf-8\"))),\n      )\n      await fs.writeFile(join(contractsFolder, `${key}.ts`), types)\n      imports.push(`export { descriptor as ${key} } from './${key}'`)\n    } catch (ex) {\n      console.error(\"Exception when generating descriptors for contract \" + key)\n      console.error(ex)\n    }\n  }\n\n  for (const [key, metadata] of Object.entries(contracts.sol ?? {})) {\n    try {\n      const types = generateSolTypes(\n        JSON.parse(await fs.readFile(metadata, \"utf-8\")),\n      )\n      await fs.writeFile(join(contractsFolder, `${key}.ts`), types)\n      imports.push(`export { descriptor as ${key} } from './${key}'`)\n    } catch (ex) {\n      console.error(\"Exception when generating descriptors for contract \" + key)\n      console.error(ex)\n    }\n  }\n\n  await fs.writeFile(\n    join(contractsFolder, `index.ts`),\n    imports.join(\"\\n\") + \"\\n\",\n  )\n\n  fs.appendFile(\n    join(outputFolder, \"index.ts\"),\n    `\n    export * as contracts from './contracts';\n    `,\n  )\n}\n\nasync function compileCodegen(packageDir: string) {\n  const srcDir = join(packageDir, \"src\")\n  const outDir = join(packageDir, \"dist\")\n\n  if (await fsExists(outDir)) {\n    await fs.rm(outDir, { recursive: true })\n  }\n\n  await tsup.build({\n    target: \"es2022\",\n    format: [\"cjs\", \"esm\"],\n    entry: [path.join(srcDir, \"index.ts\").replaceAll(win32.sep, posix.sep)],\n    loader: {\n      \".scale\": \"binary\",\n    },\n    platform: \"neutral\",\n    outDir,\n    outExtension: (ctx) => ({\n      js: ctx.format === \"esm\" ? \".mjs\" : \".js\",\n    }),\n  })\n\n  tsc.build({\n    basePath: srcDir,\n    compilerOptions: {\n      skipLibCheck: true,\n      declaration: true,\n      emitDeclarationOnly: true,\n      target: \"esnext\",\n      module: \"esnext\",\n      moduleResolution: \"node\",\n      resolveJsonModule: true,\n      allowSyntheticDefaultImports: true,\n      outDir,\n    },\n  })\n}\n\nconst cacheMetadataStr = `\nexport const getMetadata: (codeHash: string) => Promise<Uint8Array | null> = async (\n  codeHash: string\n)=> {\n  try {\n    return await metadatas[codeHash].getMetadata()\n  } catch {}\n  return null\n}`\n\nconst generateIndex = async (\n  path: string,\n  keys: string[],\n  publicTypes: string[],\n  metadatas: Record<string, string>,\n) => {\n  const indexTs = [\n    ...keys.flatMap((key) => [\n      `import { default as ${key} } from \"./${key}\";`,\n      `export { ${key} }`,\n      `export type * from \"./${key}\";`,\n    ]),\n    `export {`,\n    publicTypes.join(\", \"),\n    `} from './common-types';`,\n    `const metadatas = {${Object.entries(metadatas)\n      .map(([codeHash, key]) => `[\"${codeHash}\"]: ${key}`)\n      .join(\",\\n\")}}`,\n    cacheMetadataStr,\n  ].join(\"\\n\")\n  await fs.writeFile(join(path, \"index.ts\"), indexTs)\n}\n\nasync function replacePackageJson(descriptorsDir: string, version: bigint) {\n  await fs.writeFile(\n    join(descriptorsDir, \"package.json\"),\n    `{\n  \"version\": \"0.1.0-autogenerated.${version}\",\n  \"name\": \"@polkadot-api/descriptors\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"module\": \"./dist/index.mjs\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"browser\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"peerDependencies\": {\n    \"polkadot-api\": \">=1.11.2\"\n  }\n}\n`,\n  )\n}\n\nasync function readWhitelist(filename: string): Promise<string[] | null> {\n  if (!(await fsExists(filename))) {\n    throw new Error(\"Whitelist file not found: \" + filename)\n  }\n\n  const tmpDir = await mkdtemp(join(tmpdir(), \"papi-\"))\n  try {\n    await tsup.build({\n      format: \"esm\",\n      entry: {\n        index: filename,\n      },\n      outDir: tmpDir,\n      outExtension() {\n        return { js: \".mjs\" }\n      },\n      silent: true,\n    })\n    const { whitelist } = await import(join(tmpDir, \"index.mjs\"))\n    return whitelist\n  } finally {\n    await rm(tmpDir, { recursive: true }).catch(console.error)\n  }\n}\n\nasync function flushBundlerCache() {\n  try {\n    const viteMetadata = join(\n      process.cwd(),\n      \"node_modules\",\n      \".vite\",\n      \"deps\",\n      \"_metadata.json\",\n    )\n    if (await fsExists(viteMetadata)) {\n      await rm(viteMetadata)\n    }\n  } catch (ex) {\n    console.error(ex)\n  }\n}\n","import { readdir } from \"node:fs/promises\"\nimport { join } from \"node:path\"\nimport { execa } from \"execa\"\n\nexport type PackageManager = \"npm\" | \"pnpm\" | \"yarn\" | \"bun\"\nexport interface PackageManagerDetection {\n  packageManager: PackageManager\n  executable: string\n  version: string\n}\nlet detected: PackageManagerDetection | null = null\n\nexport async function detectPackageManager() {\n  if (detected) return detected\n\n  const { packageManager, executable } =\n    (await detectByLockFile()) ?? detectByEnvironment() ?? getFallback()\n  const version = await getVersion(executable)\n\n  return (detected = {\n    packageManager,\n    executable,\n    version,\n  })\n}\n\nasync function detectByLockFile(): Promise<Omit<\n  PackageManagerDetection,\n  \"version\"\n> | null> {\n  try {\n    for (let i = 0, dir = \".\"; i < 5; i++, dir = join(dir, \"..\")) {\n      const packageManager = await getByLockFile(dir)\n      if (packageManager) {\n        return {\n          packageManager,\n          executable: packageManager,\n        }\n      }\n    }\n  } catch (ex) {\n    // fs access can fail for permission errors\n    // We just assume that we have\n  }\n  return null\n}\n\nconst lockFileToPackageManager: Record<string, PackageManager> = {\n  \"pnpm-lock.yaml\": \"pnpm\",\n  \"yarn.lock\": \"yarn\",\n  \"bun.lock\": \"bun\",\n  \"bun.lockb\": \"bun\",\n  \"package-lock.json\": \"npm\",\n}\n\nconst lockFiles = new Set(Object.keys(lockFileToPackageManager))\nasync function getByLockFile(dir: string) {\n  const files = await readdir(dir)\n  const lockFile = files.find((v) => lockFiles.has(v))\n  return lockFile ? lockFileToPackageManager[lockFile] : null\n}\n\nfunction detectByEnvironment(): Omit<\n  PackageManagerDetection,\n  \"version\"\n> | null {\n  const npm_execpath = process.env.npm_execpath\n  if (npm_execpath) {\n    const packageManager = Object.values(lockFileToPackageManager).find(\n      (manager) => npm_execpath.includes(manager),\n    )\n    return packageManager ? { packageManager, executable: npm_execpath } : null\n  }\n  if (process.env.PNPM_PACKAGE_NAME) {\n    return { packageManager: \"pnpm\", executable: \"pnpm\" }\n  }\n  return null\n}\n\nfunction getFallback(): Omit<PackageManagerDetection, \"version\"> {\n  console.warn(\"Package manager couldn't be detected, fallback to npm\")\n  return {\n    executable: \"npm\",\n    packageManager: \"npm\",\n  }\n}\n\nasync function getVersion(executable: string) {\n  const res = await execa(executable, [\"--version\"])\n  return res.stdout\n}\n","import { getMetadata, writeMetadataToDisk } from \"@/metadata\"\nimport {\n  defaultConfig,\n  EntryConfig,\n  papiFolder,\n  readPapiConfig,\n  writePapiConfig,\n} from \"@/papiConfig\"\nimport { compactNumber } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\nimport { getMetadataFromRuntime } from \"@polkadot-api/wasm-executor/node\"\nimport * as fs from \"node:fs/promises\"\nimport ora from \"ora\"\nimport { CommonOptions } from \"./commonOptions\"\nimport { generate } from \"./generate\"\nimport { join } from \"node:path\"\nimport { existsSync } from \"node:fs\"\n\nexport interface AddOptions extends CommonOptions {\n  file?: string\n  wsUrl?: string\n  chainSpec?: string\n  // well-known chains\n  name?: string\n  wasm?: string\n  noPersist?: boolean\n  // only for wsUrl\n  at?: string\n}\n\nexport async function add(key: string, options: AddOptions) {\n  const config = (await readPapiConfig(options.config)) ?? defaultConfig\n  const entries = config.entries\n\n  if (key in entries) {\n    console.warn(`Replacing existing ${key} config`)\n  }\n\n  if (options.file) {\n    entries[key] = {\n      metadata: options.file,\n    }\n  } else if (options.wasm) {\n    const spinner = ora(`Loading metadata from runtime`).start()\n    const metadataHex = (await fs.readFile(options.wasm)).toString(\"hex\")\n    const opaqueMeta = fromHex(getMetadataFromRuntime(`0x${metadataHex}`))\n\n    // metadata comes with compact length prepended\n    const metadataLen = compactNumber.dec(opaqueMeta)\n    const compactLen = compactNumber.enc(metadataLen).length\n    // verify we got all data\n    if (opaqueMeta.length - compactLen !== metadataLen)\n      throw new Error(\"Not able to retrieve runtime metadata\")\n\n    spinner.text = \"Writing metadata\"\n    const metadataRaw = opaqueMeta.slice(compactLen)\n    const filename = await storeMetadata(metadataRaw, key)\n    spinner.succeed(`Metadata saved as ${filename}`)\n\n    entries[key] = {\n      metadata: filename,\n    }\n  } else {\n    const entry = entryFromOptions(options)\n    entries[key] = entry\n\n    if (!options.noPersist) {\n      const spinner = ora(`Loading metadata`).start()\n      const { metadataRaw, genesis, codeHash } = (await getMetadata(entry))!\n\n      spinner.text = \"Writing metadata\"\n      const filename = await storeMetadata(metadataRaw, key)\n\n      spinner.succeed(`Metadata saved as ${filename}`)\n      entry.metadata = filename\n      entry.genesis = genesis\n      entry.codeHash = codeHash\n    }\n  }\n\n  await writePapiConfig(options.config, config)\n  console.log(`Saved new spec \"${key}\"`)\n\n  if (!options.skipCodegen) {\n    generate({\n      config: options.config,\n    })\n  }\n}\n\nasync function storeMetadata(metadata: Uint8Array, key: string) {\n  const defaultFolder = join(papiFolder, \"metadata\")\n  if (!existsSync(defaultFolder)) {\n    await fs.mkdir(defaultFolder, { recursive: true })\n  }\n  const filename = join(defaultFolder, `${key}.scale`)\n  await writeMetadataToDisk(metadata, filename)\n  return filename\n}\n\nconst entryFromOptions = (options: AddOptions): EntryConfig => {\n  if (options.wsUrl) {\n    return {\n      wsUrl: options.wsUrl,\n      at: options.at,\n    }\n  }\n  if (options.chainSpec) {\n    return {\n      chainSpec: options.chainSpec,\n    }\n  }\n  if (options.name) {\n    return {\n      chain: options.name,\n    }\n  }\n\n  throw new Error(\n    \"add command needs one source, specified by options -f -w -c or -n\",\n  )\n}\n","import {\n  defaultConfig,\n  papiFolder,\n  readPapiConfig,\n  writePapiConfig,\n} from \"@/papiConfig\"\nimport { existsSync } from \"node:fs\"\nimport * as fs from \"node:fs/promises\"\nimport { join } from \"node:path\"\nimport { CommonOptions } from \"./commonOptions\"\nimport { generate } from \"./generate\"\n\nexport interface InkAddOptions extends CommonOptions {\n  key?: string\n}\n\nexport const ink = {\n  async add(file: string, options: InkAddOptions) {\n    const metadata = JSON.parse(await fs.readFile(file, \"utf-8\"))\n    // Remove wasm blob if it's there\n    delete metadata.source?.wasm\n\n    const key = options.key || metadata.contract.name\n    const config = (await readPapiConfig(options.config)) ?? defaultConfig\n    const inkConfig = (config.ink ||= {})\n    if (key in inkConfig) {\n      console.warn(`Replacing existing ${key} config`)\n    }\n\n    const contractsFolder = join(papiFolder, \"contracts\")\n    if (!existsSync(contractsFolder)) {\n      await fs.mkdir(contractsFolder, { recursive: true })\n    }\n    const fileName = join(contractsFolder, key + \".json\")\n    await fs.writeFile(fileName, JSON.stringify(metadata, null, 2))\n\n    inkConfig[key] = fileName\n    await writePapiConfig(options.config, config)\n\n    if (!options.skipCodegen) {\n      generate({\n        config: options.config,\n      })\n    }\n  },\n  async remove(key: string, options: CommonOptions) {\n    const config = (await readPapiConfig(options.config)) ?? defaultConfig\n    const inkConfig = (config.ink ||= {})\n    if (!(key in inkConfig)) {\n      console.log(`${key} contract not found in config`)\n      return\n    }\n\n    const fileName = inkConfig[key]\n    delete inkConfig[key]\n\n    if (existsSync(fileName)) {\n      await fs.rm(fileName)\n    }\n\n    await writePapiConfig(options.config, config)\n\n    if (!options.skipCodegen) {\n      generate({\n        config: options.config,\n      })\n    }\n  },\n}\n","import { defaultConfig, readPapiConfig, writePapiConfig } from \"@/papiConfig\"\nimport { CommonOptions } from \"./commonOptions\"\nimport { generate } from \"./generate\"\n\nexport async function remove(key: string, options: CommonOptions) {\n  const config = (await readPapiConfig(options.config)) ?? defaultConfig\n  const entries = config.entries\n\n  if (!(key in entries)) {\n    throw new Error(`Key ${key} not set in polkadot-api config`)\n  }\n\n  delete entries[key]\n\n  await writePapiConfig(options.config, config)\n  console.log(`Removed chain \"${key}\" from config`)\n\n  if (!options.skipCodegen) {\n    generate({\n      config: options.config,\n    })\n  }\n}\n","import { getMetadata, writeMetadataToDisk } from \"@/metadata\"\nimport {\n  defaultConfig,\n  EntryConfig,\n  readPapiConfig,\n  writePapiConfig,\n} from \"@/papiConfig\"\nimport ora from \"ora\"\nimport { CommonOptions } from \"./commonOptions\"\nimport { generate } from \"./generate\"\n\nexport async function update(\n  keysInput: string | undefined,\n  options: CommonOptions,\n) {\n  const config = (await readPapiConfig(options.config)) ?? defaultConfig\n  const { entries } = config\n\n  const keys =\n    keysInput === undefined ? Object.keys(entries) : keysInput.split(\",\")\n\n  const updateByKey = async (key: string) => {\n    if (!(key in entries)) {\n      throw new Error(`Key ${key} not set in polkadot-api config`)\n    }\n\n    // Exclude metadata file from the entry, otherwise getMetadata would load from the file\n    const { metadata: filename, ...entry } = entries[key]\n    if (!filename) {\n      if (keysInput !== undefined) {\n        console.warn(`Key ${key} doesn't have a metadata file to update`)\n      }\n\n      return\n    }\n\n    if (\"at\" in entry) {\n      console.warn(\n        `Key ${key} is based on a specific block ${entry.at}, skipping update`,\n      )\n      return\n    }\n\n    const metadata = await getMetadata(entry as EntryConfig)\n    // For those without other sources than metadata file, we get a null.\n    if (!metadata) {\n      if (keysInput !== undefined) {\n        console.warn(\n          `Key ${key} doesn't have any external source to update from`,\n        )\n      }\n      return\n    }\n    entries[key].genesis = metadata.genesis\n    entries[key].codeHash = metadata.codeHash\n\n    spinner.text = `Writing ${key} metadata`\n    await writeMetadataToDisk(metadata.metadataRaw, filename)\n    spinner.succeed(`${key} metadata updated`)\n  }\n\n  const spinner = ora(`Updating`).start()\n  await Promise.all(keys.map(updateByKey))\n  await writePapiConfig(options.config, config)\n\n  if (!options.skipCodegen) {\n    console.log(`Updating descriptors`)\n    await generate({\n      config: options.config,\n    })\n  }\n\n  spinner.stop()\n  console.log(`Updated chain(s) \"${keys.join(\", \")}\"`)\n}\n","import { Option, program } from \"@commander-js/extra-typings\"\nimport type { add, generate, ink, remove, update } from \"./commands\"\nimport * as knownChains from \"@polkadot-api/known-chains\"\nimport { sol } from \"./commands/sol\"\n\nexport type Commands = {\n  add: typeof add\n  generate: typeof generate\n  remove: typeof remove\n  update: typeof update\n  ink: typeof ink\n  version: string\n}\n\nexport function getCli({\n  add,\n  generate,\n  remove,\n  update,\n  ink,\n  version,\n}: Commands) {\n  program.name(\"polkadot-api\").description(\"Polkadot API CLI\").version(version)\n\n  const config = new Option(\"--config <filename>\", \"Source for the config file\")\n  const skipCodegen = new Option(\n    \"--skip-codegen\",\n    \"Skip running codegen after adding\",\n  )\n  const whitelist = new Option(\n    \"--whitelist <filename>\",\n    \"Use whitelist file to reduce descriptor size\",\n  )\n\n  program\n    .command(\"generate\", {\n      isDefault: true,\n    })\n    .description(\"Generate descriptor files\")\n    .addOption(config)\n    .addOption(whitelist)\n    .action(generate)\n\n  program\n    .command(\"add\")\n    .description(\"Add a new chain spec to the list\")\n    .argument(\"<key>\", \"Key identifier for the chain spec\")\n    .addOption(config)\n    .option(\"-f, --file <filename>\", \"Source from metadata encoded file\")\n    .option(\"-w, --wsUrl <URL>\", \"Source from websocket url\")\n    .option(\"-c, --chainSpec <filename>\", \"Source from chain spec file\")\n    .addOption(\n      new Option(\"-n, --name <name>\", \"Source from a well-known chain\").choices(\n        Object.keys(knownChains),\n      ),\n    )\n    .option(\"--wasm <filename>\", \"Source from runtime wasm file\")\n    .option(\n      \"--at <block hash or number>\",\n      \"Only for -w/--wsUrl. Fetch the metadata for a specific block or hash\",\n    )\n    .option(\"--no-persist\", \"Do not persist the metadata as a file\")\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(add)\n\n  program\n    .command(\"update\")\n    .description(\"Update the metadata files and generate descriptor files\")\n    .argument(\n      \"[keys]\",\n      \"Keys of the metadata files to update, separated by commas. Leave empty for all\",\n    )\n    .addOption(config)\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(update)\n\n  program\n    .command(\"remove\")\n    .description(\"Remove a chain spec from the list\")\n    .argument(\"<key>\", \"Key identifier for the chain spec\")\n    .addOption(config)\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(remove)\n\n  const inkCommand = program\n    .command(\"ink\")\n    .description(\"Add, update or remove ink contracts\")\n  inkCommand\n    .command(\"add\")\n    .description(\"Add or update an ink contract\")\n    .argument(\"<file>\", \".contract or .json metadata file for the contract\")\n    .option(\"-k, --key <key>\", \"Key identifier for the contract\")\n    .addOption(config)\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(ink.add)\n  inkCommand\n    .command(\"remove\")\n    .description(\"Remove an ink contract\")\n    .argument(\"<key>\", \"Key identifier for the contract to remove\")\n    .addOption(config)\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(ink.remove)\n\n  const solCommand = program\n    .command(\"sol\")\n    .description(\"Add, update or remove solidity contracts\")\n  solCommand\n    .command(\"add\")\n    .description(\"Add or update a solidity contract\")\n    .argument(\"<file>\", \".abi file for the contract\")\n    .argument(\"<key>\", \"Key identifier for the contract\")\n    .addOption(config)\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(sol.add)\n  solCommand\n    .command(\"remove\")\n    .description(\"Remove a solidity contract\")\n    .argument(\"<key>\", \"Key identifier for the contract to remove\")\n    .addOption(config)\n    .addOption(skipCodegen)\n    .addOption(whitelist)\n    .action(sol.remove)\n\n  return program\n}\n","import {\n  defaultConfig,\n  papiFolder,\n  readPapiConfig,\n  writePapiConfig,\n} from \"@/papiConfig\"\nimport { existsSync } from \"node:fs\"\nimport * as fs from \"node:fs/promises\"\nimport { join } from \"node:path\"\nimport { CommonOptions } from \"./commonOptions\"\nimport { generate } from \"./generate\"\n\nexport const sol = {\n  async add(file: string, key: string, options: CommonOptions) {\n    const abi = JSON.parse(await fs.readFile(file, \"utf-8\"))\n\n    const config = (await readPapiConfig(options.config)) ?? defaultConfig\n    const solConfig = (config.sol ||= {})\n    if (key in solConfig) {\n      console.warn(`Replacing existing ${key} config`)\n    }\n\n    const contractsFolder = join(papiFolder, \"contracts\")\n    if (!existsSync(contractsFolder)) {\n      await fs.mkdir(contractsFolder, { recursive: true })\n    }\n    const fileName = join(contractsFolder, key + \".json\")\n    await fs.writeFile(fileName, JSON.stringify(abi, null, 2))\n\n    solConfig[key] = fileName\n    await writePapiConfig(options.config, config)\n\n    if (!options.skipCodegen) {\n      generate({\n        config: options.config,\n      })\n    }\n  },\n  async remove(key: string, options: CommonOptions) {\n    const config = (await readPapiConfig(options.config)) ?? defaultConfig\n    const solConfig = (config.sol ||= {})\n    if (!(key in solConfig)) {\n      console.log(`${key} contract not found in config`)\n      return\n    }\n\n    const fileName = solConfig[key]\n    delete solConfig[key]\n\n    if (existsSync(fileName)) {\n      await fs.rm(fileName)\n    }\n\n    await writePapiConfig(options.config, config)\n\n    if (!options.skipCodegen) {\n      generate({\n        config: options.config,\n      })\n    }\n  },\n}\n"],"mappings":"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","names":["metadata","relayChainName","mkdir","readFile","writeFile","existsSync","fsExists","fs","join","process","readPackage","join","process","join","fs","path","existsSync","readPackage","metadata","fsExists","fs","join","existsSync","metadata","existsSync","fs","join","metadata","join","existsSync","ora","metadata","ora","knownChains","existsSync","fs","join","join","existsSync","add","generate","remove","update","ink","knownChains"]}