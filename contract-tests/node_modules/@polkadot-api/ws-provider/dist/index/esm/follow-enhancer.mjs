const methods = {};
["v1", "unstable"].forEach((version) => {
  methods[`chainHead_${version}_follow`] = "follow";
  methods[`chainHead_${version}_unfollow`] = "unfollow";
});
const resetStops = () => ({ latest: Date.now(), count: 0 });
const followEnhancer = (base, forceDisconnect) => {
  const prematureStops = /* @__PURE__ */ new Set();
  const preOpId = /* @__PURE__ */ new Map();
  const onGoing = /* @__PURE__ */ new Set();
  let methodsRequestId;
  let nStops = resetStops();
  const result = (onMsg) => {
    const { send, disconnect } = base((fromProvider) => {
      const parsed = JSON.parse(fromProvider);
      if ("id" in parsed) {
        const { id, result: result2 } = parsed;
        if (id === methodsRequestId) {
          methodsRequestId = void 0;
          if (result2 && !result2.methods.some((x) => {
            const [group, , name] = x.split("_");
            return group === "chainHead" && name === "follow";
          })) {
            onMsg(fromProvider);
            forceDisconnect();
            return;
          }
        }
        const msg = preOpId.get(id);
        if (msg) {
          preOpId.delete(id);
          if (prematureStops.has(result2)) {
            prematureStops.delete(result2);
            return;
          }
          onGoing.add(result2);
          const currentSize = onGoing.size + preOpId.size;
          if (currentSize > 2)
            console.warn(
              `Too many chainHead follow subscriptions (${currentSize})`
            );
          else if (parsed.error) {
            console.warn(`chainHead follow failed on the ${currentSize} sub`);
            forceDisconnect();
            preOpId.set(id, msg);
            send(msg);
            return;
          }
        }
      } else {
        const { subscription, result: result2 } = parsed.params;
        if (result2?.event === "stop") {
          const diff = Date.now() - nStops.latest;
          nStops.latest += diff;
          nStops.count = diff < 1e3 ? nStops.count + 1 : 1;
          if (onGoing.has(subscription)) onGoing.delete(subscription);
          else prematureStops.add(subscription);
        }
      }
      onMsg(fromProvider);
      if (nStops.count > 2) {
        nStops = resetStops();
        forceDisconnect();
      }
    });
    return {
      send(toProvider) {
        const parsed = JSON.parse(toProvider);
        if (parsed.method === "rpc_methods") methodsRequestId = parsed.id;
        const method = methods[parsed.method];
        if (method === "follow") {
          preOpId.set(parsed.id, toProvider);
        } else if (method === "unfollow") {
          onGoing.delete(parsed.params[0]);
        }
        send(toProvider);
      },
      disconnect
    };
  };
  return Object.assign(result, {
    cleanup: () => {
      prematureStops.clear();
      preOpId.clear();
      onGoing.clear();
    }
  });
};

export { followEnhancer };
//# sourceMappingURL=follow-enhancer.mjs.map
