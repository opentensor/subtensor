'use strict';

var ws = require('ws');
var jsonRpcProviderProxy = require('@polkadot-api/json-rpc-provider-proxy');

var WsEvent = /* @__PURE__ */ ((WsEvent2) => {
  WsEvent2[WsEvent2["CONNECTING"] = 0] = "CONNECTING";
  WsEvent2[WsEvent2["CONNECTED"] = 1] = "CONNECTED";
  WsEvent2[WsEvent2["ERROR"] = 2] = "ERROR";
  WsEvent2[WsEvent2["CLOSE"] = 3] = "CLOSE";
  return WsEvent2;
})(WsEvent || {});

const methods = {};
["v1", "unstable"].forEach((version) => {
  methods[`chainHead_${version}_follow`] = "follow";
  methods[`chainHead_${version}_unfollow`] = "unfollow";
});
const resetStops = () => ({ latest: Date.now(), count: 0 });
const followEnhancer = (base, forceDisconnect) => {
  const prematureStops = /* @__PURE__ */ new Set();
  const preOpId = /* @__PURE__ */ new Map();
  const onGoing = /* @__PURE__ */ new Set();
  let methodsRequestId;
  let nStops = resetStops();
  const result = (onMsg) => {
    const { send, disconnect } = base((fromProvider) => {
      const parsed = JSON.parse(fromProvider);
      if ("id" in parsed) {
        const { id, result: result2 } = parsed;
        if (id === methodsRequestId) {
          methodsRequestId = void 0;
          if (result2 && !result2.methods.some((x) => {
            const [group, , name] = x.split("_");
            return group === "chainHead" && name === "follow";
          })) {
            onMsg(fromProvider);
            forceDisconnect();
            return;
          }
        }
        const msg = preOpId.get(id);
        if (msg) {
          preOpId.delete(id);
          if (prematureStops.has(result2)) {
            prematureStops.delete(result2);
            return;
          }
          onGoing.add(result2);
          const currentSize = onGoing.size + preOpId.size;
          if (currentSize > 2)
            console.warn(
              `Too many chainHead follow subscriptions (${currentSize})`
            );
          else if (parsed.error) {
            console.warn(`chainHead follow failed on the ${currentSize} sub`);
            forceDisconnect();
            preOpId.set(id, msg);
            send(msg);
            return;
          }
        }
      } else {
        const { subscription, result: result2 } = parsed.params;
        if (result2?.event === "stop") {
          const diff = Date.now() - nStops.latest;
          nStops.latest += diff;
          nStops.count = diff < 1e3 ? nStops.count + 1 : 1;
          if (onGoing.has(subscription)) onGoing.delete(subscription);
          else prematureStops.add(subscription);
        }
      }
      onMsg(fromProvider);
      if (nStops.count > 2) {
        nStops = resetStops();
        forceDisconnect();
      }
    });
    return {
      send(toProvider) {
        const parsed = JSON.parse(toProvider);
        if (parsed.method === "rpc_methods") methodsRequestId = parsed.id;
        const method = methods[parsed.method];
        if (method === "follow") {
          preOpId.set(parsed.id, toProvider);
        } else if (method === "unfollow") {
          onGoing.delete(parsed.params[0]);
        }
        send(toProvider);
      },
      disconnect
    };
  };
  return Object.assign(result, {
    cleanup: () => {
      prematureStops.clear();
      preOpId.clear();
      onGoing.clear();
    }
  });
};

const timeoutError = {
  type: WsEvent.ERROR,
  event: { type: "timeout" }
};
const noop = () => {
};
const defaultConfig = {
  onStatusChanged: noop,
  innerEnhancer: (x) => x,
  timeout: 5e3,
  heartbeatTimeout: 4e4
};
const mapEndpoints = (endpoints) => endpoints.map((x) => typeof x === "string" ? [x] : [x.uri, x.protocol]);
const getWsProvider$1 = (endpoints, config) => {
  const { onStatusChanged, innerEnhancer, timeout, heartbeatTimeout } = {
    ...defaultConfig,
    ...config
  };
  const actualEndpoints = mapEndpoints(
    Array.isArray(endpoints) ? endpoints : [endpoints]
  );
  const WebsocketClass = config?.websocketClass ?? globalThis.WebSocket;
  if (!WebsocketClass) throw new Error("Missing WebSocket class");
  let idx = 0;
  let status;
  let switchTo = null;
  let disconnect = noop;
  let outerCleanup = noop;
  const result = followEnhancer(
    jsonRpcProviderProxy.getSyncProvider(async () => {
      const [uri, protocols] = switchTo || actualEndpoints[idx++ % endpoints.length];
      switchTo = null;
      const socket = new WebsocketClass(uri, protocols);
      const forceSocketClose = () => {
        try {
          socket.addEventListener("error", noop, { once: true });
          socket.close();
        } catch {
        }
      };
      onStatusChanged(
        status = {
          type: WsEvent.CONNECTING,
          uri,
          protocols
        }
      );
      await new Promise((resolve, reject) => {
        const onOpen = () => {
          initialCleanup();
          resolve();
        };
        const onError = (e) => {
          initialCleanup();
          if (e == null) forceSocketClose();
          console.error(
            `Unable to connect to ${uri}${protocols ? ", protocols: " + protocols : ""}`
          );
          onStatusChanged(
            status = {
              type: e ? WsEvent.ERROR : WsEvent.CLOSE,
              event: e
            }
          );
          setTimeout(reject, e ? 300 : 0, e);
        };
        const timeoutToken = timeout !== Infinity ? setTimeout(() => {
          initialCleanup();
          forceSocketClose();
          onStatusChanged(status = timeoutError);
          reject(timeoutError.event);
        }, timeout) : void 0;
        const initialCleanup = () => {
          clearTimeout(timeoutToken);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("open", onOpen);
        };
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
        disconnect = () => {
          onError(null);
        };
      });
      onStatusChanged(
        status = {
          type: WsEvent.CONNECTED,
          uri,
          protocols
        }
      );
      let _onInnerMessage;
      const inner = innerEnhancer((onInnerMessage) => {
        _onInnerMessage = onInnerMessage;
        return {
          send: (m) => {
            socket.send(m);
          },
          disconnect: () => {
            disconnect();
          }
        };
      });
      return (onMessage, onHalt) => {
        let heartbeatToken;
        const heartbeat = () => {
          clearTimeout(heartbeatToken);
          heartbeatToken = setTimeout(() => {
            console.warn(`Terminate: heartbeat timeout`);
            disconnect(true);
          }, heartbeatTimeout);
        };
        heartbeat();
        const connection = inner(onMessage);
        const _onMessage = (e) => {
          heartbeat();
          if (typeof e.data === "string") _onInnerMessage(e.data);
        };
        const innerHalt = (reason) => (e) => {
          clearTimeout(heartbeatToken);
          console.warn(`WS halt (${reason})`);
          onStatusChanged(
            status = {
              type: reason,
              event: e
            }
          );
          onHalt();
        };
        const onError = innerHalt(WsEvent.ERROR);
        const onClose = innerHalt(WsEvent.CLOSE);
        socket.addEventListener("ping", heartbeat);
        socket.addEventListener("message", _onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("close", onClose);
        disconnect = (withHalt) => {
          clearTimeout(heartbeatToken);
          outerCleanup();
          disconnect = noop;
          socket.removeEventListener("ping", heartbeat);
          socket.removeEventListener("message", _onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("close", onClose);
          forceSocketClose();
          if (withHalt) onClose({});
          connection.disconnect();
        };
        return connection;
      };
    }),
    () => {
      switchFn();
    }
  );
  outerCleanup = result.cleanup;
  delete result.cleanup;
  const switchFn = (...args) => {
    if (status.type === WsEvent.CLOSE) return;
    if (args.length) switchTo = args;
    if (status.type !== WsEvent.ERROR) disconnect(true);
  };
  return Object.assign(result, { switch: switchFn, getStatus: () => status });
};

const getLegacyWsProvider = (websocketClass) => {
  return (...args) => {
    let endpoints = [];
    let { heartbeatTimeout, timeout, innerEnhancer, onStatusChanged } = defaultConfig;
    const [firstArg] = args;
    if (args.length === 1 && typeof firstArg === "object" && !Array.isArray(firstArg)) {
      endpoints = mapEndpoints(firstArg.endpoints);
      onStatusChanged = firstArg.onStatusChanged ?? noop;
      timeout = firstArg.timeout ?? timeout;
      heartbeatTimeout = firstArg.heartbeatTimeout ?? heartbeatTimeout;
      innerEnhancer = firstArg.innerEnhancer ?? ((x) => x);
    } else {
      if (typeof args[1] === "function")
        onStatusChanged = args[1];
      if (Array.isArray(firstArg)) endpoints = mapEndpoints(firstArg);
      else {
        endpoints = [[firstArg]];
        if (args[1] && args[1] !== onStatusChanged)
          endpoints[0][1] = args[1];
        if (args[2]) onStatusChanged = args[2];
      }
    }
    return getWsProvider$1(
      endpoints.map(
        (x) => x.length === 1 ? x[0] : {
          uri: x[0],
          protocol: x[1]
        }
      ),
      {
        websocketClass,
        onStatusChanged,
        timeout,
        innerEnhancer
      }
    );
  };
};

class WS extends ws.WebSocket {
  close() {
    this.terminate();
  }
}
const getWsProvider = getLegacyWsProvider(
  WS
);

exports.WsEvent = WsEvent;
exports.getWsProvider = getWsProvider;
//# sourceMappingURL=node.js.map
