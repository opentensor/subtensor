import { chainSpecMethods, createChainSpec } from './chainspec.mjs';
import { chainHeadMethods, createChainHead } from './chain-head.mjs';
import { transactionMethods, createTransactionFns } from './transaction.mjs';
import { archiveMethods, createArchive } from './archive.mjs';
import { withNumericIds } from '../with-numeric.mjs';
import { createUpstream } from '../upstream/upstream.mjs';

const supportedMethods = [
  chainSpecMethods,
  archiveMethods,
  chainHeadMethods,
  transactionMethods
].map((methods) => Object.values(methods)).flat();
const createDownstream = () => (upstreamProvider) => {
  const upstream = createUpstream(withNumericIds(upstreamProvider));
  return (onMessage) => {
    const jsonRpc = (input) => onMessage(
      JSON.stringify({
        jsonrpc: "2.0",
        ...input
      })
    );
    const reply = (id, result) => {
      jsonRpc({ id, result });
    };
    const err = (id, code, message) => {
      jsonRpc({ id, error: { code, message } });
    };
    const notification = (method, subscription, result) => {
      jsonRpc({ method, params: { subscription, result } });
    };
    const groups = {
      chainSpec: createChainSpec(upstream, reply, err),
      chainHead: createChainHead(upstream, reply, err, notification),
      archive: createArchive(upstream, reply, err, notification),
      transaction: createTransactionFns(upstream, reply)
    };
    return {
      send: (msg) => {
        let parsedMsg = null;
        try {
          parsedMsg = JSON.parse(msg);
        } catch {
        }
        if (!parsedMsg) return;
        const { id, method, params } = parsedMsg;
        if (id !== null && typeof id !== "string" && typeof id !== "number" || typeof method !== "string") {
          console.warn(`Invalid message:
${msg}`);
          return;
        }
        if (method === "rpc_methods") {
          return upstream.methods.subscribe(
            ({ methods }) => {
              reply(id, {
                methods: [
                  ...supportedMethods,
                  ...methods.filter(
                    (method2) => !supportedMethods.includes(method2)
                  )
                ]
              });
            },
            (e) => {
              console.error(e);
              err(id, -32602, "Invalid");
            }
          );
        }
        const [groupName] = method.split("_");
        if (groupName in groups) {
          try {
            return groups[groupName](
              id,
              method,
              params
            );
          } catch (e) {
            if (e !== null) throw e;
          }
        }
        upstream.request(
          method,
          params,
          (value) => {
            reply(id, value);
          },
          (e) => {
            err(id, e?.code || -1, e?.message || "");
          }
        );
      },
      disconnect: () => {
        groups.chainHead.stop();
        groups.archive.stop();
        groups.transaction.stop();
        upstream.disconnect();
      }
    };
  };
};

export { createDownstream };
//# sourceMappingURL=downstream.mjs.map
