import { createOpaqueToken } from '../utils/create-opaque-token.mjs';
import { noop } from '@polkadot-api/utils';
import { finalize } from 'rxjs';
import { areItemsValid, getStg$ } from './storage.mjs';
import { getMsgFromErr } from '../utils/message-from-error.mjs';

const chainHeadMethods = Object.fromEntries(
  [
    "body",
    "call",
    "continue",
    "follow",
    "header",
    "stopOperation",
    "storage",
    "unfollow",
    "unpin"
  ].map((key) => [key, `chainHead_v1_${key}`])
);
const createChainHead = (upstream, reply, err, notification) => {
  const subscriptions = /* @__PURE__ */ new Map();
  const follow = (rId) => {
    if (subscriptions.size === 2) {
      return err(rId, -32800, "Limit reached");
    }
    const token = createOpaqueToken();
    const up = upstream.getBlocks(token);
    const operations = /* @__PURE__ */ new Map();
    subscriptions.set(token, {
      id: token,
      up,
      operations,
      cleanUp: () => {
        cleanUp();
      }
    });
    let cleanUp = noop;
    reply(rId, token);
    let subscription = up.blocks$.subscribe({
      next(v) {
        notification("chainHead_v1_followEvent", token, v);
      },
      error() {
        cleanUp();
        notification("chainHead_v1_followEvent", token, { event: "stop" });
      }
    });
    cleanUp = () => {
      cleanUp = noop;
      subscription?.unsubscribe();
      subscription = null;
      operations.forEach((cb) => {
        cb();
      });
      operations.clear();
      subscriptions.delete(token);
    };
    if (subscription.closed) cleanUp();
  };
  const unfollow = (rId, followId) => {
    subscriptions.get(followId)?.cleanUp();
    reply(rId, "null");
  };
  const stopOperation = (rId, followId, operationId) => {
    const cb = subscriptions.get(followId)?.operations.get(operationId);
    if (cb) cb();
    reply(rId, "null");
  };
  const header = ({ up: { getHeader } }, reply2, at) => {
    reply2(getHeader(at));
  };
  const unpin = ({ up: { unpin: innerUnpin } }, reply2, hashOrHashes) => {
    const hashes = typeof hashOrHashes === "string" ? [hashOrHashes] : hashOrHashes;
    hashes.forEach(innerUnpin);
    reply2(null);
  };
  const call = ({ operations, id: followId }, reply2, at, method, args) => {
    const operationId = createOpaqueToken();
    reply2({ result: "started", operationId });
    const subscription = upstream.runtimeCall(at, method, args).subscribe(
      (output) => {
        operations.delete(operationId);
        notification("chainHead_v1_call", followId, {
          event: "operationCallDone",
          operationId,
          output
        });
      },
      (e) => {
        operations.delete(operationId);
        notification("chainHead_v1_call", followId, {
          event: "operationError",
          operationId,
          error: getMsgFromErr(e)
        });
      }
    );
    if (!subscription.closed)
      operations.set(operationId, () => {
        subscription.unsubscribe();
        operations.delete(operationId);
      });
  };
  const body = ({ operations, id: followId }, reply2, at) => {
    const operationId = createOpaqueToken();
    reply2({ result: "started", operationId });
    const subscription = upstream.getBody(at).subscribe(
      ({ block: { extrinsics: value } }) => {
        operations.delete(operationId);
        notification("chainHead_v1_body", followId, {
          event: "operationBodyDone",
          operationId,
          value
        });
      },
      (e) => {
        operations.delete(operationId);
        notification("chainHead_v1_body", followId, {
          event: "operationError",
          operationId,
          error: getMsgFromErr(e)
        });
      }
    );
    if (!subscription.closed)
      operations.set(operationId, () => {
        subscription.unsubscribe();
        operations.delete(operationId);
      });
  };
  const stg = ({ operations, id: followId }, reply2, at, items) => {
    const operationId = createOpaqueToken();
    reply2({ result: "started", operationId });
    const innerNotifiaction = (msg) => {
      notification("chainHead_v1_storage", followId, msg);
    };
    const subscription = getStg$(upstream, at, items).pipe(
      finalize(() => {
        operations.delete(operationId);
      })
    ).subscribe(
      (items2) => {
        innerNotifiaction({
          event: "operationStorageItems",
          operationId,
          items: items2
        });
      },
      (e) => {
        innerNotifiaction({
          event: "operationError",
          operationId,
          error: getMsgFromErr(e)
        });
      },
      () => {
        innerNotifiaction({
          event: "operationStorageDone",
          operationId
        });
      }
    );
    if (!subscription.closed)
      operations.set(operationId, () => {
        subscription.unsubscribe();
      });
  };
  const result = (rId, method, params) => {
    if (method === chainHeadMethods.follow) return follow(rId);
    const [followId, ...rest] = params;
    const ctx = subscriptions.get(followId);
    if (!ctx) return err(rId, -32602, "Ivalid followSubscription");
    const innerReply = (value) => {
      reply(rId, value);
    };
    switch (method) {
      case chainHeadMethods.unfollow:
        return unfollow(rId, followId);
      case chainHeadMethods.stopOperation:
        return stopOperation(rId, followId, rest[0]);
      case chainHeadMethods.unpin: {
        const [hashOrHashes] = rest;
        if ((Array.isArray(hashOrHashes) ? hashOrHashes : [hashOrHashes]).some(
          (hash) => typeof hash !== "string"
        ))
          return err(rId, -32602, "Invalid args");
        return unpin(ctx, innerReply, hashOrHashes);
      }
      default: {
        const [at, ...other] = rest;
        if (!ctx.up.isPinned(at)) return err(rId, -32801, "Block not pinned");
        switch (method) {
          case chainHeadMethods.header:
            return header(ctx, innerReply, at);
          case chainHeadMethods.body:
            return body(ctx, innerReply, at);
          case chainHeadMethods.call: {
            const [method2, data] = other;
            if (typeof method2 !== "string" || typeof data !== "string")
              return err(rId, -32602, "Invalid args");
            return call(ctx, innerReply, at, method2, data);
          }
          case chainHeadMethods.storage: {
            const [items] = other;
            return areItemsValid(items) ? stg(ctx, innerReply, at, items) : err(rId, -32602, "Invalid args");
          }
        }
      }
    }
    throw null;
  };
  result.stop = () => {
    subscriptions.forEach((x) => {
      x.cleanUp();
    });
  };
  return result;
};

export { chainHeadMethods, createChainHead };
//# sourceMappingURL=chain-head.mjs.map
