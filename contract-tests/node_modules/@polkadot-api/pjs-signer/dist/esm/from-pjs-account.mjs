import { createV4Tx } from '@polkadot-api/signers-common';
import { AccountId, Blake2256, unifyMetadata, decAnyMetadata } from '@polkadot-api/substrate-bindings';
import { fromHex, toHex } from '@polkadot-api/utils';
import * as pjsSignedExtensionsMappers from './pjs-signed-extensions-mappers.mjs';

const accountIdEnc = AccountId().enc;
const getPublicKey = (address) => address.startsWith("0x") ? fromHex(address) : accountIdEnc(address);
function getPolkadotSignerFromPjs(address, signPayload, signRaw) {
  const signBytes = (data) => signRaw({
    address,
    data: toHex(data),
    type: "bytes"
  }).then(({ signature }) => fromHex(signature));
  const publicKey = getPublicKey(address);
  const signTx = async (callData, signedExtensions, metadata, atBlockNumber, _ = Blake2256) => {
    const decMeta = unifyMetadata(decAnyMetadata(metadata));
    const pjs = {};
    pjs.signedExtensions = [];
    const { version } = decMeta.extrinsic;
    const extra = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed-extension`);
      extra.push(signedExtension.value);
      pjs.signedExtensions.push(identifier);
      if (!pjsSignedExtensionsMappers[identifier]) {
        if (signedExtension.value.length === 0 && signedExtension.additionalSigned.length === 0)
          return;
        throw new Error(
          `PJS does not support this signed-extension: ${identifier}`
        );
      }
      Object.assign(
        pjs,
        pjsSignedExtensionsMappers[identifier](
          signedExtension,
          atBlockNumber
        )
      );
    });
    const checkedVersion = version.includes(4) ? 4 : null;
    if (checkedVersion == null)
      throw new Error("Only extrinsic v4 is supported");
    pjs.address = address;
    pjs.method = toHex(callData);
    pjs.version = checkedVersion;
    pjs.withSignedTransaction = true;
    const result = await signPayload(pjs);
    const tx = result.signedTransaction;
    if (tx) return typeof tx === "string" ? fromHex(tx) : tx;
    return createV4Tx(
      decMeta,
      publicKey,
      fromHex(result.signature),
      extra,
      callData
    );
  };
  return { publicKey, signTx, signBytes };
}

export { getPolkadotSignerFromPjs };
//# sourceMappingURL=from-pjs-account.mjs.map
