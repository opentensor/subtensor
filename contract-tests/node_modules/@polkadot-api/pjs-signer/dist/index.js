'use strict';

var signersCommon = require('@polkadot-api/signers-common');
var substrateBindings = require('@polkadot-api/substrate-bindings');
var utils = require('@polkadot-api/utils');

const toPjsHex = (value, minByteLen) => {
  let inner = value.toString(16);
  inner = (inner.length % 2 ? "0" : "") + inner;
  const nPaddedBytes = Math.max(0, (minByteLen || 0) - inner.length / 2);
  return "0x" + "00".repeat(nPaddedBytes) + inner;
};
const CheckGenesis = ({
  additionalSigned
}) => ({
  genesisHash: utils.toHex(additionalSigned)
});
const CheckNonce = ({
  value
}) => {
  return { nonce: toPjsHex(substrateBindings.compact.dec(value), 4) };
};
const CheckTxVersion = ({
  additionalSigned
}) => {
  return { transactionVersion: toPjsHex(substrateBindings.u32.dec(additionalSigned), 4) };
};
const assetTxPaymentDec = substrateBindings.Struct({
  tip: substrateBindings.compact,
  asset: substrateBindings.Option(substrateBindings.Bytes(Infinity))
}).dec;
const ChargeAssetTxPayment = ({
  value
}) => {
  const { tip, asset } = assetTxPaymentDec(value);
  return {
    ...asset ? { assetId: utils.toHex(asset) } : {},
    tip: toPjsHex(tip, 16)
  };
};
const ChargeTransactionPayment = ({
  value
}) => ({
  tip: toPjsHex(substrateBindings.compactBn.dec(value), 16)
  // u128 => 16 bytes
});
const CheckMortality = ({ value, additionalSigned }, blockNumber) => ({
  era: utils.toHex(value),
  blockHash: utils.toHex(additionalSigned),
  blockNumber: toPjsHex(blockNumber, 4)
});
const CheckSpecVersion = ({
  additionalSigned
}) => ({
  specVersion: toPjsHex(substrateBindings.u32.dec(additionalSigned), 4)
});
const CheckMetadataHash = ({
  value,
  additionalSigned
}) => value.length && value[0] ? {
  mode: 1,
  metadataHash: utils.toHex(
    additionalSigned.length ? additionalSigned.slice(1) : additionalSigned
  )
} : {};

var signedExtensionMappers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ChargeAssetTxPayment: ChargeAssetTxPayment,
  ChargeTransactionPayment: ChargeTransactionPayment,
  CheckGenesis: CheckGenesis,
  CheckMetadataHash: CheckMetadataHash,
  CheckMortality: CheckMortality,
  CheckNonce: CheckNonce,
  CheckSpecVersion: CheckSpecVersion,
  CheckTxVersion: CheckTxVersion
});

const accountIdEnc = substrateBindings.AccountId().enc;
const getPublicKey = (address) => address.startsWith("0x") ? utils.fromHex(address) : accountIdEnc(address);
function getPolkadotSignerFromPjs(address, signPayload, signRaw) {
  const signBytes = (data) => signRaw({
    address,
    data: utils.toHex(data),
    type: "bytes"
  }).then(({ signature }) => utils.fromHex(signature));
  const publicKey = getPublicKey(address);
  const signTx = async (callData, signedExtensions, metadata, atBlockNumber, _ = substrateBindings.Blake2256) => {
    const decMeta = substrateBindings.unifyMetadata(substrateBindings.decAnyMetadata(metadata));
    const pjs = {};
    pjs.signedExtensions = [];
    const { version } = decMeta.extrinsic;
    const extra = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed-extension`);
      extra.push(signedExtension.value);
      pjs.signedExtensions.push(identifier);
      if (!signedExtensionMappers[identifier]) {
        if (signedExtension.value.length === 0 && signedExtension.additionalSigned.length === 0)
          return;
        throw new Error(
          `PJS does not support this signed-extension: ${identifier}`
        );
      }
      Object.assign(
        pjs,
        signedExtensionMappers[identifier](
          signedExtension,
          atBlockNumber
        )
      );
    });
    const checkedVersion = version.includes(4) ? 4 : null;
    if (checkedVersion == null)
      throw new Error("Only extrinsic v4 is supported");
    pjs.address = address;
    pjs.method = utils.toHex(callData);
    pjs.version = checkedVersion;
    pjs.withSignedTransaction = true;
    const result = await signPayload(pjs);
    const tx = result.signedTransaction;
    if (tx) return typeof tx === "string" ? utils.fromHex(tx) : tx;
    return signersCommon.createV4Tx(
      decMeta,
      publicKey,
      utils.fromHex(result.signature),
      extra,
      callData
    );
  };
  return { publicKey, signTx, signBytes };
}

const supportedAccountTypes = /* @__PURE__ */ new Set([
  "ed25519",
  "sr25519",
  "ecdsa",
  "ethereum"
]);
const connectInjectedExtension = async (name, dappName) => {
  let entry = window.injectedWeb3?.[name];
  if (!entry) throw new Error(`Unavailable extension: "${name}"`);
  const enabledExtension = await entry.enable(dappName);
  const signPayload = enabledExtension.signer.signPayload.bind(
    enabledExtension.signer
  );
  const signRaw = enabledExtension.signer.signRaw.bind(enabledExtension.signer);
  const toPolkadotInjected = (accounts) => accounts.filter(({ type }) => supportedAccountTypes.has(type)).map((x) => {
    const polkadotSigner = getPolkadotSignerFromPjs(
      x.address,
      signPayload,
      signRaw
    );
    return {
      ...x,
      polkadotSigner
    };
  });
  let currentAccounts = toPolkadotInjected(
    await enabledExtension.accounts.get()
  );
  const listeners = /* @__PURE__ */ new Set();
  const stop = enabledExtension.accounts.subscribe((x) => {
    currentAccounts = toPolkadotInjected(x);
    listeners.forEach((cb) => {
      cb(currentAccounts);
    });
  });
  return {
    name,
    getAccounts: () => currentAccounts,
    subscribe: (cb) => {
      listeners.add(cb);
      return () => {
        listeners.delete(cb);
      };
    },
    disconnect: () => {
      stop();
    }
  };
};
const getInjectedExtensions = () => {
  const { injectedWeb3 } = window;
  return injectedWeb3 ? Object.keys(injectedWeb3) : [];
};

exports.connectInjectedExtension = connectInjectedExtension;
exports.getInjectedExtensions = getInjectedExtensions;
exports.getPolkadotSignerFromPjs = getPolkadotSignerFromPjs;
//# sourceMappingURL=index.js.map
