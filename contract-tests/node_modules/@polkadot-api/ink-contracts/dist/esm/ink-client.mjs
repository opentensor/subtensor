import { Binary } from '@polkadot-api/substrate-bindings';
import { getInkDynamicBuilder } from './dynamic-builders.mjs';
import { getInkLookup } from './get-lookup.mjs';

const getInkClient = (inkContract) => {
  if (!inkContract.metadata) {
    throw new Error("Ink client needs the contract metadata");
  }
  const lookup = getInkLookup(inkContract.metadata);
  const builder = getInkDynamicBuilder(lookup);
  const constructorCodec = buildCallable(builder.buildConstructor);
  const messageCodec = buildCallable(builder.buildMessage);
  const findConstructor = (label) => {
    const result = lookup.metadata.spec.constructors.find(
      (c) => c.label === label
    );
    if (!result) {
      throw new Error(`Constructor ${label} not found`);
    }
    return result;
  };
  const findMessage = (label) => {
    const result = lookup.metadata.spec.messages.find((c) => c.label === label);
    if (!result) {
      throw new Error(`Message ${label} not found`);
    }
    return result;
  };
  const defaultConstructor = lookup.metadata.spec.constructors.find(
    (c) => c.default
  )?.label;
  const defaultMessage = lookup.metadata.spec.messages.find(
    (c) => c.default
  )?.label;
  return {
    constructor: (label) => ({
      attributes: getAttributes(findConstructor(label)),
      ...constructorCodec(label)
    }),
    defaultConstructor,
    message: (label) => ({
      attributes: getAttributes(findMessage(label)),
      ...messageCodec(label)
    }),
    defaultMessage,
    storage: buildStorage(builder.buildStorage),
    event: Number(lookup.metadata.version) === 4 ? buildEventV4(builder.buildEvents) : buildEventV5(lookup, builder.buildEvent)
  };
};
const getAttributes = (spec) => ({
  payable: spec.payable,
  default: spec.default,
  mutates: "mutates" in spec ? spec.mutates : true
});
const buildCallable = (builder) => (label) => {
  const codecs = builder(label);
  return {
    encode: (value) => Binary.fromBytes(codecs.call.enc(value || {})),
    decode: (response) => codecs.value.dec(response.data.asBytes())
  };
};
const buildStorage = (builder) => (label) => {
  const codecs = builder(label);
  return {
    encode: (key) => Binary.fromBytes(codecs.key.enc(key)),
    decode: (response) => codecs.value.dec(response.asBytes())
  };
};
const buildEventV4 = (eventsDecoder) => {
  const decode = (value) => {
    return eventsDecoder().dec(value.data.asBytes());
  };
  const filter = (address, events = []) => {
    const contractEvents = events.map((v) => "event" in v ? v.event : v).filter(
      (v) => v.type === "Contracts" && v.value.type === "ContractEmitted" && v.value.value.contract === address
    );
    return contractEvents.map((v) => {
      try {
        return decode(v.value.value);
      } catch (ex) {
        console.error(
          `Contract ${address} emitted an incompatible event`,
          v.value.value
        );
        throw ex;
      }
    });
  };
  return { decode, filter };
};
const buildEventV5 = (lookup, eventDecoder) => {
  const metadataEventTopics = new Set(
    lookup.metadata.spec.events.map((evt) => evt.signature_topic).filter((v) => v != null)
  );
  const hasAnonymousEvents = lookup.metadata.spec.events.some(
    (evt) => evt.signature_topic == null
  );
  const decode = (value, signatureTopic) => {
    if (signatureTopic != null) {
      if (!metadataEventTopics.has(signatureTopic)) {
        throw new Error(`Event with signature topic ${value} not found`);
      }
      return eventDecoder(signatureTopic).dec(value.data.asBytes());
    }
    if (!hasAnonymousEvents) {
      throw new Error("Event signature topic required");
    }
    return eventDecoder(void 0).dec(value.data.asBytes());
  };
  const filter = (address, events = []) => {
    const addrEq = (a) => (a instanceof Binary ? a.asHex() : a) === address;
    const contractEvents = events.map((v) => "event" in v ? v : { event: v, topics: v.topics }).filter(
      (v) => (v.event.type === "Contracts" || v.event.type === "Revive") && v.event.value.type === "ContractEmitted" && addrEq(v.event.value.value.contract)
    );
    return contractEvents.map((v) => {
      const eventTopics = [
        ...v.topics,
        ...v.event.value?.value?.topics ?? []
      ].map((evt) => evt.asHex());
      const suitableTopic = eventTopics.find(
        (topic) => metadataEventTopics.has(topic)
      );
      try {
        return decode(v.event.value.value, suitableTopic);
      } catch (ex) {
        return null;
      }
    }).filter((v) => v !== null);
  };
  return {
    decode,
    filter
  };
};

export { getInkClient };
//# sourceMappingURL=ink-client.mjs.map
