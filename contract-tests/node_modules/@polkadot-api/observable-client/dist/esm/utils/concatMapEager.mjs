import { Observable, Subscription, defer } from 'rxjs';

const concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    let isCompleted = false;
    let subscription = inner$.subscribe({
      next(x) {
        if (observerIdx === idx) {
          observer.next(x);
        } else {
          results.get(idx).push(x);
        }
      },
      complete() {
        isCompleted = true;
        innerSubscriptions.delete(idx);
        if (idx === observerIdx) {
          observerIdx++;
          while (results.has(observerIdx)) {
            results.get(observerIdx).forEach((x) => observer.next(x));
            results.delete(observerIdx);
            if (innerSubscriptions.has(observerIdx)) {
              break;
            }
            observerIdx++;
          }
        }
        nextSubscription();
      },
      error(e) {
        observer.error(e);
      }
    });
    if (!isCompleted) innerSubscriptions.set(idx, subscription);
  };
  topSubscription = new Subscription();
  topSubscription.add(
    source$.subscribe({
      next(outterValue) {
        const idx = mapperIdx++;
        queues.set(
          idx,
          defer(() => mapper(outterValue, idx))
        );
        if (innerSubscriptions.size < concurrent) {
          nextSubscription();
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (innerSubscriptions.size === 0) {
          observer.complete();
        }
      }
    })
  );
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

export { concatMapEager };
//# sourceMappingURL=concatMapEager.mjs.map
