import { map, withLatestFrom } from 'rxjs';
import { toHex, mergeUint8, fromHex } from '@polkadot-api/utils';
import { Variant, u8, _void, createDecoder } from '@polkadot-api/substrate-bindings';

const external = new Uint8Array([2]);
const getValidateTxArgs = (tx, hash) => toHex(mergeUint8([external, fromHex(tx), fromHex(hash)]));
const TaggedTransactionQueue = "TaggedTransactionQueue";
const validateTransaction = "validate_transaction";
const [, defaultInvalidTxDecoder] = Variant({
  InvalidTransaction: Variant({
    Call: _void,
    Payment: _void,
    Future: _void,
    Stale: _void,
    BadProof: _void,
    AncientBirthBlock: _void,
    ExhaustsResources: _void,
    Custom: u8,
    BadMandatory: _void,
    MandatoryValidation: _void,
    BadSigner: _void
  }),
  UnknownTransaction: Variant({
    CannotLookup: _void,
    NoUnsignedValidator: _void,
    Custom: u8
  })
});
const defaultValidateTxDecoder = createDecoder((input) => {
  const firstByte = u8.dec(input);
  if (firstByte > 1)
    throw new Error("Unable to decode validateTransaction result");
  if (!firstByte) return { success: true, value: void 0 };
  let value;
  try {
    value = defaultInvalidTxDecoder(input);
  } catch (_) {
    value = {
      type: "UnknownInvalidTx"
    };
  }
  return { success: false, value };
});
const getValidateTx = (call$, getRuntimeContext) => (blockHash, tx) => {
  const decoder$ = getRuntimeContext(blockHash).pipe(
    map((ctx) => {
      try {
        return ctx.dynamicBuilder.buildRuntimeCall(
          TaggedTransactionQueue,
          validateTransaction
        ).value[1];
      } catch (_) {
        return defaultValidateTxDecoder;
      }
    })
  );
  return call$(
    blockHash,
    `${TaggedTransactionQueue}_${validateTransaction}`,
    getValidateTxArgs(tx, blockHash)
  ).pipe(
    withLatestFrom(decoder$),
    map(([result, decoder]) => decoder(result))
  );
};

export { getValidateTx };
//# sourceMappingURL=validate-tx.mjs.map
