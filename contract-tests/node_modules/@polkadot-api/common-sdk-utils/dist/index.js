'use strict';

var rxjs = require('rxjs');

const isResult = (value) => typeof value === "object" && !!value && "success" in value && "value" in value && typeof value.success === "boolean";
const flattenValues = (v) => {
  const result = flattenResult(v);
  return result.success ? { value: result.value } : null;
};
const flattenErrors = (v) => {
  const result = flattenResult(v);
  return result.success ? null : { error: result.value };
};
const flattenResult = (v) => isResult(v) ? v.success ? flattenResult(v.value) : { success: false, value: v.value } : { success: true, value: v };
function mapResult(result, mapFns) {
  return result.success ? {
    success: true,
    value: mapFns.value?.(result.value) ?? result.value
  } : {
    success: false,
    value: mapFns.error?.(result.value) ?? result.value
  };
}

const wrapAsyncTx = (fn) => {
  const promise = fn();
  promise.catch((ex) => {
    console.error(ex);
  });
  return {
    sign: (...args) => promise.then((tx) => tx.sign(...args)),
    signSubmitAndWatch: (...args) => rxjs.from(promise).pipe(rxjs.switchMap((tx) => tx.signSubmitAndWatch(...args))),
    signAndSubmit: (...args) => promise.then((tx) => tx.signAndSubmit(...args)),
    getEstimatedFees: (...args) => promise.then((tx) => tx.getEstimatedFees(...args)),
    getPaymentInfo: (...args) => promise.then((tx) => tx.getPaymentInfo(...args)),
    decodedCall: promise.then((tx) => tx.decodedCall),
    getEncodedData: () => promise.then((tx) => tx.getEncodedData()),
    waited: promise
  };
};

exports.flattenErrors = flattenErrors;
exports.flattenResult = flattenResult;
exports.flattenValues = flattenValues;
exports.mapResult = mapResult;
exports.wrapAsyncTx = wrapAsyncTx;
//# sourceMappingURL=index.js.map
