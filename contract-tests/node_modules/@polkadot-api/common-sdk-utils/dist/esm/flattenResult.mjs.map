{"version":3,"file":"flattenResult.mjs","sources":["../../src/flattenResult.ts"],"sourcesContent":["const isResult = (value: unknown): value is Result =>\n  typeof value === \"object\" &&\n  !!value &&\n  \"success\" in value &&\n  \"value\" in value &&\n  typeof value.success === \"boolean\"\n\nexport type Result<S = unknown, E = unknown> =\n  | { success: true; value: S }\n  | { success: false; value: E }\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { value: number } | null\n */\nexport const flattenValues = <T>(v: T): { value: FlattenValues<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? { value: result.value } : null\n}\nexport type FlattenValues<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ? FlattenValues<(T & { success: true })[\"value\"]>\n      : T\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { error: ErrorA | ErrorB | ErrorC } | null\n */\nexport const flattenErrors = <T>(v: T): { error: FlattenErrors<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? null : { error: result.value }\n}\nexport type FlattenErrors<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ?\n          | (T & { success: false })[\"value\"]\n          | FlattenErrors<(T & { success: true })[\"value\"]>\n      : never\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * Result<number, ErrorA | ErrorB | ErrorC>\n */\nexport const flattenResult = <T>(v: T): FlattenResult<T> =>\n  isResult(v)\n    ? v.success\n      ? (flattenResult as any)(v.value)\n      : ({ success: false, value: v.value } as FlattenResult<T>)\n    : ({ success: true, value: v } as FlattenResult<T>)\nexport type FlattenResult<T> = T extends Result\n  ? Result<FlattenValues<T>, FlattenErrors<T>>\n  : never\n\n// `any extends number ? true : false` ==> boolean. So we have to double-check\n// setting the case for `false` to `boolean` for a bit more clarification.\ntype IsAny<T> = (any extends T ? true : boolean) extends true ? true : false\n\nexport function mapResult<SI, EI, SO = SI, EO = EI>(\n  result: Result<SI, EI>,\n  mapFns: {\n    value?: (value: SI) => SO\n    error?: (error: EI) => EO\n  },\n): Result<SO, EO> {\n  return result.success\n    ? {\n        success: true,\n        value: mapFns.value?.(result.value) ?? (result.value as unknown as SO),\n      }\n    : {\n        success: false,\n        value: mapFns.error?.(result.value) ?? (result.value as unknown as EO),\n      }\n}\n"],"names":[],"mappings":"AAAA,MAAM,QAAA,GAAW,CAAC,KAAA,KAChB,OAAO,UAAU,QAAA,IACjB,CAAC,CAAC,KAAA,IACF,aAAa,KAAA,IACb,OAAA,IAAW,KAAA,IACX,OAAO,MAAM,OAAA,KAAY,SAAA;AAUpB,MAAM,aAAA,GAAgB,CAAI,CAAA,KAA6C;AAC5E,EAAA,MAAM,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAA,GAAU,EAAE,KAAA,EAAO,MAAA,CAAO,OAAM,GAAI,IAAA;AACpD;AAYO,MAAM,aAAA,GAAgB,CAAI,CAAA,KAA6C;AAC5E,EAAA,MAAM,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAA,GAAU,IAAA,GAAO,EAAE,KAAA,EAAO,OAAO,KAAA,EAAM;AACvD;AAcO,MAAM,aAAA,GAAgB,CAAI,CAAA,KAC/B,QAAA,CAAS,CAAC,CAAA,GACN,CAAA,CAAE,OAAA,GACC,aAAA,CAAsB,CAAA,CAAE,KAAK,IAC7B,EAAE,OAAA,EAAS,KAAA,EAAO,KAAA,EAAO,CAAA,CAAE,KAAA,KAC7B,EAAE,OAAA,EAAS,IAAA,EAAM,KAAA,EAAO,CAAA;AASxB,SAAS,SAAA,CACd,QACA,MAAA,EAIgB;AAChB,EAAA,OAAO,OAAO,OAAA,GACV;AAAA,IACE,OAAA,EAAS,IAAA;AAAA,IACT,OAAO,MAAA,CAAO,KAAA,GAAQ,MAAA,CAAO,KAAK,KAAM,MAAA,CAAO;AAAA,GACjD,GACA;AAAA,IACE,OAAA,EAAS,KAAA;AAAA,IACT,OAAO,MAAA,CAAO,KAAA,GAAQ,MAAA,CAAO,KAAK,KAAM,MAAA,CAAO;AAAA,GACjD;AACN;;;;"}