{"version":3,"file":"index.js","sources":["../src/flattenResult.ts","../src/asyncTransaction.ts"],"sourcesContent":["const isResult = (value: unknown): value is Result =>\n  typeof value === \"object\" &&\n  !!value &&\n  \"success\" in value &&\n  \"value\" in value &&\n  typeof value.success === \"boolean\"\n\nexport type Result<S = unknown, E = unknown> =\n  | { success: true; value: S }\n  | { success: false; value: E }\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { value: number } | null\n */\nexport const flattenValues = <T>(v: T): { value: FlattenValues<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? { value: result.value } : null\n}\nexport type FlattenValues<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ? FlattenValues<(T & { success: true })[\"value\"]>\n      : T\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * { error: ErrorA | ErrorB | ErrorC } | null\n */\nexport const flattenErrors = <T>(v: T): { error: FlattenErrors<T> } | null => {\n  const result = flattenResult(v)\n  return result.success ? null : { error: result.value }\n}\nexport type FlattenErrors<T> =\n  IsAny<T> extends true\n    ? any\n    : T extends Result\n      ?\n          | (T & { success: false })[\"value\"]\n          | FlattenErrors<(T & { success: true })[\"value\"]>\n      : never\n\n/**\n * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into\n * Result<number, ErrorA | ErrorB | ErrorC>\n */\nexport const flattenResult = <T>(v: T): FlattenResult<T> =>\n  isResult(v)\n    ? v.success\n      ? (flattenResult as any)(v.value)\n      : ({ success: false, value: v.value } as FlattenResult<T>)\n    : ({ success: true, value: v } as FlattenResult<T>)\nexport type FlattenResult<T> = T extends Result\n  ? Result<FlattenValues<T>, FlattenErrors<T>>\n  : never\n\n// `any extends number ? true : false` ==> boolean. So we have to double-check\n// setting the case for `false` to `boolean` for a bit more clarification.\ntype IsAny<T> = (any extends T ? true : boolean) extends true ? true : false\n\nexport function mapResult<SI, EI, SO = SI, EO = EI>(\n  result: Result<SI, EI>,\n  mapFns: {\n    value?: (value: SI) => SO\n    error?: (error: EI) => EO\n  },\n): Result<SO, EO> {\n  return result.success\n    ? {\n        success: true,\n        value: mapFns.value?.(result.value) ?? (result.value as unknown as SO),\n      }\n    : {\n        success: false,\n        value: mapFns.error?.(result.value) ?? (result.value as unknown as EO),\n      }\n}\n","import type { Transaction, Binary } from \"polkadot-api\"\nimport { from, switchMap } from \"rxjs\"\n\nexport type AsyncTransaction<\n  Arg extends {} | undefined = any,\n  Pallet extends string = any,\n  Name extends string = any,\n  Asset = any,\n> = Omit<\n  Transaction<Arg, Pallet, Name, Asset>,\n  \"decodedCall\" | \"getEncodedData\"\n> & {\n  decodedCall: Promise<Transaction<Arg, Pallet, Name, Asset>[\"decodedCall\"]>\n  getEncodedData: () => Promise<Binary>\n  waited: Promise<Transaction<Arg, Pallet, Name, Asset>>\n}\n\nexport const wrapAsyncTx = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset,\n>(\n  fn: () => Promise<Transaction<Arg, Pallet, Name, Asset>>,\n): AsyncTransaction<Arg, Pallet, Name, Asset> => {\n  const promise = fn()\n\n  // Prevent some runtimes from terminating for an uncaught exception\n  promise.catch((ex) => {\n    console.error(ex)\n  })\n\n  return {\n    sign: (...args) => promise.then((tx) => tx.sign(...args)),\n    signSubmitAndWatch: (...args) =>\n      from(promise).pipe(switchMap((tx) => tx.signSubmitAndWatch(...args))),\n    signAndSubmit: (...args) => promise.then((tx) => tx.signAndSubmit(...args)),\n    getEstimatedFees: (...args) =>\n      promise.then((tx) => tx.getEstimatedFees(...args)),\n    getPaymentInfo: (...args) =>\n      promise.then((tx) => tx.getPaymentInfo(...args)),\n    decodedCall: promise.then((tx) => tx.decodedCall),\n    getEncodedData: () => promise.then((tx) => tx.getEncodedData()),\n    waited: promise,\n  }\n}\n"],"names":["from","switchMap"],"mappings":";;;;AAAA,MAAM,QAAA,GAAW,CAAC,KAAA,KAChB,OAAO,UAAU,QAAA,IACjB,CAAC,CAAC,KAAA,IACF,aAAa,KAAA,IACb,OAAA,IAAW,KAAA,IACX,OAAO,MAAM,OAAA,KAAY,SAAA;AAUpB,MAAM,aAAA,GAAgB,CAAI,CAAA,KAA6C;AAC5E,EAAA,MAAM,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAA,GAAU,EAAE,KAAA,EAAO,MAAA,CAAO,OAAM,GAAI,IAAA;AACpD;AAYO,MAAM,aAAA,GAAgB,CAAI,CAAA,KAA6C;AAC5E,EAAA,MAAM,MAAA,GAAS,cAAc,CAAC,CAAA;AAC9B,EAAA,OAAO,OAAO,OAAA,GAAU,IAAA,GAAO,EAAE,KAAA,EAAO,OAAO,KAAA,EAAM;AACvD;AAcO,MAAM,aAAA,GAAgB,CAAI,CAAA,KAC/B,QAAA,CAAS,CAAC,CAAA,GACN,CAAA,CAAE,OAAA,GACC,aAAA,CAAsB,CAAA,CAAE,KAAK,IAC7B,EAAE,OAAA,EAAS,KAAA,EAAO,KAAA,EAAO,CAAA,CAAE,KAAA,KAC7B,EAAE,OAAA,EAAS,IAAA,EAAM,KAAA,EAAO,CAAA;AASxB,SAAS,SAAA,CACd,QACA,MAAA,EAIgB;AAChB,EAAA,OAAO,OAAO,OAAA,GACV;AAAA,IACE,OAAA,EAAS,IAAA;AAAA,IACT,OAAO,MAAA,CAAO,KAAA,GAAQ,MAAA,CAAO,KAAK,KAAM,MAAA,CAAO;AAAA,GACjD,GACA;AAAA,IACE,OAAA,EAAS,KAAA;AAAA,IACT,OAAO,MAAA,CAAO,KAAA,GAAQ,MAAA,CAAO,KAAK,KAAM,MAAA,CAAO;AAAA,GACjD;AACN;;AC5DO,MAAM,WAAA,GAAc,CAMzB,EAAA,KAC+C;AAC/C,EAAA,MAAM,UAAU,EAAA,EAAG;AAGnB,EAAA,OAAA,CAAQ,KAAA,CAAM,CAAC,EAAA,KAAO;AACpB,IAAA,OAAA,CAAQ,MAAM,EAAE,CAAA;AAAA,EAClB,CAAC,CAAA;AAED,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,CAAA,GAAI,IAAA,KAAS,OAAA,CAAQ,IAAA,CAAK,CAAC,EAAA,KAAO,EAAA,CAAG,IAAA,CAAK,GAAG,IAAI,CAAC,CAAA;AAAA,IACxD,kBAAA,EAAoB,CAAA,GAAI,IAAA,KACtBA,SAAA,CAAK,OAAO,CAAA,CAAE,IAAA,CAAKC,cAAA,CAAU,CAAC,OAAO,EAAA,CAAG,kBAAA,CAAmB,GAAG,IAAI,CAAC,CAAC,CAAA;AAAA,IACtE,aAAA,EAAe,CAAA,GAAI,IAAA,KAAS,OAAA,CAAQ,IAAA,CAAK,CAAC,EAAA,KAAO,EAAA,CAAG,aAAA,CAAc,GAAG,IAAI,CAAC,CAAA;AAAA,IAC1E,gBAAA,EAAkB,CAAA,GAAI,IAAA,KACpB,OAAA,CAAQ,IAAA,CAAK,CAAC,EAAA,KAAO,EAAA,CAAG,gBAAA,CAAiB,GAAG,IAAI,CAAC,CAAA;AAAA,IACnD,cAAA,EAAgB,CAAA,GAAI,IAAA,KAClB,OAAA,CAAQ,IAAA,CAAK,CAAC,EAAA,KAAO,EAAA,CAAG,cAAA,CAAe,GAAG,IAAI,CAAC,CAAA;AAAA,IACjD,aAAa,OAAA,CAAQ,IAAA,CAAK,CAAC,EAAA,KAAO,GAAG,WAAW,CAAA;AAAA,IAChD,cAAA,EAAgB,MAAM,OAAA,CAAQ,IAAA,CAAK,CAAC,EAAA,KAAO,EAAA,CAAG,gBAAgB,CAAA;AAAA,IAC9D,MAAA,EAAQ;AAAA,GACV;AACF;;;;;;;;"}