import { Transaction, Binary } from 'polkadot-api';

type Result<S = unknown, E = unknown> = {
    success: true;
    value: S;
} | {
    success: false;
    value: E;
};
/**
 * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into
 * { value: number } | null
 */
declare const flattenValues: <T>(v: T) => {
    value: FlattenValues<T>;
} | null;
type FlattenValues<T> = IsAny<T> extends true ? any : T extends Result ? FlattenValues<(T & {
    success: true;
})["value"]> : T;
/**
 * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into
 * { error: ErrorA | ErrorB | ErrorC } | null
 */
declare const flattenErrors: <T>(v: T) => {
    error: FlattenErrors<T>;
} | null;
type FlattenErrors<T> = IsAny<T> extends true ? any : T extends Result ? (T & {
    success: false;
})["value"] | FlattenErrors<(T & {
    success: true;
})["value"]> : never;
/**
 * Flattens a nested Result<Result<Result<number>, ErrorA>, ErrorB>, ErrorC> into
 * Result<number, ErrorA | ErrorB | ErrorC>
 */
declare const flattenResult: <T>(v: T) => FlattenResult<T>;
type FlattenResult<T> = T extends Result ? Result<FlattenValues<T>, FlattenErrors<T>> : never;
type IsAny<T> = (any extends T ? true : boolean) extends true ? true : false;
declare function mapResult<SI, EI, SO = SI, EO = EI>(result: Result<SI, EI>, mapFns: {
    value?: (value: SI) => SO;
    error?: (error: EI) => EO;
}): Result<SO, EO>;

type AsyncTransaction<Arg extends {} | undefined = any, Pallet extends string = any, Name extends string = any, Asset = any> = Omit<Transaction<Arg, Pallet, Name, Asset>, "decodedCall" | "getEncodedData"> & {
    decodedCall: Promise<Transaction<Arg, Pallet, Name, Asset>["decodedCall"]>;
    getEncodedData: () => Promise<Binary>;
    waited: Promise<Transaction<Arg, Pallet, Name, Asset>>;
};
declare const wrapAsyncTx: <Arg extends {} | undefined, Pallet extends string, Name extends string, Asset>(fn: () => Promise<Transaction<Arg, Pallet, Name, Asset>>) => AsyncTransaction<Arg, Pallet, Name, Asset>;

type SdkDefinition<P, R> = {
    descriptors: Promise<any> & {
        pallets: P;
        apis: R;
    };
    asset: any;
    metadataTypes: any;
    getMetadata: any;
    genesis: any;
};

export { flattenErrors, flattenResult, flattenValues, mapResult, wrapAsyncTx };
export type { AsyncTransaction, FlattenErrors, FlattenResult, FlattenValues, Result, SdkDefinition };
