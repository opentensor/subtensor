declare const accountId: (publicKey: Hex) => Uint8Array<ArrayBufferLike>;

declare const mnemonicToEntropy: (mnemonic: string, wordlistStr?: string) => Uint8Array;
declare const entropyToMnemonic: (entropy: Uint8Array, wordlistStr?: string) => string;
declare const generateMnemonic: (strength?: number, wordlist?: string) => string;
declare const validateMnemonic: (mnemonic: string, wordlist?: string) => boolean;

declare const BIP39_EN_WORDLIST: string;

declare const DEV_PHRASE = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";
declare const DEV_MINI_SECRET = "fac7959dbfe72f052e5a0c3c8d6530f202b02fd8f9f5ca3580ec8deb7797479e";

type DeriveKeyPairFn = (seed: Uint8Array, curve: Curve, derivations: [type: "hard" | "soft", chainCodes: Uint8Array][]) => KeyPair;

type Hex = Uint8Array | string;
type Curve = {
    getPublicKey: (privateKey: Hex) => Uint8Array;
    sign: (message: Hex, privateKey: Hex) => Uint8Array;
    verify: (signature: Hex, message: Hex, publicKey: Hex) => boolean;
};
type KeyPair = {
    publicKey: Uint8Array;
    sign: (message: Hex) => Uint8Array;
};
type DeriveFn = (path: string) => KeyPair;

type CreateDeriveOptions = {
    seed: Hex;
    curve: Curve;
    derive: DeriveKeyPairFn;
};
declare const createDerive: ({ seed, curve, derive }: CreateDeriveOptions) => DeriveFn;

declare const ecdsa: Curve;

declare const ecdsaDerive: DeriveKeyPairFn;

declare const ed25519: Curve;

declare const ed25519Derive: DeriveKeyPairFn;

declare const parseSuri: (suri: string) => {
    phrase: string | undefined;
    paths: string | undefined;
    password: string | undefined;
};

declare const sr25519: Curve;

declare const sr25519Derive: DeriveKeyPairFn;

declare const ss58Encode: (payload: Hex, prefix?: number) => string;
declare const ss58Decode: (addressStr: string) => [payload: Uint8Array, prefix: number];

declare const ss58Address: (publicKey: Hex, prefix?: number) => string;

declare const ss58PublicKey: (publicKey: Hex, prefix?: number) => string;

declare const entropyToMiniSecret: (entropy: Uint8Array, password?: string) => Uint8Array;
declare const entropyToMiniSecretAsync: (entropy: Uint8Array, password?: string) => Promise<Uint8Array>;
declare const mnemonicToMiniSecret: (mnemonic: string, password?: string, wordlist?: string) => Uint8Array;
declare const mnemonicToMiniSecretAsync: (mnemonic: string, password?: string, wordlist?: string) => Promise<Uint8Array>;

declare const blake2b256: (msg: Hex) => Uint8Array<ArrayBufferLike>;
declare const blake2b512: (msg: Hex) => Uint8Array<ArrayBufferLike>;
/**
 * Adapted from: https://github.com/paulmillr/noble-curves/blob/a0ac59846ee76c52f7c18886f4963e1211345d48/src/utils.ts#L104 (MIT License)
 *
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
declare const ensureBytes: (title: string, hex: Hex, expectedLength?: number) => Uint8Array<ArrayBufferLike>;
declare const createDeriveKeyPairFn: (prefix: string) => DeriveKeyPairFn;

export { BIP39_EN_WORDLIST, type Curve, DEV_MINI_SECRET, DEV_PHRASE, type DeriveFn, type Hex, type KeyPair, accountId, blake2b256, blake2b512, createDerive, createDeriveKeyPairFn, ecdsa, ecdsaDerive, ed25519, ed25519Derive, ensureBytes, entropyToMiniSecret, entropyToMiniSecretAsync, entropyToMnemonic, generateMnemonic, mnemonicToEntropy, mnemonicToMiniSecret, mnemonicToMiniSecretAsync, parseSuri, sr25519, sr25519Derive, ss58Address, ss58Decode, ss58Encode, ss58PublicKey, validateMnemonic };
