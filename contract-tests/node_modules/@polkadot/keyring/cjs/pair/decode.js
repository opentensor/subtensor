"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePair = decodePair;
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const defaults_js_1 = require("./defaults.js");
const SEED_OFFSET = defaults_js_1.PAIR_HDR.length;
/**
 * Decode a pair, taking into account the generation-specific formats and headers
 *
 * For divisor/headers, don't rely on the magic being static. These will
 * change between generations, aka with the long-awaited 4th generation
 * of the format. The external decode interface is the only way to use and decode these.
 **/
function decodePair(passphrase, encrypted, _encType) {
    const encType = Array.isArray(_encType) || _encType === undefined
        ? _encType
        : [_encType];
    const decrypted = (0, util_crypto_1.jsonDecryptData)(encrypted, passphrase, encType);
    const header = decrypted.subarray(0, defaults_js_1.PAIR_HDR.length);
    // check the start header (generations 1-3)
    if (!(0, util_1.u8aEq)(header, defaults_js_1.PAIR_HDR)) {
        throw new Error('Invalid encoding header found in body');
    }
    // setup for generation 3 format
    let secretKey = decrypted.subarray(SEED_OFFSET, SEED_OFFSET + defaults_js_1.SEC_LENGTH);
    let divOffset = SEED_OFFSET + defaults_js_1.SEC_LENGTH;
    let divider = decrypted.subarray(divOffset, divOffset + defaults_js_1.PAIR_DIV.length);
    // old-style (generation 1 & 2), we have the seed here
    if (!(0, util_1.u8aEq)(divider, defaults_js_1.PAIR_DIV)) {
        divOffset = SEED_OFFSET + defaults_js_1.SEED_LENGTH;
        secretKey = decrypted.subarray(SEED_OFFSET, divOffset);
        divider = decrypted.subarray(divOffset, divOffset + defaults_js_1.PAIR_DIV.length);
        // check the divisior at this point (already checked for generation 3)
        if (!(0, util_1.u8aEq)(divider, defaults_js_1.PAIR_DIV)) {
            throw new Error('Invalid encoding divider found in body');
        }
    }
    const pubOffset = divOffset + defaults_js_1.PAIR_DIV.length;
    const publicKey = decrypted.subarray(pubOffset, pubOffset + defaults_js_1.PUB_LENGTH);
    return {
        publicKey,
        secretKey
    };
}
