import { map, firstValueFrom, mergeMap } from 'rxjs';
import { concatMapEager } from '@polkadot-api/observable-client';
import { shareLatest } from './utils/shareLatest.mjs';
import '@polkadot-api/utils';
import 'rxjs/operators';

const createEventEntry = (pallet, name, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  withCompatibleRuntime,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead.finalized$.pipe(
    withCompatibleRuntime(chainHead, (x) => x.hash),
    map(([block, runtime, ctx]) => {
      const eventsIdx = ctx.lookup.metadata.pallets.find(
        (p) => p.name === pallet
      )?.events?.type;
      if (eventsIdx == null || ctx.lookup.metadata.lookup[eventsIdx].def.tag !== "variant" || ctx.lookup.metadata.lookup[eventsIdx].def.value.find(
        (ev) => ev.name === name
      ) == null)
        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`);
      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError();
      return [block, runtime, ctx];
    }),
    concatMapEager(
      ([block, runtime, ctx]) => chainHead.eventsAt$(block.hash).pipe(
        map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))
              throw compatibilityError();
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe(mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom(shared$);
  const filter = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter, getCompatibilityLevel, isCompatible };
};

export { createEventEntry };
//# sourceMappingURL=event.mjs.map
