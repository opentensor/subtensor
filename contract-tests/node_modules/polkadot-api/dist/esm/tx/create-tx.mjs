import { u64, u32, u16, u8 } from '@polkadot-api/substrate-bindings';
import { toHex, fromHex } from '@polkadot-api/utils';
import { combineLatest, of, take, mergeMap, filter, map, switchMap, catchError, scan, startWith, distinctUntilChanged } from 'rxjs';
import { getSignExtensionsCreator } from './signed-extensions/sign-extensions.mjs';

const NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
const lenToDecoder = {
  1: u8.dec,
  2: u16.dec,
  4: u32.dec,
  8: u64.dec
};
const getNonceAtBlock$ = (call$, from, at) => call$(at, NONCE_RUNTIME_CALL, from).pipe(
  map((result) => {
    const bytes = fromHex(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return decoder(bytes);
  })
);
const createTx = (chainHead, signer, callData, atBlock, customSignedExtensions, hinted = {}) => combineLatest([
  hinted.nonce ? of(hinted.nonce) : getNonce$(chainHead, toHex(signer.publicKey)),
  chainHead.getRuntimeContext$(atBlock.hash),
  chainHead.genesis$
]).pipe(
  take(1),
  mergeMap(([nonce, ctx, genesis]) => {
    const signExtCreator = getSignExtensionsCreator(
      fromHex(genesis),
      ctx.lookup,
      ctx.dynamicBuilder
    );
    const mortality = hinted.mortality ?? { period: 64, mortal: true };
    const signExtensions = signExtCreator({
      nonce,
      tip: hinted.tip ?? 0n,
      mortality: mortality.mortal ? {
        mortal: true,
        period: mortality.period,
        startAtBlock: {
          height: atBlock.number,
          hash: atBlock.hash
        }
      } : { mortal: false },
      customSignedExtensions,
      asset: hinted.asset
    });
    return signer.signTx(
      callData,
      signExtensions,
      ctx.metadataRaw,
      atBlock.number
    );
  })
);
const getNonce$ = (chainHead, from) => {
  const followHead$ = (head) => chainHead.newBlocks$.pipe(
    scan((acc, block) => block.parent === acc ? block.hash : acc, head),
    startWith(head),
    distinctUntilChanged()
  );
  const followNonce$ = (head) => followHead$(head).pipe(
    take(2),
    switchMap((hash) => getNonceAtBlock$(chainHead.call$, from, hash))
  );
  const getHeadsNonce$ = (heads) => combineLatest(
    heads.map(
      (head) => followNonce$(head).pipe(
        map((value) => ({
          success: true,
          value
        })),
        catchError(
          (err) => of({
            success: false,
            value: err
          })
        )
      )
    )
  ).pipe(take(1));
  return chainHead.pinnedBlocks$.pipe(
    filter((v) => !v.recovering && v.blocks.size > 0),
    take(1),
    map(({ blocks, best }) => {
      const bestBlock = blocks.get(best);
      return [...blocks.values()].filter(
        (v) => !v.unpinnable && v.children.size === 0 && v.number >= bestBlock.number
      ).map((v) => v.hash);
    }),
    switchMap(getHeadsNonce$),
    map((result) => {
      const winner = result.reduce(
        (acc, v) => v.success ? v.value >= (acc ?? 0) ? v.value : acc : acc,
        null
      );
      if (winner == null) {
        throw result[0].value;
      }
      return winner;
    })
  );
};

export { createTx };
//# sourceMappingURL=create-tx.mjs.map
