import { EntryPointCodec, TypedefCodec, mapLookupToTypedef, CompatibilityLevel, valueIsCompatibleWithDest, entryPointsAreCompatible } from '@polkadot-api/metadata-compatibility';
import { Vector, Tuple } from '@polkadot-api/substrate-bindings';
import { filter, firstValueFrom, combineLatest, map } from 'rxjs';

class RuntimeToken {
  constructor() {
  }
  // @ts-ignore
  _runtime(value) {
  }
}
class CompatibilityToken {
  constructor() {
  }
  // @ts-ignore
  _compatibility(value) {
  }
}
const compatibilityTokenApi = /* @__PURE__ */ new WeakMap();
const runtimeTokenApi = /* @__PURE__ */ new WeakMap();
const getCompatibilityApi = (token) => token instanceof RuntimeToken ? runtimeTokenApi.get(token) : compatibilityTokenApi.get(token);
var OpType = /* @__PURE__ */ ((OpType2) => {
  OpType2["Storage"] = "storage";
  OpType2["Tx"] = "tx";
  OpType2["Event"] = "events";
  OpType2["Const"] = "constants";
  OpType2["ViewFns"] = "viewFns";
  OpType2["Api"] = "apis";
  return OpType2;
})(OpType || {});
const EntryPointsCodec = Vector(EntryPointCodec);
const TypedefsCodec = Vector(TypedefCodec);
const TypesCodec = Tuple(EntryPointsCodec, TypedefsCodec);
const createCompatibilityToken = (chainDefinition, chainHead) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = Promise.all([
    chainDefinition.metadataTypes.then(TypesCodec.dec),
    chainDefinition.descriptors,
    awaitedRuntime
  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {
    const token = new CompatibilityToken();
    compatibilityTokenApi.set(token, {
      runtime,
      getEntryPoint(opType, pallet, name) {
        const idx = descriptors[opType]?.[pallet]?.[name];
        if (idx == null)
          throw new Error(
            `Descriptor for ${opType} ${pallet}.${name} does not exist`
          );
        return entryPoints[idx];
      },
      typedefNodes
    });
    return token;
  });
  return promise;
};
const createRuntimeToken = (chainHead) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead.runtime$.pipe(filter((v) => v != null));
    let latest = await firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = awaitedRuntime.then((runtime) => {
    const token = new RuntimeToken();
    runtimeTokenApi.set(token, {
      runtime
    });
    return token;
  });
  return promise;
};
const metadataCache = /* @__PURE__ */ new WeakMap();
const getMetadataCache = (ctx) => {
  if (!metadataCache.has(ctx.metadataRaw)) {
    metadataCache.set(ctx.metadataRaw, {
      compat: /* @__PURE__ */ new Map(),
      lookup: ctx.lookup,
      typeNodes: []
    });
  }
  return metadataCache.get(ctx.metadataRaw);
};
const compatibilityHelper = (descriptors, getDescriptorEntryPoint, getRuntimeEntryPoint) => {
  const getRuntimeTypedef = (ctx, id) => {
    var _a;
    const cache = getMetadataCache(ctx);
    return (_a = cache.typeNodes)[id] || (_a[id] = mapLookupToTypedef(cache.lookup(id)));
  };
  function getCompatibilityLevels(descriptors2, ctx) {
    if (descriptors2 instanceof RuntimeToken) {
      return {
        args: CompatibilityLevel.Identical,
        values: CompatibilityLevel.Identical
      };
    }
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    ctx || (ctx = compatibilityApi.runtime());
    const runtimeEntryPoint = getRuntimeEntryPoint(ctx);
    if (runtimeEntryPoint == null)
      return {
        args: CompatibilityLevel.Incompatible,
        values: CompatibilityLevel.Incompatible
      };
    const descriptorNodes = compatibilityApi.typedefNodes;
    const cache = getMetadataCache(ctx);
    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi);
    const result = entryPointsAreCompatible(
      descriptorEntryPoint,
      (id) => descriptorNodes[id],
      runtimeEntryPoint,
      (id) => getRuntimeTypedef(ctx, id),
      cache.compat
    );
    return {
      args: result.args.level,
      values: result.values.level
    };
  }
  const getCompatibilityLevel = withOptionalToken(
    descriptors,
    (runtime) => minCompatLevel(getCompatibilityLevels(runtime))
  );
  const isCompatible = withOptionalToken(
    descriptors,
    (threshold, runtime) => getCompatibilityLevel(runtime) >= threshold
  );
  const compatibleRuntime$ = (chainHead, hash) => combineLatest([descriptors, chainHead.getRuntimeContext$(hash)]);
  const withCompatibleRuntime = (chainHead, mapper) => (source$) => combineLatest([
    source$.pipe(chainHead.withRuntime(mapper)),
    descriptors
  ]).pipe(map(([[x, ctx], descriptors2]) => [x, descriptors2, ctx]));
  const argsAreCompatible = (descriptors2, ctx, args) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const levels = getCompatibilityLevels(descriptors2, ctx);
    if (levels.args === CompatibilityLevel.Incompatible) return false;
    if (levels.args > CompatibilityLevel.Partial) return true;
    if (levels.values === CompatibilityLevel.Incompatible) return false;
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    return valueIsCompatibleWithDest(
      entryPoint.args,
      (id) => getRuntimeTypedef(ctx, id),
      args
    );
  };
  const valuesAreCompatible = (descriptors2, ctx, values) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const level = getCompatibilityLevels(descriptors2, ctx).values;
    if (level === CompatibilityLevel.Incompatible) return false;
    if (level > CompatibilityLevel.Partial) return true;
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    const entryPoint = getDescriptorEntryPoint(compatibilityApi);
    return valueIsCompatibleWithDest(
      entryPoint.values,
      (id) => compatibilityApi.typedefNodes[id],
      values
    );
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getCompatibilityLevels,
    descriptors,
    withCompatibleRuntime,
    compatibleRuntime$,
    argsAreCompatible,
    valuesAreCompatible,
    getRuntimeTypedef
  };
};
const minCompatLevel = (levels) => Math.min(levels.args, levels.values);
const withOptionalToken = (compatibilityToken, fn) => (...args) => {
  const lastElement = args.at(-1);
  if (lastElement instanceof CompatibilityToken || lastElement instanceof RuntimeToken) {
    return fn(...args);
  }
  return compatibilityToken.then((token) => fn(...args, token));
};

export { CompatibilityToken, OpType, RuntimeToken, compatibilityHelper, createCompatibilityToken, createRuntimeToken, getCompatibilityApi, minCompatLevel };
//# sourceMappingURL=compatibility.mjs.map
