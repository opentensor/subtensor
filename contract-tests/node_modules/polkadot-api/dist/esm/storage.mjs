import { BlockNotPinnedError } from '@polkadot-api/observable-client';
import './utils/shareLatest.mjs';
import { map, filter, take, identity, shareReplay, pipe, combineLatestWith, distinctUntilChanged, from, mergeMap, catchError } from 'rxjs';
import { firstValueFromWithSignal } from './utils/firstValueFromWithSignal.mjs';
import { lossLessExhaustMap } from './utils/lossLessExhaustMap.mjs';
import { isOptionalArg } from './utils/optional-arg.mjs';
import 'rxjs/operators';
import { CompatibilityLevel } from '@polkadot-api/metadata-compatibility';
import { FixedSizeBinary } from '@polkadot-api/substrate-bindings';
import { minCompatLevel, CompatibilityToken, RuntimeToken, getCompatibilityApi } from './compatibility.mjs';

const toMapped = map((x) => x.mapped);
const createStorageEntry = (pallet, name, chainHead, getWatchEntries, {
  isCompatible,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead.runtime$.pipe(
    filter(Boolean),
    take(1),
    map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : identity
    ),
    shareReplay()
  );
  const bigIntOrNumber = pipe(
    combineLatestWith(sysNumberMapper$),
    map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!argsAreCompatible(descriptors, ctx, actualArgs))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const mapped = data === null ? codecs.fallback : codecs.value.dec(data);
            if (!valuesAreCompatible(descriptors, ctx, mapped))
              throw incompatibleError();
            return { raw: data, mapped };
          }
        )
      ),
      chainHead.withHodl(at)
    );
    if (isSystemNumber)
      return chainHead.pinnedBlocks$.pipe(
        map((blocks) => {
          const hash = at === "finalized" || !at ? blocks.finalized : at === "best" ? blocks.best : at;
          const block = blocks.blocks.get(hash);
          if (!block) {
            throw new BlockNotPinnedError(hash, "System.Number");
          }
          return block.number;
        }),
        distinctUntilChanged(),
        bigIntOrNumber,
        map((mapped) => ({ raw: mapped.toString(), mapped })),
        catchError((e) => {
          if (e instanceof BlockNotPinnedError) return result$;
          throw e;
        })
      );
    return isBlockHash && Number(args[0]) === 0 ? chainHead.genesis$.pipe(
      map((raw) => ({ raw, mapped: FixedSizeBinary.fromHex(raw) }))
    ) : result$;
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = from(descriptorsPromise).pipe(
      mergeMap(
        (descriptors) => chainHead.storage$(
          at,
          "descendantsValues",
          (ctx) => {
            const codecs = getCodec(ctx);
            if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === CompatibilityLevel.Incompatible)
              throw incompatibleError();
            if (args.length > codecs.len) throw invalidArgs(args);
            const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
            if (args.length === codecs.len && actualArgs === args)
              throw invalidArgs(args);
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (values, ctx) => {
            const codecs = getCodec(ctx);
            const decodedValues = values.map(({ key, value }) => ({
              keyArgs: codecs.keys.dec(key),
              value: codecs.value.dec(value)
            }));
            if (decodedValues.some(
              ({ value }) => !valuesAreCompatible(descriptors, ctx, value)
            ))
              throw incompatibleError();
            return decodedValues;
          }
        )
      ),
      chainHead.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  const getKey = (...args) => {
    const token = args.at(-1);
    if (token instanceof CompatibilityToken || token instanceof RuntimeToken) {
      const actualArgs = args.slice(0, -1);
      const ctx = getCompatibilityApi(token).runtime();
      if (!argsAreCompatible(token, ctx, actualArgs)) throw incompatibleError();
      return getCodec(ctx).keys.enc(...actualArgs);
    }
    return descriptorsPromise.then((x) => getKey(...args, x));
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getKey,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

export { createStorageEntry };
//# sourceMappingURL=storage.mjs.map
