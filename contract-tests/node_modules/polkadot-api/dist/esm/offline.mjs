import { getLookupFn, getDynamicBuilder } from '@polkadot-api/metadata-builders';
import { unifyMetadata, metadata, Binary, Enum } from '@polkadot-api/substrate-bindings';
import { fromHex, mergeUint8, toHex } from '@polkadot-api/utils';
import { getSignExtensionsCreator } from './tx/signed-extensions/sign-extensions.mjs';

const createOfflineTxEntry = (pallet, name, metadataRaw, dynamicBuilder, signExtensionCreator) => {
  let codecs;
  try {
    codecs = dynamicBuilder.buildCall(pallet, name);
  } catch {
    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
  }
  const { location, codec } = codecs;
  const locationBytes = new Uint8Array(location);
  return (arg) => {
    const encodedData = Binary.fromBytes(
      mergeUint8([locationBytes, codec.enc(arg)])
    );
    return {
      encodedData,
      decodedCall: Enum(pallet, Enum(name, arg)),
      sign: async (from, extensions) => toHex(
        await from.signTx(
          encodedData.asBytes(),
          signExtensionCreator(extensions),
          metadataRaw,
          extensions.mortality.mortal ? extensions.mortality.startAtBlock.height : 0
        )
      )
    };
  };
};
const getOfflineApi = async ({ genesis: genesisHex, getMetadata }) => {
  if (!genesisHex) throw new Error("Missing genesis hash");
  const genesis = fromHex(genesisHex);
  const metadataRaw = await getMetadata();
  const metadata$1 = unifyMetadata(metadata.dec(metadataRaw));
  const lookupFn = getLookupFn(metadata$1);
  const dynamicBuilder = getDynamicBuilder(lookupFn);
  const signExtensionCreator = getSignExtensionsCreator(
    genesis,
    lookupFn,
    dynamicBuilder
  );
  const getPallet = (name) => metadata$1.pallets.find((p) => p.name === name);
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const constants = createProxyPath((pallet, name) => {
    const constant = getPallet(pallet)?.constants.find((c) => c.name === name);
    if (!constant)
      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`);
    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value);
  });
  const tx = createProxyPath(
    (pallet, name) => createOfflineTxEntry(
      pallet,
      name,
      metadataRaw,
      dynamicBuilder,
      signExtensionCreator
    )
  );
  return { constants, tx };
};

export { getOfflineApi };
//# sourceMappingURL=offline.mjs.map
