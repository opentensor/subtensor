(function(_e,xe){typeof exports=="object"&&typeof module<"u"?xe(exports):typeof define=="function"&&define.amd?define(["exports"],xe):(_e=typeof globalThis<"u"?globalThis:_e||self,xe(_e.papiInk={}))})(this,(function(_e){"use strict";const xe=(e,t)=>e.type==="array"&&e.len===t&&e.value.type==="primitive"&&e.value.value==="u8",pe={type:"void"},yr=(e,t=()=>null)=>{const n=new Map,r=new Set,s=a=>f=>{let h=n.get(f);if(h)return h;if(r.has(f)){const p={id:f};return n.set(f,p),p}r.add(f);const u=a(f);return h=n.get(f),h?Object.assign(h,u):(h={id:f,...u},n.set(f,h)),r.delete(f),h};let o=!0,c=!0;const i=s(a=>{const f=t(e[a]);if(f)return f;const{def:h,path:u,params:p}=e[a];if(h.tag==="composite"){if(h.value.length===0)return pe;if(h.value.length===1){const y=i(h.value[0].type);return o&&u.at(-1)==="AccountId32"&&xe(y,32)?(o=!1,{type:"AccountId32"}):c&&u.at(-1)==="AccountId20"&&xe(y,20)?(c=!1,{type:"AccountId20"}):y}return d(h.value)}if(h.tag==="variant"){if(u.length===1&&u[0]==="Option"&&p.length===1&&p[0].name==="T"){const x=i(p[0].type);return x.type==="void"?{type:"primitive",value:"bool"}:{type:"option",value:x}}if(u.length===1&&u[0]==="Result"&&p.length===2&&p[0].name==="T"&&p[1].name==="E")return{type:"result",value:{ok:i(p[0].type),ko:i(p[1].type)}};if(h.value.length===0)return pe;const y={},b={};return h.value.forEach(x=>{const L=x.name;if(b[L]=x.docs,x.fields.length===0){y[L]={...pe,idx:x.index};return}if(x.fields.length===1&&!x.fields[0].name){y[L]={type:"lookupEntry",value:i(x.fields[0].type),idx:x.index};return}y[L]={...d(x.fields),idx:x.index}}),{type:"enum",value:y,innerDocs:b}}if(h.tag==="sequence")return{type:"sequence",value:i(h.value)};if(h.tag==="array"){const{len:y}=h.value,b=i(h.value.type);return!y||b.type==="void"?pe:y>1?{type:"array",value:b,len:h.value.len}:b}if(h.tag==="tuple")return h.value.length===0?pe:h.value.length>1?l(h.value.map(y=>i(y)),h.value.map(y=>e[y].docs)):i(h.value[0]);if(h.tag==="primitive")return{type:"primitive",value:h.value.tag};if(h.tag==="compact"){const y=i(h.value);return y.type==="void"?pe:{type:"compact",isBig:Number(y.value.slice(1))>32,size:y.value}}return{type:h.tag,isLSB:(e[h.value.bitOrderType].path.at(-1)??"LSB").toUpperCase().startsWith("LSB")}}),d=a=>{let f=!0;const h={},u={};return a.forEach((p,y)=>{f=f&&!!p.name;const b=p.name||y,x=i(p.type);x.type!=="void"&&(h[b]=x,u[b]=p.docs)}),f?{type:"struct",value:h,innerDocs:u}:l(Object.values(h),Object.values(u))},l=(a,f)=>{if(a.every(h=>h.id===a[0].id)&&f.every(h=>!h.length)){const[h]=a;return h.type==="void"?pe:{type:"array",value:a[0],len:a.length}}return{type:"tuple",value:a,innerDocs:f}};return i},gr=e=>yr(e);var vr=Object.defineProperty,br=(e,t,n)=>t in e?vr(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,At=(e,t,n)=>(br(e,typeof t!="symbol"?t+"":t,n),n),st={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function mr(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,r=(e.length-n)/2+t,s=new Uint8Array(r);t&&(s[0]=0|st[e[2]]);for(let o=0;o<r;){const c=n+o*2,i=st[e[c]],d=st[e[c+1]];s[t+o++]=i<<4|d}return s}var kt=class extends Uint8Array{constructor(e){super(e),At(this,"i",0),At(this,"v"),this.v=new DataView(e)}},W=e=>t=>e(t instanceof kt?t:new kt(t instanceof Uint8Array?t.buffer:typeof t=="string"?mr(t).buffer:t)),G=e=>{const t=e.length;let n=0;for(let s=0;s<t;s++)n+=e[s].length;const r=new Uint8Array(n);for(let s=0,o=0;s<t;s++){const c=e[s];r.set(c,o),o+=c.byteLength}return r};function je(e,t){const n=Object.keys(e),r=n.length,s={};for(let o=0;o<r;o++){const c=n[o];s[c]=t(e[c],c)}return s}var Ie=W,A=(e,t)=>{const n=[e,t];return n.enc=e,n.dec=t,n},ot=(e,t)=>n=>e(t(n)),ct=(e,t)=>n=>t(e(n)),M=([e,t],n,r)=>A(ot(e,n),ct(t,r));function wr(e,t){return W(n=>{const r=n.v[t](n.i,!0);return n.i+=e,r})}function Er(e,t){return n=>{const r=new Uint8Array(e);return new DataView(r.buffer)[t](0,n,!0),r}}function re(e,t,n){return A(Er(e,n),wr(e,t))}var k=re(1,"getUint8","setUint8"),ye=re(2,"getUint16","setUint16"),se=re(4,"getUint32","setUint32"),Pe=re(8,"getBigUint64","setBigUint64"),xr=re(1,"getInt8","setInt8"),Ir=re(2,"getInt16","setInt16"),Br=re(4,"getInt32","setInt32"),Ar=re(8,"getBigInt64","setBigInt64"),_t=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),t},Ot=e=>W(t=>{const{v:n,i:r}=t,s=n.getBigUint64(r,!0),o=n[e](r+8,!0);return t.i+=16,o<<64n|s}),kr=A(_t,Ot("getBigUint64")),_r=A(_t,Ot("getBigInt64")),Ut=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),n.setBigInt64(16,e>>128n,!0),n.setBigInt64(24,e>>192n,!0),t},Lt=e=>W(t=>{let n=t.v.getBigUint64(t.i,!0);return t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<64n,t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<128n,t.i+=8,n|=t.v[e](t.i,!0)<<192n,t.i+=8,n}),Or=A(Ut,Lt("getBigUint64")),Ur=A(Ut,Lt("getBigInt64")),Lr=M(k,e=>e?1:0,Boolean),Tr=[k[1],ye[1],se[1]],Sr=W(e=>{const t=e[e.i],n=t&3;if(n<3)return Tr[n](e)>>>2;const r=(t>>>2)+4;e.i++;let s=0n;const o=r/8|0;let c=0n;for(let d=0;d<o;d++)s=Pe[1](e)<<c|s,c+=64n;let i=r%8;return i>3&&(s=BigInt(se[1](e))<<c|s,c+=32n,i-=4),i>1&&(s=BigInt(ye[1](e))<<c|s,c+=16n,i-=2),i&&(s=BigInt(k[1](e))<<c|s),s}),Dr=1n<<56n,$r=1<<24,Cr=256,Hr=4294967295n,Vr=64,Mr=16384,Nr=1<<30,Rr=e=>{if(e<0)throw new Error(`Wrong compact input (${e})`);const t=Number(e)<<2;if(e<Vr)return k[0](t);if(e<Mr)return ye[0](t|1);if(e<Nr)return se[0](t|2);let n=[new Uint8Array(1)],r=BigInt(e);for(;r>=Dr;)n.push(Pe[0](r)),r>>=64n;r>=$r&&(n.push(se[0](Number(r&Hr))),r>>=32n);let s=Number(r);s>=Cr&&(n.push(ye[0](s)),s>>=16),s&&n.push(k[0](s));const o=G(n);return o[0]=o.length-5<<2|3,o},K=A(Rr,Sr),jr=new TextEncoder,Pr=e=>{const t=jr.encode(e);return G([K.enc(t.length),t])},Kr=new TextDecoder,qr=W(e=>{let t=K.dec(e);const n=new DataView(e.buffer,e.i,t);return e.i+=t,Kr.decode(n)}),I=A(Pr,qr),Fr=()=>{},Wr=new Uint8Array(0),w=A(()=>Wr,Fr),Tt=e=>e===void 0?t=>G([K.enc(t.length),t]):t=>t.length===e?t:t.slice(0,e),St=e=>W(t=>{const n=e===void 0?K.dec(t):e!==1/0?e:t.byteLength-t.i,r=new Uint8Array(t.buffer.slice(t.i,t.i+n));return t.i+=n,r}),T=e=>A(Tt(e),St(e));T.enc=Tt,T.dec=St;var Dt=(e,t)=>{const n=Object.keys(e),r=new Map(t?.map((o,c)=>[n[c],o])??n.map((o,c)=>[o,c])),s=o=>r.get(o);return({tag:o,value:c})=>G([k.enc(s(o)),e[o](c)])},$t=(e,t)=>{const n=Object.keys(e),r=new Map(t?.map((s,o)=>[s,n[o]])??n.map((s,o)=>[o,s]));return W(s=>{const o=k.dec(s),c=r.get(o),i=e[c];return{tag:c,value:i(s)}})},N=(e,...t)=>A(Dt(je(e,([n])=>n),...t),$t(je(e,([,n])=>n),...t));N.enc=Dt,N.dec=$t;var Ct=e=>W(t=>k[1](t)>0?e(t):void 0),Ht=e=>t=>{const n=new Uint8Array(1);return t===void 0?n:(n[0]=1,G([n,e(t)]))},R=e=>A(Ht(e[0]),Ct(e[1]));R.enc=Ht,R.dec=Ct;var Vt=(e,t)=>W(n=>{const r=k[1](n)===0,o=(r?e:t)(n);return{success:r,value:o}}),Mt=(e,t)=>({success:n,value:r})=>G([k[0](n?0:1),(n?e:t)(r)]),Oe=(e,t)=>A(Mt(e[0],t[0]),Vt(e[1],t[1]));Oe.dec=Vt,Oe.enc=Mt;var Nt=(...e)=>W(t=>e.map(n=>n(t))),Rt=(...e)=>t=>G(e.map((n,r)=>n(t[r]))),X=(...e)=>A(Rt(...e.map(([t])=>t)),Nt(...e.map(([,t])=>t)));X.enc=Rt,X.dec=Nt;var jt=e=>{const t=Object.keys(e);return ot(X.enc(...Object.values(e)),n=>t.map(r=>n[r]))},Pt=e=>{const t=Object.keys(e);return ct(X.dec(...Object.values(e)),n=>Object.fromEntries(n.map((r,s)=>[t[s],r])))},m=e=>A(jt(je(e,t=>t[0])),Pt(je(e,t=>t[1])));m.enc=jt,m.dec=Pt;var Kt=(e,t)=>t>=0?n=>G(n.map(e)):n=>G([K.enc(n.length),G(n.map(e))]),qt=(e,t)=>W(n=>{const r=t>=0?t:K.dec(n),s=new Array(r);for(let o=0;o<r;o++)s[o]=e(n);return s}),E=(e,t)=>A(Kt(e[0],t),qt(e[1],t));E.enc=Kt,E.dec=qt;/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Xr(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ft(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function it(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function Wt(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function at(e){if(!Array.isArray(e))throw new Error("array expected")}function Xt(e,t){if(!Ft(!0,t))throw new Error(`${e}: array of strings expected`)}function zr(e,t){if(!Ft(!1,t))throw new Error(`${e}: array of numbers expected`)}function Yr(...e){const t=o=>o,n=(o,c)=>i=>o(c(i)),r=e.map(o=>o.encode).reduceRight(n,t),s=e.map(o=>o.decode).reduce(n,t);return{encode:r,decode:s}}function Gr(e){const t=typeof e=="string"?e.split(""):e,n=t.length;Xt("alphabet",t);const r=new Map(t.map((s,o)=>[s,o]));return{encode:s=>(at(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);return t[o]})),decode:s=>(at(s),s.map(o=>{it("alphabet.decode",o);const c=r.get(o);if(c===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);return c}))}}function Jr(e=""){return it("join",e),{encode:t=>(Xt("join.decode",t),t.join(e)),decode:t=>(it("join.decode",t),t.split(e))}}function zt(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(at(e),!e.length)return[];let r=0;const s=[],o=Array.from(e,i=>{if(Wt(i),i<0||i>=t)throw new Error(`invalid integer: ${i}`);return i}),c=o.length;for(;;){let i=0,d=!0;for(let l=r;l<c;l++){const a=o[l],f=t*i,h=f+a;if(!Number.isSafeInteger(h)||f/t!==i||h-a!==f)throw new Error("convertRadix: carry overflow");const u=h/n;i=h%n;const p=Math.floor(u);if(o[l]=p,!Number.isSafeInteger(p)||p*n+i!==h)throw new Error("convertRadix: carry overflow");if(d)p?d=!1:r=l;else continue}if(s.push(i),d)break}for(let i=0;i<e.length-1&&e[i]===0;i++)s.push(0);return s.reverse()}function Qr(e){Wt(e);const t=2**8;return{encode:n=>{if(!Xr(n))throw new Error("radix.encode input should be Uint8Array");return zt(Array.from(n),t,e)},decode:n=>(zr("radix.decode",n),Uint8Array.from(zt(n,e,t)))}}const Yt=(e=>Yr(Qr(58),Gr(e),Jr("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Zr(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Be(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function z(e,t,n=""){const r=Zr(e),s=e?.length,o=t!==void 0;if(!r||o&&s!==t){const c=n&&`"${n}" `,i=o?` of length ${t}`:"",d=r?`length=${s}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+d)}return e}function Ue(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function lt(e,t){z(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function es(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}function ge(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function oe(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function Ke(e,t){return e<<32-t|e>>>t}const Gt=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Jt(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}const Z=Gt?e=>e:e=>Jt(e);function ts(e){for(let t=0;t<e.length;t++)e[t]=Jt(e[t]);return e}const H=Gt?e=>e:ts;function ut(e,t={}){const n=(s,o)=>e(o).update(s).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=s=>e(s),Object.assign(n,t),Object.freeze(n)}const ns=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]);function ce(e,t,n,r,s){return e=e+t+s|0,r=Ke(r^e,16),n=n+r|0,t=Ke(t^n,12),{a:e,b:t,c:n,d:r}}function ie(e,t,n,r,s){return e=e+t+s|0,r=Ke(r^e,8),n=n+r|0,t=Ke(t^n,7),{a:e,b:t,c:n,d:r}}const rs=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),qe=BigInt(2**32-1),Qt=BigInt(32);function Fe(e,t=!1){return t?{h:Number(e&qe),l:Number(e>>Qt&qe)}:{h:Number(e>>Qt&qe)|0,l:Number(e&qe)|0}}function ss(e,t=!1){const n=e.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let o=0;o<n;o++){const{h:c,l:i}=Fe(e[o],t);[r[o],s[o]]=[c,i]}return[r,s]}const Zt=(e,t,n)=>e>>>n|t<<32-n,en=(e,t,n)=>e<<32-n|t>>>n,os=(e,t,n)=>e<<64-n|t>>>n-32,cs=(e,t,n)=>e>>>n-32|t<<64-n,is=(e,t)=>t,as=(e,t)=>e,ls=(e,t,n)=>e<<n|t>>>32-n,us=(e,t,n)=>t<<n|e>>>32-n,ds=(e,t,n)=>t<<n-32|e>>>64-n,hs=(e,t,n)=>e<<n-32|t>>>64-n;function tn(e,t,n,r){const s=(t>>>0)+(r>>>0);return{h:e+n+(s/2**32|0)|0,l:s|0}}const nn=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),rn=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,U=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),g=new Uint32Array(32);function ae(e,t,n,r,s,o){const c=s[o],i=s[o+1];let d=g[2*e],l=g[2*e+1],a=g[2*t],f=g[2*t+1],h=g[2*n],u=g[2*n+1],p=g[2*r],y=g[2*r+1],b=nn(d,a,c);l=rn(b,l,f,i),d=b|0,{Dh:y,Dl:p}={Dh:y^l,Dl:p^d},{Dh:y,Dl:p}={Dh:is(y,p),Dl:as(y)},{h:u,l:h}=tn(u,h,y,p),{Bh:f,Bl:a}={Bh:f^u,Bl:a^h},{Bh:f,Bl:a}={Bh:Zt(f,a,24),Bl:en(f,a,24)},g[2*e]=d,g[2*e+1]=l,g[2*t]=a,g[2*t+1]=f,g[2*n]=h,g[2*n+1]=u,g[2*r]=p,g[2*r+1]=y}function le(e,t,n,r,s,o){const c=s[o],i=s[o+1];let d=g[2*e],l=g[2*e+1],a=g[2*t],f=g[2*t+1],h=g[2*n],u=g[2*n+1],p=g[2*r],y=g[2*r+1],b=nn(d,a,c);l=rn(b,l,f,i),d=b|0,{Dh:y,Dl:p}={Dh:y^l,Dl:p^d},{Dh:y,Dl:p}={Dh:Zt(y,p,16),Dl:en(y,p,16)},{h:u,l:h}=tn(u,h,y,p),{Bh:f,Bl:a}={Bh:f^u,Bl:a^h},{Bh:f,Bl:a}={Bh:os(f,a,63),Bl:cs(f,a,63)},g[2*e]=d,g[2*e+1]=l,g[2*t]=a,g[2*t+1]=f,g[2*n]=h,g[2*n+1]=u,g[2*r]=p,g[2*r+1]=y}function fs(e,t={},n,r,s){if(Be(n),e<0||e>n)throw new Error("outputLen bigger than keyLen");const{key:o,salt:c,personalization:i}=t;if(o!==void 0&&(o.length<1||o.length>n))throw new Error('"key" expected to be undefined or of length=1..'+n);c!==void 0&&z(c,r,"salt"),i!==void 0&&z(i,s,"personalization")}class sn{buffer;buffer32;finished=!1;destroyed=!1;length=0;pos=0;blockLen;outputLen;constructor(t,n){Be(t),Be(n),this.blockLen=t,this.outputLen=n,this.buffer=new Uint8Array(t),this.buffer32=ge(this.buffer)}update(t){Ue(this),z(t);const{blockLen:n,buffer:r,buffer32:s}=this,o=t.length,c=t.byteOffset,i=t.buffer;for(let d=0;d<o;){this.pos===n&&(H(s),this.compress(s,0,!1),H(s),this.pos=0);const l=Math.min(n-this.pos,o-d),a=c+d;if(l===n&&!(a%4)&&d+l<o){const f=new Uint32Array(i,a,Math.floor((o-d)/4));H(f);for(let h=0;d+n<o;h+=s.length,d+=n)this.length+=n,this.compress(f,h,!1);H(f);continue}r.set(t.subarray(d,d+l),this.pos),this.pos+=l,this.length+=l,d+=l}return this}digestInto(t){Ue(this),lt(t,this);const{pos:n,buffer32:r}=this;this.finished=!0,oe(this.buffer.subarray(n)),H(r),this.compress(r,0,!0),H(r);const s=ge(t);this.get().forEach((o,c)=>s[c]=Z(o))}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){const{buffer:n,length:r,finished:s,destroyed:o,outputLen:c,pos:i}=this;return t||=new this.constructor({dkLen:c}),t.set(...this.get()),t.buffer.set(n),t.destroyed=o,t.finished=s,t.length=r,t.pos=i,t.outputLen=c,t}clone(){return this._cloneInto()}}class ps extends sn{v0l=U[0]|0;v0h=U[1]|0;v1l=U[2]|0;v1h=U[3]|0;v2l=U[4]|0;v2h=U[5]|0;v3l=U[6]|0;v3h=U[7]|0;v4l=U[8]|0;v4h=U[9]|0;v5l=U[10]|0;v5h=U[11]|0;v6l=U[12]|0;v6h=U[13]|0;v7l=U[14]|0;v7h=U[15]|0;constructor(t={}){const n=t.dkLen===void 0?64:t.dkLen;super(128,n),fs(n,t,64,16,16);let{key:r,personalization:s,salt:o}=t,c=0;if(r!==void 0&&(z(r,void 0,"key"),c=r.length),this.v0l^=this.outputLen|c<<8|65536|1<<24,o!==void 0){z(o,void 0,"salt");const i=ge(o);this.v4l^=Z(i[0]),this.v4h^=Z(i[1]),this.v5l^=Z(i[2]),this.v5h^=Z(i[3])}if(s!==void 0){z(s,void 0,"personalization");const i=ge(s);this.v6l^=Z(i[0]),this.v6h^=Z(i[1]),this.v7l^=Z(i[2]),this.v7h^=Z(i[3])}if(r!==void 0){const i=new Uint8Array(this.blockLen);i.set(r),this.update(i)}}get(){let{v0l:t,v0h:n,v1l:r,v1h:s,v2l:o,v2h:c,v3l:i,v3h:d,v4l:l,v4h:a,v5l:f,v5h:h,v6l:u,v6h:p,v7l:y,v7h:b}=this;return[t,n,r,s,o,c,i,d,l,a,f,h,u,p,y,b]}set(t,n,r,s,o,c,i,d,l,a,f,h,u,p,y,b){this.v0l=t|0,this.v0h=n|0,this.v1l=r|0,this.v1h=s|0,this.v2l=o|0,this.v2h=c|0,this.v3l=i|0,this.v3h=d|0,this.v4l=l|0,this.v4h=a|0,this.v5l=f|0,this.v5h=h|0,this.v6l=u|0,this.v6h=p|0,this.v7l=y|0,this.v7h=b|0}compress(t,n,r){this.get().forEach((d,l)=>g[l]=d),g.set(U,16);let{h:s,l:o}=Fe(BigInt(this.length));g[24]=U[8]^o,g[25]=U[9]^s,r&&(g[28]=~g[28],g[29]=~g[29]);let c=0;const i=ns;for(let d=0;d<12;d++)ae(0,4,8,12,t,n+2*i[c++]),le(0,4,8,12,t,n+2*i[c++]),ae(1,5,9,13,t,n+2*i[c++]),le(1,5,9,13,t,n+2*i[c++]),ae(2,6,10,14,t,n+2*i[c++]),le(2,6,10,14,t,n+2*i[c++]),ae(3,7,11,15,t,n+2*i[c++]),le(3,7,11,15,t,n+2*i[c++]),ae(0,5,10,15,t,n+2*i[c++]),le(0,5,10,15,t,n+2*i[c++]),ae(1,6,11,12,t,n+2*i[c++]),le(1,6,11,12,t,n+2*i[c++]),ae(2,7,8,13,t,n+2*i[c++]),le(2,7,8,13,t,n+2*i[c++]),ae(3,4,9,14,t,n+2*i[c++]),le(3,4,9,14,t,n+2*i[c++]);this.v0l^=g[0]^g[16],this.v0h^=g[1]^g[17],this.v1l^=g[2]^g[18],this.v1h^=g[3]^g[19],this.v2l^=g[4]^g[20],this.v2h^=g[5]^g[21],this.v3l^=g[6]^g[22],this.v3h^=g[7]^g[23],this.v4l^=g[8]^g[24],this.v4h^=g[9]^g[25],this.v5l^=g[10]^g[26],this.v5h^=g[11]^g[27],this.v6l^=g[12]^g[28],this.v6h^=g[13]^g[29],this.v7l^=g[14]^g[30],this.v7h^=g[15]^g[31],oe(g)}destroy(){this.destroyed=!0,oe(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const We=ut(e=>new ps(e));function on(e,t,n,r,s,o,c,i,d,l,a,f,h,u,p,y,b,x,L,P){let O=0;for(let Ee=0;Ee<r;Ee++)({a:s,b:d,c:h,d:b}=ce(s,d,h,b,n[t+e[O++]])),{a:s,b:d,c:h,d:b}=ie(s,d,h,b,n[t+e[O++]]),{a:o,b:l,c:u,d:x}=ce(o,l,u,x,n[t+e[O++]]),{a:o,b:l,c:u,d:x}=ie(o,l,u,x,n[t+e[O++]]),{a:c,b:a,c:p,d:L}=ce(c,a,p,L,n[t+e[O++]]),{a:c,b:a,c:p,d:L}=ie(c,a,p,L,n[t+e[O++]]),{a:i,b:f,c:y,d:P}=ce(i,f,y,P,n[t+e[O++]]),{a:i,b:f,c:y,d:P}=ie(i,f,y,P,n[t+e[O++]]),{a:s,b:l,c:p,d:P}=ce(s,l,p,P,n[t+e[O++]]),{a:s,b:l,c:p,d:P}=ie(s,l,p,P,n[t+e[O++]]),{a:o,b:a,c:y,d:b}=ce(o,a,y,b,n[t+e[O++]]),{a:o,b:a,c:y,d:b}=ie(o,a,y,b,n[t+e[O++]]),{a:c,b:f,c:h,d:x}=ce(c,f,h,x,n[t+e[O++]]),{a:c,b:f,c:h,d:x}=ie(c,f,h,x,n[t+e[O++]]),{a:i,b:d,c:u,d:L}=ce(i,d,u,L,n[t+e[O++]]),{a:i,b:d,c:u,d:L}=ie(i,d,u,L,n[t+e[O++]]);return{v0:s,v1:o,v2:c,v3:i,v4:d,v5:l,v6:a,v7:f,v8:h,v9:u,v10:p,v11:y,v12:b,v13:x,v14:L,v15:P}}const cn=new TextEncoder().encode("SS58PRE"),dt=2,an=e=>{try{const t=Yt.decode(e),n=t.subarray(0,t[0]&64?2:1),r=t.subarray(n.length,t.length-dt),s=t.subarray(n.length+r.length),o=We(Uint8Array.of(...cn,...n,...r),{dkLen:64}).subarray(0,dt);return s[0]===o[0]&&s[1]===o[1]?{isValid:!0,ss58Format:ys(n),publicKey:r.slice()}:{isValid:!1}}catch{return{isValid:!1}}},ys=e=>{const t=new DataView(e.buffer,e.byteOffset,e.byteLength);return t.byteLength===1?t.getUint8(0):t.getUint16(0)},ln=e=>{const t=e<64?Uint8Array.of(e):Uint8Array.of((e&252)>>2|64,e>>8|(e&3)<<6);return n=>{const r=We(Uint8Array.of(...cn,...t,...n),{dkLen:64}).subarray(0,dt);return Yt.encode(Uint8Array.of(...t,...n,...r))}};function gs(e,t){return n=>{const r=an(n);if(!r.isValid)throw new Error("Invalid checksum");const{publicKey:s}=r;if(s.length!==e)throw new Error("Invalid public key length");return s}}const ht=(e=42,t=32)=>M(T(t),gs(t),ln(e)),un="0123456789abcdef";function Y(e){const t=new Array(e.length+1);t[0]="0x";for(let n=0;n<e.length;){const r=e[n++];t[n]=un[r>>4]+un[r&15]}return t.join("")}const ft={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function Le(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,r=(e.length-n)/2+t,s=new Uint8Array(r);t&&(s[0]=0|ft[e[2]]);for(let o=0;o<r;){const c=n+o*2,i=ft[e[c]],d=ft[e[c+1]];s[t+o++]=i<<4|d}return s}function dn(e,t){return Object.fromEntries(Object.entries(e).map(([n,r])=>[n,t(r,n)]))}const ue=(...e)=>{const t=Array.isArray(e[0])?e[0]:e,n=t.reduce((s,o)=>s+o.byteLength,0),r=new Uint8Array(n);for(let s=0,o=0;s<t.length;s++){const c=t[s];r.set(c,o),o+=c.byteLength}return r};var vs=Object.defineProperty,hn=e=>{throw TypeError(e)},bs=(e,t,n)=>t in e?vs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Te=(e,t,n)=>bs(e,typeof t!="symbol"?t+"":t,n),fn=(e,t,n)=>t.has(e)||hn("Cannot "+n),ee=(e,t,n)=>(fn(e,t,"read from private field"),n?n.call(e):t.get(e)),Se=(e,t,n)=>t.has(e)?hn("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),ve=(e,t,n,r)=>(fn(e,t,"write to private field"),t.set(e,n),n),te,De,Xe,ze,Ye;const ms=new TextEncoder,ws=new TextDecoder,Es=X(K,T(1/0))[1];class J{constructor(t,n=!1){if(Se(this,te),Se(this,De,null),Se(this,Xe,null),Se(this,ze,null),Se(this,Ye,null),Te(this,"asText",()=>ee(this,Ye)??ve(this,Ye,ws.decode(ee(this,te)))),Te(this,"asHex",()=>ee(this,Xe)??ve(this,Xe,Y(ee(this,te)))),Te(this,"asOpaqueHex",()=>ee(this,ze)??ve(this,ze,Y(this.asBytes()))),Te(this,"asBytes",()=>ee(this,te)),Te(this,"asOpaqueBytes",()=>ee(this,De)??ve(this,De,ue([ee(this,te),K[0](ee(this,te).length)]))),n){try{const[r,s]=Es(t);if(r===s.length){ve(this,te,s),ve(this,De,t);return}}catch{}throw new Error("Invalid opaque bytes")}else ve(this,te,t)}static fromText(t){return new this(ms.encode(t))}static fromHex(t){return new this(Le(t))}static fromOpaqueHex(t){return new this(Le(t),!0)}static fromBytes(t){return new this(t)}static fromOpaqueBytes(t){return new this(t,!0)}}te=new WeakMap,De=new WeakMap,Xe=new WeakMap,ze=new WeakMap,Ye=new WeakMap;const[xs]=ht();class pn extends J{constructor(t){super(t)}static fromArray(t){return new this(new Uint8Array(t))}static fromAccountId32(t){return new this(xs(t))}}const yn=e=>{const t=T.enc(e);return n=>t(n.asBytes())},gn=e=>{const t=T.dec(e),n=e==null?J:pn;return r=>n.fromBytes(t(r))},$e=e=>A(yn(e),gn(e));$e.enc=yn,$e.dec=gn;const v=M(K,e=>e,Number),vn=M(K,e=>e,BigInt),Is=Ie(e=>{const t=v.dec(e),n=Math.ceil(t/8);return{bytes:T(n).dec(e),bitsLen:t}}),Bs=A(e=>{if(e.bitsLen>e.bytes.length*8)throw new Error(`Not enough bytes. (bitsLen:${e.bitsLen}, bytesLen:${e.bytes.length})`);const t=v.enc(e.bitsLen),n=new Uint8Array(e.bytes.length+t.length);return n.set(t,0),n.set(e.bytes,t.length),n},Is),As=M(k,e=>e.charCodeAt(0),String.fromCharCode),bn=e=>{const t=T.enc(e);return n=>t(Le(n))},mn=e=>{const t=T.dec(e);return n=>Y(t(n))},V=e=>A(bn(e),mn(e));V.enc=bn,V.dec=mn;const wn=new TextEncoder,ks=new TextDecoder,_s=e=>M(T(e),t=>wn.encode(t),t=>ks.decode(t)),En=e=>{let t=n=>{const r=e();return t=r,r(n)};return n=>t(n)},xn=e=>{let t=n=>{const r=e(),s=r;return t=r,s(n)};return n=>t(n)},In=e=>A(En(()=>e().enc),xn(()=>e().dec)),pt=Object.assign((e,t)=>({type:e,value:t}),{is(e,t){return e.type===t},as(e,t){if(t!==e.type)throw new Error(`Enum.as(enum, ${t}) used with actual type ${e.type}`);return e}}),Os=new Proxy({},{get(e,t){return n=>pt(t,n)}}),_=(e,t)=>{const n=e;return n.inner=t,n},Bn=(...e)=>{const t=N.enc(...e);return _(n=>t({tag:n.type,value:n.value}),e[0])},An=(...e)=>{const t=N.dec(...e);return _(n=>{const{tag:r,value:s}=t(n);return pt(r,s)},e[0])},be=(e,...t)=>_(A(Bn(dn(e,([n])=>n),...t),An(dn(e,([,n])=>n),...t)),e);be.enc=Bn,be.dec=An;const Ge=(e,...t)=>_(N(e,...t),e);Ge.enc=(e,...t)=>_(N.enc(e,...t),e),Ge.dec=(e,...t)=>_(N.dec(e,...t),e);const Q={CHUNK_START:1,CHUNK_END:2,PARENT:4,ROOT:8,KEYED_HASH:16,DERIVE_KEY_CONTEXT:32,DERIVE_KEY_MATERIAL:64},ne=rs.slice(),kn=(()=>{const e=Array.from({length:16},(r,s)=>s),t=r=>[2,6,3,10,7,0,4,13,1,11,12,5,9,14,15,8].map(s=>r[s]),n=[];for(let r=0,s=e;r<7;r++,s=t(s))n.push(...s);return Uint8Array.from(n)})();class yt extends sn{chunkPos=0;chunksDone=0;flags=0;IV;state;stack=[];posOut=0;bufferOut32=new Uint32Array(16);bufferOut;chunkOut=0;enableXOF=!0;constructor(t={},n=0){super(64,t.dkLen===void 0?32:t.dkLen);const{key:r,context:s}=t,o=s!==void 0;if(r!==void 0){if(o)throw new Error('Only "key" or "context" can be specified at same time');z(r,32,"key");const c=r.slice();this.IV=ge(c),H(this.IV),this.flags=n|Q.KEYED_HASH}else if(o){z(s,void 0,"context");const c=s,i=new yt({dkLen:32},Q.DERIVE_KEY_CONTEXT).update(c).digest();this.IV=ge(i),H(this.IV),this.flags=n|Q.DERIVE_KEY_MATERIAL}else this.IV=ne.slice(),this.flags=n;this.state=this.IV.slice(),this.bufferOut=es(this.bufferOut32)}get(){return[]}set(){}b2Compress(t,n,r,s=0){const{state:o,pos:c}=this,{h:i,l:d}=Fe(BigInt(t),!0),{v0:l,v1:a,v2:f,v3:h,v4:u,v5:p,v6:y,v7:b,v8:x,v9:L,v10:P,v11:O,v12:Ee,v13:nt,v14:rt,v15:Yo}=on(kn,s,r,7,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],ne[0],ne[1],ne[2],ne[3],i,d,c,n);o[0]=l^x,o[1]=a^L,o[2]=f^P,o[3]=h^O,o[4]=u^Ee,o[5]=p^nt,o[6]=y^rt,o[7]=b^Yo}compress(t,n=0,r=!1){let s=this.flags;if(this.chunkPos||(s|=Q.CHUNK_START),(this.chunkPos===15||r)&&(s|=Q.CHUNK_END),r||(this.pos=this.blockLen),this.b2Compress(this.chunksDone,s,t,n),this.chunkPos+=1,this.chunkPos===16||r){let o=this.state;this.state=this.IV.slice();for(let c,i=this.chunksDone+1;(r||!(i&1))&&(c=this.stack.pop());i>>=1)this.buffer32.set(c,0),this.buffer32.set(o,8),this.pos=this.blockLen,this.b2Compress(0,this.flags|Q.PARENT,this.buffer32,0),o=this.state,this.state=this.IV.slice();this.chunksDone++,this.chunkPos=0,this.stack.push(o)}this.pos=0}_cloneInto(t){t=super._cloneInto(t);const{IV:n,flags:r,state:s,chunkPos:o,posOut:c,chunkOut:i,stack:d,chunksDone:l}=this;return t.state.set(s.slice()),t.stack=d.map(a=>Uint32Array.from(a)),t.IV.set(n),t.flags=r,t.chunkPos=o,t.chunksDone=l,t.posOut=c,t.chunkOut=i,t.enableXOF=this.enableXOF,t.bufferOut32.set(this.bufferOut32),t}destroy(){this.destroyed=!0,oe(this.state,this.buffer32,this.IV,this.bufferOut32),oe(...this.stack)}b2CompressOut(){const{state:t,pos:n,flags:r,buffer32:s,bufferOut32:o}=this,{h:c,l:i}=Fe(BigInt(this.chunkOut++));H(s);const{v0:d,v1:l,v2:a,v3:f,v4:h,v5:u,v6:p,v7:y,v8:b,v9:x,v10:L,v11:P,v12:O,v13:Ee,v14:nt,v15:rt}=on(kn,0,s,7,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],ne[0],ne[1],ne[2],ne[3],i,c,n,r);o[0]=d^b,o[1]=l^x,o[2]=a^L,o[3]=f^P,o[4]=h^O,o[5]=u^Ee,o[6]=p^nt,o[7]=y^rt,o[8]=t[0]^b,o[9]=t[1]^x,o[10]=t[2]^L,o[11]=t[3]^P,o[12]=t[4]^O,o[13]=t[5]^Ee,o[14]=t[6]^nt,o[15]=t[7]^rt,H(s),H(o),this.posOut=0}finish(){if(this.finished)return;this.finished=!0,oe(this.buffer.subarray(this.pos));let t=this.flags|Q.ROOT;this.stack.length?(t|=Q.PARENT,H(this.buffer32),this.compress(this.buffer32,0,!0),H(this.buffer32),this.chunksDone=0,this.pos=this.blockLen):t|=(this.chunkPos?0:Q.CHUNK_START)|Q.CHUNK_END,this.flags=t,this.b2CompressOut()}writeInto(t){Ue(this,!1),z(t),this.finish();const{blockLen:n,bufferOut:r}=this;for(let s=0,o=t.length;s<o;){this.posOut>=n&&this.b2CompressOut();const c=Math.min(n-this.posOut,o-s);t.set(r.subarray(this.posOut,this.posOut+c),s),this.posOut+=c,s+=c}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible after digest call");return this.writeInto(t)}xof(t){return Be(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(lt(t,this),this.finished)throw new Error("digest() was already called");return this.enableXOF=!1,this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}}const Us=ut((e={})=>new yt(e)),Ls=BigInt(0),Ce=BigInt(1),Ts=BigInt(2),Ss=BigInt(7),Ds=BigInt(256),$s=BigInt(113),_n=[],On=[],Un=[];for(let e=0,t=Ce,n=1,r=0;e<24;e++){[n,r]=[r,(2*n+3*r)%5],_n.push(2*(5*r+n)),On.push((e+1)*(e+2)/2%64);let s=Ls;for(let o=0;o<7;o++)t=(t<<Ce^(t>>Ss)*$s)%Ds,t&Ts&&(s^=Ce<<(Ce<<BigInt(o))-Ce);Un.push(s)}const Ln=ss(Un,!0),Cs=Ln[0],Hs=Ln[1],Tn=(e,t,n)=>n>32?ds(e,t,n):ls(e,t,n),Sn=(e,t,n)=>n>32?hs(e,t,n):us(e,t,n);function Vs(e,t=24){const n=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let c=0;c<10;c++)n[c]=e[c]^e[c+10]^e[c+20]^e[c+30]^e[c+40];for(let c=0;c<10;c+=2){const i=(c+8)%10,d=(c+2)%10,l=n[d],a=n[d+1],f=Tn(l,a,1)^n[i],h=Sn(l,a,1)^n[i+1];for(let u=0;u<50;u+=10)e[c+u]^=f,e[c+u+1]^=h}let s=e[2],o=e[3];for(let c=0;c<24;c++){const i=On[c],d=Tn(s,o,i),l=Sn(s,o,i),a=_n[c];s=e[a],o=e[a+1],e[a]=d,e[a+1]=l}for(let c=0;c<50;c+=10){for(let i=0;i<10;i++)n[i]=e[c+i];for(let i=0;i<10;i++)e[c+i]^=~n[(i+2)%10]&n[(i+4)%10]}e[0]^=Cs[r],e[1]^=Hs[r]}oe(n)}class gt{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,r,s=!1,o=24){if(this.blockLen=t,this.suffix=n,this.outputLen=r,this.enableXOF=s,this.rounds=o,Be(r,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=ge(this.state)}clone(){return this._cloneInto()}keccak(){H(this.state32),Vs(this.state32,this.rounds),H(this.state32),this.posOut=0,this.pos=0}update(t){Ue(this),z(t);const{blockLen:n,state:r}=this,s=t.length;for(let o=0;o<s;){const c=Math.min(n-this.pos,s-o);for(let i=0;i<c;i++)r[this.pos++]^=t[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:r,blockLen:s}=this;t[r]^=n,(n&128)!==0&&r===s-1&&this.keccak(),t[s-1]^=128,this.keccak()}writeInto(t){Ue(this,!1),z(t),this.finish();const n=this.state,{blockLen:r}=this;for(let s=0,o=t.length;s<o;){this.posOut>=r&&this.keccak();const c=Math.min(r-this.posOut,o-s);t.set(n.subarray(this.posOut,this.posOut+c),s),this.posOut+=c,s+=c}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Be(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(lt(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,oe(this.state)}_cloneInto(t){const{blockLen:n,suffix:r,outputLen:s,rounds:o,enableXOF:c}=this;return t||=new gt(n,r,s,c,o),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=r,t.outputLen=s,t.enableXOF=c,t.destroyed=this.destroyed,t}}const Dn=((e,t,n,r={})=>ut(()=>new gt(t,e,n),r))(1,136,32),$n=e=>{const t=e.slice(2),n=Y(Dn(wn.encode(t))).slice(2),r=new Array(40);for(let s=0;s<40;s++){const o=parseInt(n[s],16),c=t[s];r[s]=o>7?c.toUpperCase():c}return`0x${r.join("")}`},Ms=T(20)[1],Cn=A(e=>{const t=Le(e);if(t.length!==20)throw new Error(`Invalid length found on EthAddress(${e})`);const n=Y(t);if(e===n||e===n.toUpperCase())return t;if($n(n)!==e)throw new Error(`Invalid checksum found on EthAddress(${e})`);return t},Ie(e=>$n(Y(Ms(e))))),$=e=>_(m(e),e);$.enc=e=>_(m.enc(e),e),$.dec=e=>_(m.dec(e),e);const He=(...e)=>_(X(...e),e);He.enc=(...e)=>_(X.enc(...e),e),He.dec=(...e)=>_(X.dec(...e),e);const de=(e,...t)=>_(E(e,...t),e);de.enc=(e,...t)=>_(E.enc(e,...t),e),de.dec=(e,...t)=>_(E.dec(e,...t),e);const Je=(e,t)=>_(Oe(e,t),{ok:e,ko:t});Je.enc=(e,t)=>_(Oe.enc(e,t),{ok:e,ko:t}),Je.dec=(e,t)=>_(Oe.dec(e,t),{ok:e,ko:t});const Ae=e=>_(R(e),e);Ae.enc=e=>_(R.enc(e),e),Ae.dec=e=>_(R.dec(e),e);const Hn=(e=!0)=>Ie(t=>{const n=v.dec(t),r=Math.ceil(n/8),s=T(r).dec(t),o=new Array(n);let c=0;return s.forEach(i=>{for(let d=0;d<8&&c<n;d++){const l=e?d:7-d;o[c++]=i>>l&1}}),o}),Vn=(e=!0)=>t=>{const n=v.enc(t.length),r=Math.ceil(t.length/8),s=new Uint8Array(r);for(let o=0;o<r;o++){let c=o*8,i=0;for(let d=0;d<8&&c<t.length;d++,c++)i|=t[c]<<(e?d:7-d);s[o]=i}return ue([n,s])},Qe=e=>A(Vn(e),Hn(e));Qe.enc=Vn,Qe.dec=Hn;const Mn=new TextEncoder,Nn=new TextDecoder,Ns=M(T(4),Mn.encode.bind(Mn),Nn.decode.bind(Nn)),vt=$({engine:Ns,payload:V()}),Rs=be({other:T(),consensus:vt,seal:vt,preRuntime:vt,runtimeUpdated:w},[0,4,5,6,8]),bt=V(32),js=$({parentHash:bt,number:v,stateRoot:bt,extrinsicRoot:bt,digests:de(Rs)}),q=E(I),Rn=R(I),Ps=N({bool:w,char:w,str:w,u8:w,u16:w,u32:w,u64:w,u128:w,u256:w,i8:w,i16:w,i32:w,i64:w,i128:w,i256:w}),jn=E(m({name:Rn,type:v,typeName:Rn,docs:q})),Ks=m({len:se,type:v}),qs=m({bitStoreType:v,bitOrderType:v}),Fs=E(m({name:I,fields:jn,index:k,docs:q})),Ws=N({composite:jn,variant:Fs,sequence:v,array:Ks,tuple:E(v),primitive:Ps,compact:v,bitSequence:qs}),Xs=m({name:I,type:R(v)}),zs=E(Xs),Ys=m({id:v,path:q,params:zs,def:Ws,docs:q}),Ve=E(Ys),ke=N({NotDeprecated:w,DeprecatedWithoutNote:w,Deprecated:m({note:I,since:R(I)})}),Gs=E(m({index:k,deprecation:N({DeprecatedWithoutNote:w,Deprecated:m({note:I,since:R(I)})},[1,2])})),mt={name:I,inputs:E(m({name:I,type:v})),output:v,docs:q},Js=m({name:I,methods:E(m(mt)),docs:q}),Qs=m({name:I,methods:E(m({...mt,deprecationInfo:ke})),docs:q,version:v,deprecationInfo:ke}),Zs=m({id:V(32),...mt,deprecationInfo:ke}),eo=N({Blake2128:w,Blake2256:w,Blake2128Concat:w,Twox128:w,Twox256:w,Twox64Concat:w,Identity:w}),to=E(eo),no=m({hashers:to,key:v,value:v}),Pn={name:I,modifier:k,type:N({plain:v,map:no}),fallback:V(),docs:q},wt=R(v),Kn={name:I,storage:R(m({prefix:I,items:E(m(Pn))})),calls:wt,events:wt,constants:E(m({name:I,type:v,value:V(),docs:q})),errors:wt,index:k},ro={...Kn,docs:q},Et=R(m({type:v,deprecationInfo:Gs})),so={name:I,storage:R(m({prefix:I,items:E(m({...Pn,deprecationInfo:ke}))})),calls:Et,events:Et,constants:E(m({name:I,type:v,value:V(),docs:q,deprecationInfo:ke})),errors:Et,associatedTypes:E(m({name:I,type:v,docs:q})),viewFns:E(Zs),index:k,docs:q,deprecationInfo:ke},oo=new Uint8Array,qn=e=>A(()=>oo,()=>e),co=m({type:v,version:k,signedExtensions:E(m({identifier:I,type:v,additionalSigned:v}))}),Fn=m({lookup:Ve,pallets:E(m({...Kn,docs:qn([])})),extrinsic:co,type:v,apis:qn([])}),io=m({version:k,address:v,call:v,signature:v,extra:v,signedExtensions:E(m({identifier:I,type:v,additionalSigned:v}))}),Wn=m({lookup:Ve,pallets:E(m(ro)),extrinsic:io,type:v,apis:E(Js),outerEnums:m({call:v,event:v,error:v}),custom:E(X(I,m({type:v,value:V()})))}),ao=m({version:E(k),address:v,call:v,signature:v,signedExtensionsByVersion:E(X(k,E(v))),signedExtensions:E(m({identifier:I,type:v,additionalSigned:v}))}),Xn=m({lookup:Ve,pallets:E(m(so)),extrinsic:ao,apis:E(Qs),outerEnums:m({call:v,event:v,error:v}),custom:E(X(I,m({type:v,value:V()})))}),zn=()=>{throw new Error("Unsupported metadata version!")},j=A(zn,zn),Me=m({magicNumber:se,metadata:N({v0:j,v1:j,v2:j,v3:j,v4:j,v5:j,v6:j,v7:j,v8:j,v9:j,v10:j,v11:j,v12:j,v13:j,v14:Fn,v15:Wn,v16:Xn})}),xt=T(),lo=R(xt),uo=X(K,xt),ho=e=>{try{return Me.dec(e)}catch{}try{return Me.dec(lo.dec(e))}catch{}try{return Me.dec(xt.dec(e))}catch{}try{return Me.dec(uo.dec(e)[1])}catch{}throw null},fo=e=>{if("magicNumber"in e&&(e=e.metadata),"tag"in e){if(e.tag!=="v14"&&e.tag!=="v15"&&e.tag!=="v16")throw new Error("Only metadata 14, 15, and 16 are supported");e=e.value}if("signedExtensionsByVersion"in e.extrinsic)return{version:16,...e};if("custom"in e){const{lookup:s,extrinsic:o,custom:c,apis:i,pallets:d,outerEnums:l}=e;return{version:15,lookup:s,pallets:d.map(a=>({...a,calls:a.calls!=null?{type:a.calls}:void 0,events:a.events!=null?{type:a.events}:void 0,errors:a.errors!=null?{type:a.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...o,version:[o.version]},apis:i,outerEnums:l,custom:c}}const{lookup:t,extrinsic:n,pallets:r}=e;return{version:14,lookup:t,pallets:r.map(s=>({...s,calls:s.calls!=null?{type:s.calls}:void 0,events:s.events!=null?{type:s.events}:void 0,errors:s.errors!=null?{type:s.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...n,version:[n.version]},apis:[]}},me={bare:0,0:"bare",general:1,1:"general",signed:2,2:"signed"},po=M(k,({version:e,type:t})=>e+(me[t]<<6),e=>{const t=e&63,n=e>>6;if(t===4&&(n===me.bare||n===me.signed))return{version:t,type:me[n]};if(t===5&&(n===me.bare||n===me.general))return{version:t,type:me[n]};throw new Error(`ExtrinsicFormat ${e} not valid`)}),yo={dkLen:32},Ze=e=>We(e,yo),go={dkLen:16},It=e=>We(e,go),Yn=e=>ue([It(e),e]),vo={dkLen:32},Gn=e=>Us(e,vo),bo=e=>ue([Gn(e),e]),Jn=e=>e,we=(e,t,n,r)=>new DataView(new Uint16Array([e,t,n,r]).buffer).getBigUint64(0,!0),Bt=2n**64n-1n,C=(e,t)=>e<<t&Bt|e>>64n-t,B=(e,t)=>e*t&Bt,S=(e,t)=>e+t&Bt,D=11400714785074694791n,F=14029467366897019727n,Qn=1609587929392839161n,Ne=9650029242287828579n,Zn=2870177450012600261n;function he(e,t=0n){let n=S(S(t,D),F),r=S(t,F),s=t,o=t-D,c=e.length,i=0,d=null;(function(){let u=0,p=u+c;if(c){if(d=new Uint8Array(32),c<32){d.set(e.subarray(0,c),i),i+=c;return}if(u<=p-32){const y=p-32;do{let b;b=we(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),n=B(C(S(n,B(b,F)),31n),D),u+=8,b=we(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),r=B(C(S(r,B(b,F)),31n),D),u+=8,b=we(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),s=B(C(S(s,B(b,F)),31n),D),u+=8,b=we(e[u+1]<<8|e[u],e[u+3]<<8|e[u+2],e[u+5]<<8|e[u+4],e[u+7]<<8|e[u+6]),o=B(C(S(o,B(b,F)),31n),D),u+=8}while(u<=y)}u<p&&(d.set(e.subarray(u,p),i),i=p-u)}})(),e=d||e;let l,a=0;for(c>=32?(l=C(n,1n),l=S(l,C(r,7n)),l=S(l,C(s,12n)),l=S(l,C(o,18n)),n=B(C(B(n,F),31n),D),l=l^n,l=S(B(l,D),Ne),r=B(C(B(r,F),31n),D),l=l^r,l=S(B(l,D),Ne),s=B(C(B(s,F),31n),D),l=l^s,l=S(B(l,D),Ne),o=B(C(B(o,F),31n),D),l=l^o,l=S(B(l,D),Ne)):l=S(t,Zn),l=S(l,BigInt(c));a<=i-8;){let h=we(e[a+1]<<8|e[a],e[a+3]<<8|e[a+2],e[a+5]<<8|e[a+4],e[a+7]<<8|e[a+6]);h=B(C(B(h,F),31n),D),l=S(B(C(l^h,27n),D),Ne),a+=8}if(a+4<=i){let h=B(we(e[a+1]<<8|e[a],e[a+3]<<8|e[a+2],0,0),D);l=S(B(C(l^h,23n),F),Qn),a+=4}for(;a<i;){const h=B(we(e[a++],0,0,0),Zn);l=B(C(l^h,11n),D)}let f=l>>33n;return l=B(l^f,F),f=l>>29n,l=B(l^f,Qn),f=l>>32n,l^=f,l}const et=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigUint64(0,he(e),!0),n.setBigUint64(8,he(e,1n),!0),t},er=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigUint64(0,he(e),!0),n.setBigUint64(8,he(e,1n),!0),n.setBigUint64(16,he(e,2n),!0),n.setBigUint64(24,he(e,3n),!0),t},tr=e=>ue([Pe.enc(he(e)),e]),nr=new TextEncoder,mo=new Map([[Jn,0],[tr,8],[Yn,16],[It,-16],[Ze,-32],[et,-16],[er,-32]]),wo=e=>{const t=et(nr.encode(e));return(n,...r)=>{const s=ue([t,et(nr.encode(n))]),o=Y(s),c=l=>{if(!l.startsWith(o))throw new Error(`key does not match this storage (${e}.${n})`);if(r.length===0)return[];const a=Le(l.slice(o.length)),f=new Array(r.length);for(let h=0,u=0;h<r.length;h++){const[p,y]=r[h],b=mo.get(y);if(b==null)throw new Error("Unknown hasher");if(b<0){const x=b*-1;f[h]=Y(a.slice(u,u+x)),u+=x}else u+=b,f[h]=p.dec(a.slice(u)),u+=p.enc(f[h]).length}return f},i=r.map(([{enc:l},a])=>f=>a(l(f)));return{enc:(...l)=>Y(ue([s,...l.map((a,f)=>i[f](a))])),dec:c}}},Eo=J.fromText("modlpy/utilisuba").asBytes(),xo=({threshold:e,signatories:t})=>{const n=rr(t),r=ue([Eo,K.enc(n.length),...n,ye.enc(e)]);return Ze(r)},rr=e=>e.slice().sort((t,n)=>{for(let r=0;;r++){const s=r>=t.length,o=r>=n.length;if(s&&o)return 0;if(s)return-1;if(o)return 1;if(t[r]!==n[r])return t[r]>n[r]?1:-1}}),fe={Leaf:"Leaf",Branch:"Branch",BranchWithVal:"BranchWithVal",LeafWithHash:"LeafWithHash",BranchWithHash:"BranchWithHash",Empty:"Empty",Reserved:"Reserved"},sr=V().dec,Io=V(1/0).dec,Bo=V(32).dec,or=k.dec,Ao=e=>{const t=or(e);let n=6;const r=t>>n,s=r?r===1?fe.Leaf:r===2?fe.Branch:fe.BranchWithVal:t>>--n?fe.LeafWithHash:t>>--n?fe.BranchWithHash:t?fe.Reserved:fe.Empty;let o=t&255>>8-n;if(o===2**n-1){let c;do o+=c=or(e);while(c===255)}return{type:s,partialKey:V(Math.ceil(o/2)).dec(e).slice(o%2?3:2)}},cr=Ie(e=>{const t=Ao(e),{type:n}=t;if(n==="Empty"||n==="Reserved")return t;if(n==="Leaf"||n==="LeafWithHash")return{...t,value:Io(e)};const r=ye.dec(e),s=[];for(let i=0;i<16;i++)r>>i&1&&s.push(i.toString(16));let o=null;n==="BranchWithVal"&&(o=sr(e)),n==="BranchWithHash"&&(o=Bo(e));const c={...t,children:Object.fromEntries(s.map(i=>[i,sr(e)]))};return o!==null&&(c.value=o),c}),ir=e=>Ie(t=>{const n=Y(e(new Uint8Array(t.buffer)));try{return{hash:n,...cr(t)}}catch{return{type:"Raw",hash:n,value:""}}});var ko=Object.freeze({__proto__:null,AccountId:ht,Bin:$e,Binary:J,BitSeq:Qe,Blake2128:It,Blake2128Concat:Yn,Blake2256:Ze,Blake3256:Gn,Blake3256Concat:bo,Bytes:T,Enum:pt,FixedSizeBinary:pn,Hex:V,Identity:Jn,Keccak256:Dn,Option:Ae,Result:Je,ScaleEnum:Ge,Self:In,Storage:wo,Struct:$,TrieNodeHeaders:fe,TrieNodeWithHash:ir,Tuple:He,Twox128:et,Twox256:er,Twox64Concat:tr,Variant:be,Vector:de,_Enum:Os,_void:w,bitSequence:Bs,blockHeader:js,bool:Lr,char:As,compact:K,compactBn:vn,compactNumber:v,createCodec:A,createDecoder:Ie,decAnyMetadata:ho,enhanceCodec:M,enhanceDecoder:ct,enhanceEncoder:ot,ethAccount:Cn,extrinsicFormat:po,fixedStr:_s,fromBufferToBase58:ln,getMultisigAccountId:xo,getSs58AddressInfo:an,h64:he,i128:_r,i16:Ir,i256:Ur,i32:Br,i64:Ar,i8:xr,metadata:Me,selfDecoder:xn,selfEncoder:En,sortMultisigSignatories:rr,str:I,trieNodeDec:cr,u128:kr,u16:ye,u256:Or,u32:se,u64:Pe,u8:k,unifyMetadata:fo,v14:Fn,v14Lookup:Ve,v15:Wn,v16:Xn,validateProofs:(e,t=Ze)=>{const n=e.map(ir(t)),r=Object.fromEntries(n.map(i=>[i.hash,i])),s=n.map(i=>i.hash),o=new Set(s),c=i=>{if(i.value)return;const d=e[s.indexOf(i.hash)];i.value=typeof d=="string"?d:Y(d)};return n.forEach(i=>{if("children"in i&&Object.values(i.children).forEach(d=>{const l=r[d];l&&(l.parent=i.hash,o.delete(d))}),i.type==="BranchWithHash"||i.type==="LeafWithHash"){const d=i.value,l=r[d];if(!l)return;o.delete(d),l.type!=="Raw"&&(Object.keys(l).forEach(a=>delete l[a]),l.type="Raw",l.hash=d),l.parent=i.hash,c(l)}i.type==="Raw"&&c(i)}),o.size===1?{rootHash:o.values().next().value,proofs:r}:null}});const _o=(e,t,n)=>(r,s,o,...c)=>{const{id:i}=r;if(s.has(i))return s.get(i);if(o.has(i)){const l=t(()=>s.get(i),r,...c);return s.set(i,l),l}o.add(i);let d=e(r,s,o,...c);return o.delete(i),s.has(i)&&(d=n(d,s.get(i),r,...c)),s.set(i,d),d},Oo=$e(),ar=_o((e,t,n,r)=>{if(e.type==="primitive")return ko[e.value];if(e.type==="void")return w;if(e.type==="AccountId32")return r;if(e.type==="AccountId20")return Cn;if(e.type==="compact")return e.isBig?vn:v;if(e.type==="bitSequence")return Qe(e.isLSB);const s=u=>ar(u,t,n,r),o=(u,p)=>{const y=s(u);return p?de(y,p):de(y)},c=u=>He(...u.map(s)),i=u=>{const p=Object.fromEntries(Object.entries(u).map(([y,b])=>[y,s(b)]));return $(p)};if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return Oo;if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?$e(e.len):o(e.value,e.len);if(e.type==="sequence")return o(e.value);if(e.type==="tuple")return c(e.value);if(e.type==="struct")return i(e.value);if(e.type==="option")return Ae(s(e.value));if(e.type==="result")return Je(s(e.value.ok),s(e.value.ko));const d=Object.values(e.value).map(u=>{switch(u.type){case"void":return w;case"lookupEntry":return s(u.value);case"tuple":return c(u.value);case"struct":return i(u.value);case"array":return o(u.value,u.len)}}),l=Object.fromEntries(Object.keys(e.value).map((u,p)=>[u,d[p]])),a=Object.values(e.value).map(u=>u.idx),h=a.every((u,p)=>u===p)?be(l):be(l,a);return e.byteLength?Lo(h,e.byteLength):h},In,e=>e),Uo=(e,t=ht())=>{const n=new Map,r=s=>ar(e(s),n,new Set,t);return s=>r(s)},Lo=(e,t)=>{const n=T(t);return A(r=>n.enc(e.enc(r)),r=>e.dec(n.dec(r)))},To=e=>{const{metadata:t}=e,n=Uo(e),r=(a="")=>{const f=e.storage[a];if(!f)throw new Error(`Storage entry ${a||"{root}"} not found`);const h=f.key==null?w:n(f.key);return{key:lr(h,f.keyPrefix),value:n(f.typeId)}},s=a=>{const f=$(Object.fromEntries(a.args.map(h=>[h.label,n(h.type.type)])));return{call:lr(f,a.selector),value:n(a.returnType.type)}},o=a=>{const f=t.spec.constructors.find(h=>h.label===a);if(!f)throw new Error(`Constructor ${a} not found`);return s(f)},c=a=>{const f=t.spec.messages.find(h=>h.label===a);if(!f)throw new Error(`Message ${a} not found`);return s(f)},i=a=>$(Object.fromEntries(a.args.map(f=>[f.label,n(f.type.type)])));return{buildConstructor:o,buildMessage:c,buildStorage:r,buildEvents:()=>be(Object.fromEntries(t.spec.events.map(a=>[a.label,i(a)]))),buildEvent:a=>{const f=t.spec.events,h=(p,y)=>M(p,b=>b.value,b=>({type:y,value:b}));if(a){const p=f.find(y=>y.signature_topic===a);return p?h(i(p),p.label):null}const u=f.filter(p=>p.signature_topic===a);return u.length?So(u.map(p=>h(i(p),p.label))):null}}},lr=(e,t)=>{const n=J.fromHex(t).asBytes(),r=He(T(n.length),e);return M(r,s=>[n,s],([,s])=>s)},So=e=>A(t=>{for(const n of e)try{n.enc(t)}catch{}throw new Error("Unable to encode")},t=>{for(const n of e)try{n.dec(t)}catch{}throw new Error("Unable to decode")}),ur=e=>M(Ge(e),t=>{if(typeof t=="string")return{tag:t,value:void 0};const[n,r]=Object.entries(t)[0];return{tag:n,value:r}},t=>({[t.tag]:t.value})),Re=(e,t)=>M(de(e,t),n=>n??[],n=>n),dr=Ae(I),tt=Re(I),Do=ur({bool:w,char:w,str:w,u8:w,u16:w,u32:w,u64:w,u128:w,u256:w,i8:w,i16:w,i32:w,i64:w,i128:w,i256:w}),hr=Re($({name:dr,type:v,typeName:dr,docs:tt})),$o=$({len:se,type:v}),Co=$({bitStoreType:v,bitOrderType:v}),Ho=Re($({name:I,fields:hr,index:k,docs:tt})),Vo=ur({composite:$({fields:hr}),variant:$({variants:Ho}),sequence:$({type:v}),array:$o,tuple:de(v),primitive:Do,compact:v,bitSequence:Co}),Mo=$({name:I,type:Ae(v)}),No=Re(Mo),Ro=$({id:v,path:tt,params:No,def:Vo,docs:tt}),jo=M(Ro,e=>({id:e.id,path:e.type.path,params:e.type.params??[],def:e.type.def,docs:[]}),e=>({id:e.id,type:{def:e.def,path:e.path,params:e.params}})),Po=Re(jo),Ko=e=>{const t=Po.enc(e.types),n=Ve.dec(t),r=e.spec.environment.accountId.type,s=n.find(i=>i.id===r);s&&(s.path=["AccountId32"]);const o=qo(e,n),c=gr(n);return Object.assign(c,{metadata:e,lookup:n,storage:o})};function qo(e,t){const n={},r=(s,o=[])=>{function c(d){const l=t.length;return t[l]={id:l,docs:[],def:d,params:[],path:[]},l}if("root"in s){const d=Number(e.version)===4?J.fromBytes(J.fromHex(s.root.root_key).asBytes().reverse()).asHex():s.root.root_key,l=r(s.root.layout,o);if(s.root.ty!=null){let a=function(f,h){const u=e.types[f].type,p="composite"in u.def?new Map((u.def.composite.fields??[]).map(b=>[b.name,b.type])):null,y=new Map((u.params??[]).map(b=>[b.name,b.type]));if(y.size===2&&y.has("V")&&p&&p.size===2&&p.has("len")&&p.has("elements")){a(p.get("len"),[...h,"len"]),a(p.get("elements"),h);return}else y.size===3&&y.has("K")&&y.has("V")?n[h.join(".")]={keyPrefix:d,key:y.get("K"),typeId:y.get("V")}:y.size===2&&y.has("V")&&(n[h.join(".")]={keyPrefix:d,key:null,typeId:y.get("V")})};a(s.root.ty,o)}return n[o.join(".")]||(n[o.join(".")]={keyPrefix:d,key:null,typeId:l}),c({tag:"composite",value:[]})}if("leaf"in s)return s.leaf.ty;if("hash"in s)throw new Error("HashLayout not implemented");if("array"in s){const d=r(s.array.layout,o);return d==null?null:c({tag:"array",value:{len:s.array.len,type:d}})}if("struct"in s){const d=s.struct.fields.map(l=>({name:l.name,type:r(l.layout,[...o,l.name]),typeName:void 0,docs:[]})).filter(l=>l.type!=null);return c({tag:"composite",value:d})}const i=Object.values(s.enum.variants).map((d,l)=>({name:d.name,fields:d.fields.map(a=>({name:a.name,type:r(a.layout,[...o,d.name,a.name]),typeName:void 0,docs:[]})).filter(a=>a.type!==null),index:l,docs:[]}));return c({tag:"variant",value:i})};return r(e.storage),n}const Fo=e=>{if(!e.metadata)throw new Error("Ink client needs the contract metadata");const t=Ko(e.metadata),n=To(t),r=pr(n.buildConstructor),s=pr(n.buildMessage),o=l=>{const a=t.metadata.spec.constructors.find(f=>f.label===l);if(!a)throw new Error(`Constructor ${l} not found`);return a},c=l=>{const a=t.metadata.spec.messages.find(f=>f.label===l);if(!a)throw new Error(`Message ${l} not found`);return a},i=t.metadata.spec.constructors.find(l=>l.default)?.label,d=t.metadata.spec.messages.find(l=>l.default)?.label;return{constructor:l=>({attributes:fr(o(l)),...r(l)}),defaultConstructor:i,message:l=>({attributes:fr(c(l)),...s(l)}),defaultMessage:d,storage:Wo(n.buildStorage),event:Number(t.metadata.version)===4?Xo(n.buildEvents):zo(t,n.buildEvent)}},fr=e=>({payable:e.payable,default:e.default,mutates:"mutates"in e?e.mutates:!0}),pr=e=>t=>{const n=e(t);return{encode:r=>J.fromBytes(n.call.enc(r||{})),decode:r=>n.value.dec(r.data.asBytes())}},Wo=e=>t=>{const n=e(t);return{encode:r=>J.fromBytes(n.key.enc(r)),decode:r=>n.value.dec(r.asBytes())}},Xo=e=>{const t=r=>e().dec(r.data.asBytes());return{decode:t,filter:(r,s=[])=>s.map(c=>"event"in c?c.event:c).filter(c=>c.type==="Contracts"&&c.value.type==="ContractEmitted"&&c.value.value.contract===r).map(c=>{try{return t(c.value.value)}catch(i){throw console.error(`Contract ${r} emitted an incompatible event`,c.value.value),i}})}},zo=(e,t)=>{const n=new Set(e.metadata.spec.events.map(c=>c.signature_topic).filter(c=>c!=null)),r=e.metadata.spec.events.some(c=>c.signature_topic==null),s=(c,i)=>{if(i!=null){if(!n.has(i))throw new Error(`Event with signature topic ${c} not found`);return t(i).dec(c.data.asBytes())}if(!r)throw new Error("Event signature topic required");return t(void 0).dec(c.data.asBytes())};return{decode:s,filter:(c,i=[])=>{const d=a=>(a instanceof J?a.asHex():a)===c;return i.map(a=>"event"in a?a:{event:a,topics:a.topics}).filter(a=>(a.event.type==="Contracts"||a.event.type==="Revive")&&a.event.value.type==="ContractEmitted"&&d(a.event.value.value.contract)).map(a=>{const h=[...a.topics,...a.event.value?.value?.topics??[]].map(u=>u.asHex()).find(u=>n.has(u));try{return s(a.event.value.value,h)}catch{return null}}).filter(a=>a!==null)}}};_e.getInkClient=Fo}));
