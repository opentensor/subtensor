(function(Le,He){typeof exports=="object"&&typeof module<"u"?He(exports):typeof define=="function"&&define.amd?define(["exports"],He):(Le=typeof globalThis<"u"?globalThis:Le||self,He(Le.papiSigner={}))})(this,(function(Le){"use strict";const He="0123456789abcdef";function re(e){const t=new Array(e.length+1);t[0]="0x";for(let n=0;n<e.length;){const s=e[n++];t[n]=He[s>>4]+He[s&15]}return t.join("")}const yt={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function Me(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,s=(e.length-n)/2+t,r=new Uint8Array(s);t&&(r[0]=0|yt[e[2]]);for(let o=0;o<s;){const c=n+o*2,i=yt[e[c]],u=yt[e[c+1]];r[t+o++]=i<<4|u}return r}function gt(e,t){return Object.fromEntries(Object.entries(e).map(([n,s])=>[n,t(s,n)]))}const N=(...e)=>{const t=Array.isArray(e[0])?e[0]:e,n=t.reduce((r,o)=>r+o.byteLength,0),s=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const c=t[r];s.set(c,o),o+=c.byteLength}return s};var Gr=Object.defineProperty,Jr=(e,t,n)=>t in e?Gr(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Kt=(e,t,n)=>(Jr(e,typeof t!="symbol"?t+"":t,n),n),vt={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,b:11,c:12,d:13,e:14,f:15,A:10,B:11,C:12,D:13,E:14,F:15};function Qr(e){const t=e.length%2,n=(e[1]==="x"?2:0)+t,s=(e.length-n)/2+t,r=new Uint8Array(s);t&&(r[0]=0|vt[e[2]]);for(let o=0;o<s;){const c=n+o*2,i=vt[e[c]],u=vt[e[c+1]];r[t+o++]=i<<4|u}return r}var Xt=class extends Uint8Array{constructor(e){super(e),Kt(this,"i",0),Kt(this,"v"),this.v=new DataView(e)}},Q=e=>t=>e(t instanceof Xt?t:new Xt(t instanceof Uint8Array?t.buffer:typeof t=="string"?Qr(t).buffer:t)),se=e=>{const t=e.length;let n=0;for(let r=0;r<t;r++)n+=e[r].length;const s=new Uint8Array(n);for(let r=0,o=0;r<t;r++){const c=e[r];s.set(c,o),o+=c.byteLength}return s};function tt(e,t){const n=Object.keys(e),s=n.length,r={};for(let o=0;o<s;o++){const c=n[o];r[c]=t(e[c],c)}return r}var Be=Q,_=(e,t)=>{const n=[e,t];return n.enc=e,n.dec=t,n},mt=(e,t)=>n=>e(t(n)),wt=(e,t)=>n=>t(e(n)),oe=([e,t],n,s)=>_(mt(e,n),wt(t,s));function Zr(e,t){return Q(n=>{const s=n.v[t](n.i,!0);return n.i+=e,s})}function es(e,t){return n=>{const s=new Uint8Array(e);return new DataView(s.buffer)[t](0,n,!0),s}}function ge(e,t,n){return _(es(e,n),Zr(e,t))}var A=ge(1,"getUint8","setUint8"),ie=ge(2,"getUint16","setUint16"),Z=ge(4,"getUint32","setUint32"),Re=ge(8,"getBigUint64","setBigUint64"),zt=ge(1,"getInt8","setInt8"),Yt=ge(2,"getInt16","setInt16"),Gt=ge(4,"getInt32","setInt32"),Jt=ge(8,"getBigInt64","setBigInt64"),Qt=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),t},Zt=e=>Q(t=>{const{v:n,i:s}=t,r=n.getBigUint64(s,!0),o=n[e](s+8,!0);return t.i+=16,o<<64n|r}),en=_(Qt,Zt("getBigUint64")),tn=_(Qt,Zt("getBigInt64")),nn=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigInt64(0,e,!0),n.setBigInt64(8,e>>64n,!0),n.setBigInt64(16,e>>128n,!0),n.setBigInt64(24,e>>192n,!0),t},rn=e=>Q(t=>{let n=t.v.getBigUint64(t.i,!0);return t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<64n,t.i+=8,n|=t.v.getBigUint64(t.i,!0)<<128n,t.i+=8,n|=t.v[e](t.i,!0)<<192n,t.i+=8,n}),sn=_(nn,rn("getBigUint64")),on=_(nn,rn("getBigInt64")),cn=oe(A,e=>e?1:0,Boolean),ts=[A[1],ie[1],Z[1]],ns=Q(e=>{const t=e[e.i],n=t&3;if(n<3)return ts[n](e)>>>2;const s=(t>>>2)+4;e.i++;let r=0n;const o=s/8|0;let c=0n;for(let u=0;u<o;u++)r=Re[1](e)<<c|r,c+=64n;let i=s%8;return i>3&&(r=BigInt(Z[1](e))<<c|r,c+=32n,i-=4),i>1&&(r=BigInt(ie[1](e))<<c|r,c+=16n,i-=2),i&&(r=BigInt(A[1](e))<<c|r),r}),rs=1n<<56n,ss=1<<24,os=256,cs=4294967295n,is=64,as=16384,ls=1<<30,us=e=>{if(e<0)throw new Error(`Wrong compact input (${e})`);const t=Number(e)<<2;if(e<is)return A[0](t);if(e<as)return ie[0](t|1);if(e<ls)return Z[0](t|2);let n=[new Uint8Array(1)],s=BigInt(e);for(;s>=rs;)n.push(Re[0](s)),s>>=64n;s>=ss&&(n.push(Z[0](Number(s&cs))),s>>=32n);let r=Number(s);r>=os&&(n.push(ie[0](r)),r>>=16),r&&n.push(A[0](r));const o=se(n);return o[0]=o.length-5<<2|3,o},D=_(us,ns),hs=new TextEncoder,ds=e=>{const t=hs.encode(e);return se([D.enc(t.length),t])},fs=new TextDecoder,ps=Q(e=>{let t=D.dec(e);const n=new DataView(e.buffer,e.i,t);return e.i+=t,fs.decode(n)}),k=_(ds,ps),ys=()=>{},gs=new Uint8Array(0),v=_(()=>gs,ys),an=e=>e===void 0?t=>se([D.enc(t.length),t]):t=>t.length===e?t:t.slice(0,e),ln=e=>Q(t=>{const n=e===void 0?D.dec(t):e!==1/0?e:t.byteLength-t.i,s=new Uint8Array(t.buffer.slice(t.i,t.i+n));return t.i+=n,s}),H=e=>_(an(e),ln(e));H.enc=an,H.dec=ln;var un=(e,t)=>{const n=Object.keys(e),s=new Map(t?.map((o,c)=>[n[c],o])??n.map((o,c)=>[o,c])),r=o=>s.get(o);return({tag:o,value:c})=>se([A.enc(r(o)),e[o](c)])},hn=(e,t)=>{const n=Object.keys(e),s=new Map(t?.map((r,o)=>[r,n[o]])??n.map((r,o)=>[o,r]));return Q(r=>{const o=A.dec(r),c=s.get(o),i=e[c];return{tag:c,value:i(r)}})},K=(e,...t)=>_(un(tt(e,([n])=>n),...t),hn(tt(e,([,n])=>n),...t));K.enc=un,K.dec=hn;var dn=e=>Q(t=>A[1](t)>0?e(t):void 0),fn=e=>t=>{const n=new Uint8Array(1);return t===void 0?n:(n[0]=1,se([n,e(t)]))},X=e=>_(fn(e[0]),dn(e[1]));X.enc=fn,X.dec=dn;var pn=(e,t)=>Q(n=>{const s=A[1](n)===0,o=(s?e:t)(n);return{success:s,value:o}}),yn=(e,t)=>({success:n,value:s})=>se([A[0](n?0:1),(n?e:t)(s)]),Fe=(e,t)=>_(yn(e[0],t[0]),pn(e[1],t[1]));Fe.dec=pn,Fe.enc=yn;var gn=(...e)=>Q(t=>e.map(n=>n(t))),vn=(...e)=>t=>se(e.map((n,s)=>n(t[s]))),ee=(...e)=>_(vn(...e.map(([t])=>t)),gn(...e.map(([,t])=>t)));ee.enc=vn,ee.dec=gn;var mn=e=>{const t=Object.keys(e);return mt(ee.enc(...Object.values(e)),n=>t.map(s=>n[s]))},wn=e=>{const t=Object.keys(e);return wt(ee.dec(...Object.values(e)),n=>Object.fromEntries(n.map((s,r)=>[t[r],s])))},b=e=>_(mn(tt(e,t=>t[0])),wn(tt(e,t=>t[1])));b.enc=mn,b.dec=wn;var bn=(e,t)=>t>=0?n=>se(n.map(e)):n=>se([D.enc(n.length),se(n.map(e))]),xn=(e,t)=>Q(n=>{const s=t>=0?t:D.dec(n),r=new Array(s);for(let o=0;o<s;o++)r[o]=e(n);return r}),I=(e,t)=>_(bn(e[0],t),xn(e[1],t));I.enc=bn,I.dec=xn;/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function vs(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function En(e,t){return Array.isArray(t)?t.length===0?!0:e?t.every(n=>typeof n=="string"):t.every(n=>Number.isSafeInteger(n)):!1}function bt(e,t){if(typeof t!="string")throw new Error(`${e}: string expected`);return!0}function In(e){if(!Number.isSafeInteger(e))throw new Error(`invalid integer: ${e}`)}function xt(e){if(!Array.isArray(e))throw new Error("array expected")}function kn(e,t){if(!En(!0,t))throw new Error(`${e}: array of strings expected`)}function ms(e,t){if(!En(!1,t))throw new Error(`${e}: array of numbers expected`)}function ws(...e){const t=o=>o,n=(o,c)=>i=>o(c(i)),s=e.map(o=>o.encode).reduceRight(n,t),r=e.map(o=>o.decode).reduce(n,t);return{encode:s,decode:r}}function bs(e){const t=typeof e=="string"?e.split(""):e,n=t.length;kn("alphabet",t);const s=new Map(t.map((r,o)=>[r,o]));return{encode:r=>(xt(r),r.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${e}`);return t[o]})),decode:r=>(xt(r),r.map(o=>{bt("alphabet.decode",o);const c=s.get(o);if(c===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${e}`);return c}))}}function xs(e=""){return bt("join",e),{encode:t=>(kn("join.decode",t),t.join(e)),decode:t=>(bt("join.decode",t),t.split(e))}}function Bn(e,t,n){if(t<2)throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(xt(e),!e.length)return[];let s=0;const r=[],o=Array.from(e,i=>{if(In(i),i<0||i>=t)throw new Error(`invalid integer: ${i}`);return i}),c=o.length;for(;;){let i=0,u=!0;for(let a=s;a<c;a++){const d=o[a],y=t*i,l=y+d;if(!Number.isSafeInteger(l)||y/t!==i||l-d!==y)throw new Error("convertRadix: carry overflow");const h=l/n;i=l%n;const p=Math.floor(h);if(o[a]=p,!Number.isSafeInteger(p)||p*n+i!==l)throw new Error("convertRadix: carry overflow");if(u)p?u=!1:s=a;else continue}if(r.push(i),u)break}for(let i=0;i<e.length-1&&e[i]===0;i++)r.push(0);return r.reverse()}function Es(e){In(e);const t=2**8;return{encode:n=>{if(!vs(n))throw new Error("radix.encode input should be Uint8Array");return Bn(Array.from(n),t,e)},decode:n=>(ms("radix.decode",n),Uint8Array.from(Bn(n,e,t)))}}const An=(e=>ws(Es(58),bs(e),xs("")))("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Is(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Ve(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function te(e,t,n=""){const s=Is(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){const c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+u)}return e}function qe(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Et(e,t){te(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function ks(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}function Ae(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function ve(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function nt(e,t){return e<<32-t|e>>>t}const Un=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function On(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}const ae=Un?e=>e:e=>On(e);function Bs(e){for(let t=0;t<e.length;t++)e[t]=On(e[t]);return e}const q=Un?e=>e:Bs;function It(e,t={}){const n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}const As=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]);function me(e,t,n,s,r){return e=e+t+r|0,s=nt(s^e,16),n=n+s|0,t=nt(t^n,12),{a:e,b:t,c:n,d:s}}function we(e,t,n,s,r){return e=e+t+r|0,s=nt(s^e,8),n=n+s|0,t=nt(t^n,7),{a:e,b:t,c:n,d:s}}const Us=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),rt=BigInt(2**32-1),_n=BigInt(32);function st(e,t=!1){return t?{h:Number(e&rt),l:Number(e>>_n&rt)}:{h:Number(e>>_n&rt)|0,l:Number(e&rt)|0}}function Os(e,t=!1){const n=e.length;let s=new Uint32Array(n),r=new Uint32Array(n);for(let o=0;o<n;o++){const{h:c,l:i}=st(e[o],t);[s[o],r[o]]=[c,i]}return[s,r]}const Sn=(e,t,n)=>e>>>n|t<<32-n,Tn=(e,t,n)=>e<<32-n|t>>>n,_s=(e,t,n)=>e<<64-n|t>>>n-32,Ss=(e,t,n)=>e>>>n-32|t<<64-n,Ts=(e,t)=>t,Ds=(e,t)=>e,Ls=(e,t,n)=>e<<n|t>>>32-n,Hs=(e,t,n)=>t<<n|e>>>32-n,Ms=(e,t,n)=>t<<n-32|e>>>64-n,Vs=(e,t,n)=>e<<n-32|t>>>64-n;function Dn(e,t,n,s){const r=(t>>>0)+(s>>>0);return{h:e+n+(r/2**32|0)|0,l:r|0}}const Ln=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Hn=(e,t,n,s)=>t+n+s+(e/2**32|0)|0,M=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),g=new Uint32Array(32);function be(e,t,n,s,r,o){const c=r[o],i=r[o+1];let u=g[2*e],a=g[2*e+1],d=g[2*t],y=g[2*t+1],l=g[2*n],h=g[2*n+1],p=g[2*s],f=g[2*s+1],m=Ln(u,d,c);a=Hn(m,a,y,i),u=m|0,{Dh:f,Dl:p}={Dh:f^a,Dl:p^u},{Dh:f,Dl:p}={Dh:Ts(f,p),Dl:Ds(f)},{h,l}=Dn(h,l,f,p),{Bh:y,Bl:d}={Bh:y^h,Bl:d^l},{Bh:y,Bl:d}={Bh:Sn(y,d,24),Bl:Tn(y,d,24)},g[2*e]=u,g[2*e+1]=a,g[2*t]=d,g[2*t+1]=y,g[2*n]=l,g[2*n+1]=h,g[2*s]=p,g[2*s+1]=f}function xe(e,t,n,s,r,o){const c=r[o],i=r[o+1];let u=g[2*e],a=g[2*e+1],d=g[2*t],y=g[2*t+1],l=g[2*n],h=g[2*n+1],p=g[2*s],f=g[2*s+1],m=Ln(u,d,c);a=Hn(m,a,y,i),u=m|0,{Dh:f,Dl:p}={Dh:f^a,Dl:p^u},{Dh:f,Dl:p}={Dh:Sn(f,p,16),Dl:Tn(f,p,16)},{h,l}=Dn(h,l,f,p),{Bh:y,Bl:d}={Bh:y^h,Bl:d^l},{Bh:y,Bl:d}={Bh:_s(y,d,63),Bl:Ss(y,d,63)},g[2*e]=u,g[2*e+1]=a,g[2*t]=d,g[2*t+1]=y,g[2*n]=l,g[2*n+1]=h,g[2*s]=p,g[2*s+1]=f}function Cs(e,t={},n,s,r){if(Ve(n),e<0||e>n)throw new Error("outputLen bigger than keyLen");const{key:o,salt:c,personalization:i}=t;if(o!==void 0&&(o.length<1||o.length>n))throw new Error('"key" expected to be undefined or of length=1..'+n);c!==void 0&&te(c,s,"salt"),i!==void 0&&te(i,r,"personalization")}class Mn{buffer;buffer32;finished=!1;destroyed=!1;length=0;pos=0;blockLen;outputLen;constructor(t,n){Ve(t),Ve(n),this.blockLen=t,this.outputLen=n,this.buffer=new Uint8Array(t),this.buffer32=Ae(this.buffer)}update(t){qe(this),te(t);const{blockLen:n,buffer:s,buffer32:r}=this,o=t.length,c=t.byteOffset,i=t.buffer;for(let u=0;u<o;){this.pos===n&&(q(r),this.compress(r,0,!1),q(r),this.pos=0);const a=Math.min(n-this.pos,o-u),d=c+u;if(a===n&&!(d%4)&&u+a<o){const y=new Uint32Array(i,d,Math.floor((o-u)/4));q(y);for(let l=0;u+n<o;l+=r.length,u+=n)this.length+=n,this.compress(y,l,!1);q(y);continue}s.set(t.subarray(u,u+a),this.pos),this.pos+=a,this.length+=a,u+=a}return this}digestInto(t){qe(this),Et(t,this);const{pos:n,buffer32:s}=this;this.finished=!0,ve(this.buffer.subarray(n)),q(s),this.compress(s,0,!0),q(s);const r=Ae(t);this.get().forEach((o,c)=>r[c]=ae(o))}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){const{buffer:n,length:s,finished:r,destroyed:o,outputLen:c,pos:i}=this;return t||=new this.constructor({dkLen:c}),t.set(...this.get()),t.buffer.set(n),t.destroyed=o,t.finished=r,t.length=s,t.pos=i,t.outputLen=c,t}clone(){return this._cloneInto()}}class $s extends Mn{v0l=M[0]|0;v0h=M[1]|0;v1l=M[2]|0;v1h=M[3]|0;v2l=M[4]|0;v2h=M[5]|0;v3l=M[6]|0;v3h=M[7]|0;v4l=M[8]|0;v4h=M[9]|0;v5l=M[10]|0;v5h=M[11]|0;v6l=M[12]|0;v6h=M[13]|0;v7l=M[14]|0;v7h=M[15]|0;constructor(t={}){const n=t.dkLen===void 0?64:t.dkLen;super(128,n),Cs(n,t,64,16,16);let{key:s,personalization:r,salt:o}=t,c=0;if(s!==void 0&&(te(s,void 0,"key"),c=s.length),this.v0l^=this.outputLen|c<<8|65536|1<<24,o!==void 0){te(o,void 0,"salt");const i=Ae(o);this.v4l^=ae(i[0]),this.v4h^=ae(i[1]),this.v5l^=ae(i[2]),this.v5h^=ae(i[3])}if(r!==void 0){te(r,void 0,"personalization");const i=Ae(r);this.v6l^=ae(i[0]),this.v6h^=ae(i[1]),this.v7l^=ae(i[2]),this.v7h^=ae(i[3])}if(s!==void 0){const i=new Uint8Array(this.blockLen);i.set(s),this.update(i)}}get(){let{v0l:t,v0h:n,v1l:s,v1h:r,v2l:o,v2h:c,v3l:i,v3h:u,v4l:a,v4h:d,v5l:y,v5h:l,v6l:h,v6h:p,v7l:f,v7h:m}=this;return[t,n,s,r,o,c,i,u,a,d,y,l,h,p,f,m]}set(t,n,s,r,o,c,i,u,a,d,y,l,h,p,f,m){this.v0l=t|0,this.v0h=n|0,this.v1l=s|0,this.v1h=r|0,this.v2l=o|0,this.v2h=c|0,this.v3l=i|0,this.v3h=u|0,this.v4l=a|0,this.v4h=d|0,this.v5l=y|0,this.v5h=l|0,this.v6l=h|0,this.v6h=p|0,this.v7l=f|0,this.v7h=m|0}compress(t,n,s){this.get().forEach((u,a)=>g[a]=u),g.set(M,16);let{h:r,l:o}=st(BigInt(this.length));g[24]=M[8]^o,g[25]=M[9]^r,s&&(g[28]=~g[28],g[29]=~g[29]);let c=0;const i=As;for(let u=0;u<12;u++)be(0,4,8,12,t,n+2*i[c++]),xe(0,4,8,12,t,n+2*i[c++]),be(1,5,9,13,t,n+2*i[c++]),xe(1,5,9,13,t,n+2*i[c++]),be(2,6,10,14,t,n+2*i[c++]),xe(2,6,10,14,t,n+2*i[c++]),be(3,7,11,15,t,n+2*i[c++]),xe(3,7,11,15,t,n+2*i[c++]),be(0,5,10,15,t,n+2*i[c++]),xe(0,5,10,15,t,n+2*i[c++]),be(1,6,11,12,t,n+2*i[c++]),xe(1,6,11,12,t,n+2*i[c++]),be(2,7,8,13,t,n+2*i[c++]),xe(2,7,8,13,t,n+2*i[c++]),be(3,4,9,14,t,n+2*i[c++]),xe(3,4,9,14,t,n+2*i[c++]);this.v0l^=g[0]^g[16],this.v0h^=g[1]^g[17],this.v1l^=g[2]^g[18],this.v1h^=g[3]^g[19],this.v2l^=g[4]^g[20],this.v2h^=g[5]^g[21],this.v3l^=g[6]^g[22],this.v3h^=g[7]^g[23],this.v4l^=g[8]^g[24],this.v4h^=g[9]^g[25],this.v5l^=g[10]^g[26],this.v5h^=g[11]^g[27],this.v6l^=g[12]^g[28],this.v6h^=g[13]^g[29],this.v7l^=g[14]^g[30],this.v7h^=g[15]^g[31],ve(g)}destroy(){this.destroyed=!0,ve(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ot=It(e=>new $s(e));function Vn(e,t,n,s,r,o,c,i,u,a,d,y,l,h,p,f,m,x,B,S){let T=0;for(let J=0;J<s;J++)({a:r,b:u,c:l,d:m}=me(r,u,l,m,n[t+e[T++]])),{a:r,b:u,c:l,d:m}=we(r,u,l,m,n[t+e[T++]]),{a:o,b:a,c:h,d:x}=me(o,a,h,x,n[t+e[T++]]),{a:o,b:a,c:h,d:x}=we(o,a,h,x,n[t+e[T++]]),{a:c,b:d,c:p,d:B}=me(c,d,p,B,n[t+e[T++]]),{a:c,b:d,c:p,d:B}=we(c,d,p,B,n[t+e[T++]]),{a:i,b:y,c:f,d:S}=me(i,y,f,S,n[t+e[T++]]),{a:i,b:y,c:f,d:S}=we(i,y,f,S,n[t+e[T++]]),{a:r,b:a,c:p,d:S}=me(r,a,p,S,n[t+e[T++]]),{a:r,b:a,c:p,d:S}=we(r,a,p,S,n[t+e[T++]]),{a:o,b:d,c:f,d:m}=me(o,d,f,m,n[t+e[T++]]),{a:o,b:d,c:f,d:m}=we(o,d,f,m,n[t+e[T++]]),{a:c,b:y,c:l,d:x}=me(c,y,l,x,n[t+e[T++]]),{a:c,b:y,c:l,d:x}=we(c,y,l,x,n[t+e[T++]]),{a:i,b:u,c:h,d:B}=me(i,u,h,B,n[t+e[T++]]),{a:i,b:u,c:h,d:B}=we(i,u,h,B,n[t+e[T++]]);return{v0:r,v1:o,v2:c,v3:i,v4:u,v5:a,v6:d,v7:y,v8:l,v9:h,v10:p,v11:f,v12:m,v13:x,v14:B,v15:S}}const Cn=new TextEncoder().encode("SS58PRE"),kt=2,$n=e=>{try{const t=An.decode(e),n=t.subarray(0,t[0]&64?2:1),s=t.subarray(n.length,t.length-kt),r=t.subarray(n.length+s.length),o=ot(Uint8Array.of(...Cn,...n,...s),{dkLen:64}).subarray(0,kt);return r[0]===o[0]&&r[1]===o[1]?{isValid:!0,ss58Format:Ps(n),publicKey:s.slice()}:{isValid:!1}}catch{return{isValid:!1}}},Ps=e=>{const t=new DataView(e.buffer,e.byteOffset,e.byteLength);return t.byteLength===1?t.getUint8(0):t.getUint16(0)},Pn=e=>{const t=e<64?Uint8Array.of(e):Uint8Array.of((e&252)>>2|64,e>>8|(e&3)<<6);return n=>{const s=ot(Uint8Array.of(...Cn,...t,...n),{dkLen:64}).subarray(0,kt);return An.encode(Uint8Array.of(...t,...n,...s))}};function Ns(e,t){return n=>{const s=$n(n);if(!s.isValid)throw new Error("Invalid checksum");const{publicKey:r}=s;if(r.length!==e)throw new Error("Invalid public key length");return r}}const ct=(e=42,t=32)=>oe(H(t),Ns(t),Pn(e));var Rs=Object.defineProperty,Nn=e=>{throw TypeError(e)},Fs=(e,t,n)=>t in e?Rs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,je=(e,t,n)=>Fs(e,typeof t!="symbol"?t+"":t,n),Rn=(e,t,n)=>t.has(e)||Nn("Cannot "+n),le=(e,t,n)=>(Rn(e,t,"read from private field"),n?n.call(e):t.get(e)),We=(e,t,n)=>t.has(e)?Nn("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,n),Ue=(e,t,n,s)=>(Rn(e,t,"write to private field"),t.set(e,n),n),ue,Ke,it,at,lt;const qs=new TextEncoder,js=new TextDecoder,Ws=ee(D,H(1/0))[1];class Xe{constructor(t,n=!1){if(We(this,ue),We(this,Ke,null),We(this,it,null),We(this,at,null),We(this,lt,null),je(this,"asText",()=>le(this,lt)??Ue(this,lt,js.decode(le(this,ue)))),je(this,"asHex",()=>le(this,it)??Ue(this,it,re(le(this,ue)))),je(this,"asOpaqueHex",()=>le(this,at)??Ue(this,at,re(this.asBytes()))),je(this,"asBytes",()=>le(this,ue)),je(this,"asOpaqueBytes",()=>le(this,Ke)??Ue(this,Ke,N([le(this,ue),D[0](le(this,ue).length)]))),n){try{const[s,r]=Ws(t);if(s===r.length){Ue(this,ue,r),Ue(this,Ke,t);return}}catch{}throw new Error("Invalid opaque bytes")}else Ue(this,ue,t)}static fromText(t){return new this(qs.encode(t))}static fromHex(t){return new this(Me(t))}static fromOpaqueHex(t){return new this(Me(t),!0)}static fromBytes(t){return new this(t)}static fromOpaqueBytes(t){return new this(t,!0)}}ue=new WeakMap,Ke=new WeakMap,it=new WeakMap,at=new WeakMap,lt=new WeakMap;const[Ks]=ct();class Fn extends Xe{constructor(t){super(t)}static fromArray(t){return new this(new Uint8Array(t))}static fromAccountId32(t){return new this(Ks(t))}}const qn=e=>{const t=H.enc(e);return n=>t(n.asBytes())},jn=e=>{const t=H.dec(e),n=e==null?Xe:Fn;return s=>n.fromBytes(t(s))},ze=e=>_(qn(e),jn(e));ze.enc=qn,ze.dec=jn;const w=oe(D,e=>e,Number),Wn=oe(D,e=>e,BigInt),Xs=Be(e=>{const t=w.dec(e),n=Math.ceil(t/8);return{bytes:H(n).dec(e),bitsLen:t}}),zs=_(e=>{if(e.bitsLen>e.bytes.length*8)throw new Error(`Not enough bytes. (bitsLen:${e.bitsLen}, bytesLen:${e.bytes.length})`);const t=w.enc(e.bitsLen),n=new Uint8Array(e.bytes.length+t.length);return n.set(t,0),n.set(e.bytes,t.length),n},Xs),Ys=oe(A,e=>e.charCodeAt(0),String.fromCharCode),Kn=e=>{const t=H.enc(e);return n=>t(Me(n))},Xn=e=>{const t=H.dec(e);return n=>re(t(n))},j=e=>_(Kn(e),Xn(e));j.enc=Kn,j.dec=Xn;const zn=new TextEncoder,Gs=new TextDecoder,Js=e=>oe(H(e),t=>zn.encode(t),t=>Gs.decode(t)),Yn=e=>{let t=n=>{const s=e();return t=s,s(n)};return n=>t(n)},Gn=e=>{let t=n=>{const s=e(),r=s;return t=s,r(n)};return n=>t(n)},Jn=e=>_(Yn(()=>e().enc),Gn(()=>e().dec)),Bt=Object.assign((e,t)=>({type:e,value:t}),{is(e,t){return e.type===t},as(e,t){if(t!==e.type)throw new Error(`Enum.as(enum, ${t}) used with actual type ${e.type}`);return e}}),Qs=new Proxy({},{get(e,t){return n=>Bt(t,n)}}),L=(e,t)=>{const n=e;return n.inner=t,n},Qn=(...e)=>{const t=K.enc(...e);return L(n=>t({tag:n.type,value:n.value}),e[0])},Zn=(...e)=>{const t=K.dec(...e);return L(n=>{const{tag:s,value:r}=t(n);return Bt(s,r)},e[0])},Ce=(e,...t)=>L(_(Qn(gt(e,([n])=>n),...t),Zn(gt(e,([,n])=>n),...t)),e);Ce.enc=Qn,Ce.dec=Zn;const Oe=(e,...t)=>L(K(e,...t),e);Oe.enc=(e,...t)=>L(K.enc(e,...t),e),Oe.dec=(e,...t)=>L(K.dec(e,...t),e);const ce={CHUNK_START:1,CHUNK_END:2,PARENT:4,ROOT:8,KEYED_HASH:16,DERIVE_KEY_CONTEXT:32,DERIVE_KEY_MATERIAL:64},he=Us.slice(),er=(()=>{const e=Array.from({length:16},(s,r)=>r),t=s=>[2,6,3,10,7,0,4,13,1,11,12,5,9,14,15,8].map(r=>s[r]),n=[];for(let s=0,r=e;s<7;s++,r=t(r))n.push(...r);return Uint8Array.from(n)})();class At extends Mn{chunkPos=0;chunksDone=0;flags=0;IV;state;stack=[];posOut=0;bufferOut32=new Uint32Array(16);bufferOut;chunkOut=0;enableXOF=!0;constructor(t={},n=0){super(64,t.dkLen===void 0?32:t.dkLen);const{key:s,context:r}=t,o=r!==void 0;if(s!==void 0){if(o)throw new Error('Only "key" or "context" can be specified at same time');te(s,32,"key");const c=s.slice();this.IV=Ae(c),q(this.IV),this.flags=n|ce.KEYED_HASH}else if(o){te(r,void 0,"context");const c=r,i=new At({dkLen:32},ce.DERIVE_KEY_CONTEXT).update(c).digest();this.IV=Ae(i),q(this.IV),this.flags=n|ce.DERIVE_KEY_MATERIAL}else this.IV=he.slice(),this.flags=n;this.state=this.IV.slice(),this.bufferOut=ks(this.bufferOut32)}get(){return[]}set(){}b2Compress(t,n,s,r=0){const{state:o,pos:c}=this,{h:i,l:u}=st(BigInt(t),!0),{v0:a,v1:d,v2:y,v3:l,v4:h,v5:p,v6:f,v7:m,v8:x,v9:B,v10:S,v11:T,v12:J,v13:ne,v14:pe,v15:V}=Vn(er,r,s,7,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],he[0],he[1],he[2],he[3],i,u,c,n);o[0]=a^x,o[1]=d^B,o[2]=y^S,o[3]=l^T,o[4]=h^J,o[5]=p^ne,o[6]=f^pe,o[7]=m^V}compress(t,n=0,s=!1){let r=this.flags;if(this.chunkPos||(r|=ce.CHUNK_START),(this.chunkPos===15||s)&&(r|=ce.CHUNK_END),s||(this.pos=this.blockLen),this.b2Compress(this.chunksDone,r,t,n),this.chunkPos+=1,this.chunkPos===16||s){let o=this.state;this.state=this.IV.slice();for(let c,i=this.chunksDone+1;(s||!(i&1))&&(c=this.stack.pop());i>>=1)this.buffer32.set(c,0),this.buffer32.set(o,8),this.pos=this.blockLen,this.b2Compress(0,this.flags|ce.PARENT,this.buffer32,0),o=this.state,this.state=this.IV.slice();this.chunksDone++,this.chunkPos=0,this.stack.push(o)}this.pos=0}_cloneInto(t){t=super._cloneInto(t);const{IV:n,flags:s,state:r,chunkPos:o,posOut:c,chunkOut:i,stack:u,chunksDone:a}=this;return t.state.set(r.slice()),t.stack=u.map(d=>Uint32Array.from(d)),t.IV.set(n),t.flags=s,t.chunkPos=o,t.chunksDone=a,t.posOut=c,t.chunkOut=i,t.enableXOF=this.enableXOF,t.bufferOut32.set(this.bufferOut32),t}destroy(){this.destroyed=!0,ve(this.state,this.buffer32,this.IV,this.bufferOut32),ve(...this.stack)}b2CompressOut(){const{state:t,pos:n,flags:s,buffer32:r,bufferOut32:o}=this,{h:c,l:i}=st(BigInt(this.chunkOut++));q(r);const{v0:u,v1:a,v2:d,v3:y,v4:l,v5:h,v6:p,v7:f,v8:m,v9:x,v10:B,v11:S,v12:T,v13:J,v14:ne,v15:pe}=Vn(er,0,r,7,t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],he[0],he[1],he[2],he[3],i,c,n,s);o[0]=u^m,o[1]=a^x,o[2]=d^B,o[3]=y^S,o[4]=l^T,o[5]=h^J,o[6]=p^ne,o[7]=f^pe,o[8]=t[0]^m,o[9]=t[1]^x,o[10]=t[2]^B,o[11]=t[3]^S,o[12]=t[4]^T,o[13]=t[5]^J,o[14]=t[6]^ne,o[15]=t[7]^pe,q(r),q(o),this.posOut=0}finish(){if(this.finished)return;this.finished=!0,ve(this.buffer.subarray(this.pos));let t=this.flags|ce.ROOT;this.stack.length?(t|=ce.PARENT,q(this.buffer32),this.compress(this.buffer32,0,!0),q(this.buffer32),this.chunksDone=0,this.pos=this.blockLen):t|=(this.chunkPos?0:ce.CHUNK_START)|ce.CHUNK_END,this.flags=t,this.b2CompressOut()}writeInto(t){qe(this,!1),te(t),this.finish();const{blockLen:n,bufferOut:s}=this;for(let r=0,o=t.length;r<o;){this.posOut>=n&&this.b2CompressOut();const c=Math.min(n-this.posOut,o-r);t.set(s.subarray(this.posOut,this.posOut+c),r),this.posOut+=c,r+=c}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible after digest call");return this.writeInto(t)}xof(t){return Ve(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Et(t,this),this.finished)throw new Error("digest() was already called");return this.enableXOF=!1,this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}}const Zs=It((e={})=>new At(e)),eo=BigInt(0),Ye=BigInt(1),to=BigInt(2),no=BigInt(7),ro=BigInt(256),so=BigInt(113),tr=[],nr=[],rr=[];for(let e=0,t=Ye,n=1,s=0;e<24;e++){[n,s]=[s,(2*n+3*s)%5],tr.push(2*(5*s+n)),nr.push((e+1)*(e+2)/2%64);let r=eo;for(let o=0;o<7;o++)t=(t<<Ye^(t>>no)*so)%ro,t&to&&(r^=Ye<<(Ye<<BigInt(o))-Ye);rr.push(r)}const sr=Os(rr,!0),oo=sr[0],co=sr[1],or=(e,t,n)=>n>32?Ms(e,t,n):Ls(e,t,n),cr=(e,t,n)=>n>32?Vs(e,t,n):Hs(e,t,n);function io(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let c=0;c<10;c++)n[c]=e[c]^e[c+10]^e[c+20]^e[c+30]^e[c+40];for(let c=0;c<10;c+=2){const i=(c+8)%10,u=(c+2)%10,a=n[u],d=n[u+1],y=or(a,d,1)^n[i],l=cr(a,d,1)^n[i+1];for(let h=0;h<50;h+=10)e[c+h]^=y,e[c+h+1]^=l}let r=e[2],o=e[3];for(let c=0;c<24;c++){const i=nr[c],u=or(r,o,i),a=cr(r,o,i),d=tr[c];r=e[d],o=e[d+1],e[d]=u,e[d+1]=a}for(let c=0;c<50;c+=10){for(let i=0;i<10;i++)n[i]=e[c+i];for(let i=0;i<10;i++)e[c+i]^=~n[(i+2)%10]&n[(i+4)%10]}e[0]^=oo[s],e[1]^=co[s]}ve(n)}class Ut{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,s,r=!1,o=24){if(this.blockLen=t,this.suffix=n,this.outputLen=s,this.enableXOF=r,this.rounds=o,Ve(s,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Ae(this.state)}clone(){return this._cloneInto()}keccak(){q(this.state32),io(this.state32,this.rounds),q(this.state32),this.posOut=0,this.pos=0}update(t){qe(this),te(t);const{blockLen:n,state:s}=this,r=t.length;for(let o=0;o<r;){const c=Math.min(n-this.pos,r-o);for(let i=0;i<c;i++)s[this.pos++]^=t[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:s,blockLen:r}=this;t[s]^=n,(n&128)!==0&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){qe(this,!1),te(t),this.finish();const n=this.state,{blockLen:s}=this;for(let r=0,o=t.length;r<o;){this.posOut>=s&&this.keccak();const c=Math.min(s-this.posOut,o-r);t.set(n.subarray(this.posOut,this.posOut+c),r),this.posOut+=c,r+=c}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Ve(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Et(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,ve(this.state)}_cloneInto(t){const{blockLen:n,suffix:s,outputLen:r,rounds:o,enableXOF:c}=this;return t||=new Ut(n,s,r,c,o),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=s,t.outputLen=r,t.enableXOF=c,t.destroyed=this.destroyed,t}}const ir=((e,t,n,s={})=>It(()=>new Ut(t,e,n),s))(1,136,32),ar=e=>{const t=e.slice(2),n=re(ir(zn.encode(t))).slice(2),s=new Array(40);for(let r=0;r<40;r++){const o=parseInt(n[r],16),c=t[r];s[r]=o>7?c.toUpperCase():c}return`0x${s.join("")}`},ao=H(20)[1],lr=_(e=>{const t=Me(e);if(t.length!==20)throw new Error(`Invalid length found on EthAddress(${e})`);const n=re(t);if(e===n||e===n.toUpperCase())return t;if(ar(n)!==e)throw new Error(`Invalid checksum found on EthAddress(${e})`);return t},Be(e=>ar(re(ao(e))))),R=e=>L(b(e),e);R.enc=e=>L(b.enc(e),e),R.dec=e=>L(b.dec(e),e);const de=(...e)=>L(ee(...e),e);de.enc=(...e)=>L(ee.enc(...e),e),de.dec=(...e)=>L(ee.dec(...e),e);const W=(e,...t)=>L(I(e,...t),e);W.enc=(e,...t)=>L(I.enc(e,...t),e),W.dec=(e,...t)=>L(I.dec(e,...t),e);const ut=(e,t)=>L(Fe(e,t),{ok:e,ko:t});ut.enc=(e,t)=>L(Fe.enc(e,t),{ok:e,ko:t}),ut.dec=(e,t)=>L(Fe.dec(e,t),{ok:e,ko:t});const $e=e=>L(X(e),e);$e.enc=e=>L(X.enc(e),e),$e.dec=e=>L(X.dec(e),e);const ur=(e=!0)=>Be(t=>{const n=w.dec(t),s=Math.ceil(n/8),r=H(s).dec(t),o=new Array(n);let c=0;return r.forEach(i=>{for(let u=0;u<8&&c<n;u++){const a=e?u:7-u;o[c++]=i>>a&1}}),o}),hr=(e=!0)=>t=>{const n=w.enc(t.length),s=Math.ceil(t.length/8),r=new Uint8Array(s);for(let o=0;o<s;o++){let c=o*8,i=0;for(let u=0;u<8&&c<t.length;u++,c++)i|=t[c]<<(e?u:7-u);r[o]=i}return N([n,r])},ht=e=>_(hr(e),ur(e));ht.enc=hr,ht.dec=ur;const dr=new TextEncoder,fr=new TextDecoder,lo=oe(H(4),dr.encode.bind(dr),fr.decode.bind(fr)),Ot=R({engine:lo,payload:j()}),uo=Ce({other:H(),consensus:Ot,seal:Ot,preRuntime:Ot,runtimeUpdated:v},[0,4,5,6,8]),_t=j(32),ho=R({parentHash:_t,number:w,stateRoot:_t,extrinsicRoot:_t,digests:W(uo)}),Y=I(k),pr=X(k),fo=K({bool:v,char:v,str:v,u8:v,u16:v,u32:v,u64:v,u128:v,u256:v,i8:v,i16:v,i32:v,i64:v,i128:v,i256:v}),yr=I(b({name:pr,type:w,typeName:pr,docs:Y})),po=b({len:Z,type:w}),yo=b({bitStoreType:w,bitOrderType:w}),go=I(b({name:k,fields:yr,index:A,docs:Y})),vo=K({composite:yr,variant:go,sequence:w,array:po,tuple:I(w),primitive:fo,compact:w,bitSequence:yo}),mo=b({name:k,type:X(w)}),wo=I(mo),bo=b({id:w,path:Y,params:wo,def:vo,docs:Y}),dt=I(bo),Pe=K({NotDeprecated:v,DeprecatedWithoutNote:v,Deprecated:b({note:k,since:X(k)})}),xo=I(b({index:A,deprecation:K({DeprecatedWithoutNote:v,Deprecated:b({note:k,since:X(k)})},[1,2])})),St={name:k,inputs:I(b({name:k,type:w})),output:w,docs:Y},Eo=b({name:k,methods:I(b(St)),docs:Y}),Io=b({name:k,methods:I(b({...St,deprecationInfo:Pe})),docs:Y,version:w,deprecationInfo:Pe}),ko=b({id:j(32),...St,deprecationInfo:Pe}),Bo=K({Blake2128:v,Blake2256:v,Blake2128Concat:v,Twox128:v,Twox256:v,Twox64Concat:v,Identity:v}),Ao=I(Bo),Uo=b({hashers:Ao,key:w,value:w}),gr={name:k,modifier:A,type:K({plain:w,map:Uo}),fallback:j(),docs:Y},Tt=X(w),vr={name:k,storage:X(b({prefix:k,items:I(b(gr))})),calls:Tt,events:Tt,constants:I(b({name:k,type:w,value:j(),docs:Y})),errors:Tt,index:A},Oo={...vr,docs:Y},Dt=X(b({type:w,deprecationInfo:xo})),_o={name:k,storage:X(b({prefix:k,items:I(b({...gr,deprecationInfo:Pe}))})),calls:Dt,events:Dt,constants:I(b({name:k,type:w,value:j(),docs:Y,deprecationInfo:Pe})),errors:Dt,associatedTypes:I(b({name:k,type:w,docs:Y})),viewFns:I(ko),index:A,docs:Y,deprecationInfo:Pe},So=new Uint8Array,mr=e=>_(()=>So,()=>e),To=b({type:w,version:A,signedExtensions:I(b({identifier:k,type:w,additionalSigned:w}))}),wr=b({lookup:dt,pallets:I(b({...vr,docs:mr([])})),extrinsic:To,type:w,apis:mr([])}),Do=b({version:A,address:w,call:w,signature:w,extra:w,signedExtensions:I(b({identifier:k,type:w,additionalSigned:w}))}),br=b({lookup:dt,pallets:I(b(Oo)),extrinsic:Do,type:w,apis:I(Eo),outerEnums:b({call:w,event:w,error:w}),custom:I(ee(k,b({type:w,value:j()})))}),Lo=b({version:I(A),address:w,call:w,signature:w,signedExtensionsByVersion:I(ee(A,I(w))),signedExtensions:I(b({identifier:k,type:w,additionalSigned:w}))}),xr=b({lookup:dt,pallets:I(b(_o)),extrinsic:Lo,apis:I(Io),outerEnums:b({call:w,event:w,error:w}),custom:I(ee(k,b({type:w,value:j()})))}),Er=()=>{throw new Error("Unsupported metadata version!")},z=_(Er,Er),Ge=b({magicNumber:Z,metadata:K({v0:z,v1:z,v2:z,v3:z,v4:z,v5:z,v6:z,v7:z,v8:z,v9:z,v10:z,v11:z,v12:z,v13:z,v14:wr,v15:br,v16:xr})}),Lt=H(),Ho=X(Lt),Mo=ee(D,Lt),Ht=e=>{try{return Ge.dec(e)}catch{}try{return Ge.dec(Ho.dec(e))}catch{}try{return Ge.dec(Lt.dec(e))}catch{}try{return Ge.dec(Mo.dec(e)[1])}catch{}throw null},Mt=e=>{if("magicNumber"in e&&(e=e.metadata),"tag"in e){if(e.tag!=="v14"&&e.tag!=="v15"&&e.tag!=="v16")throw new Error("Only metadata 14, 15, and 16 are supported");e=e.value}if("signedExtensionsByVersion"in e.extrinsic)return{version:16,...e};if("custom"in e){const{lookup:r,extrinsic:o,custom:c,apis:i,pallets:u,outerEnums:a}=e;return{version:15,lookup:r,pallets:u.map(d=>({...d,calls:d.calls!=null?{type:d.calls}:void 0,events:d.events!=null?{type:d.events}:void 0,errors:d.errors!=null?{type:d.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...o,version:[o.version]},apis:i,outerEnums:a,custom:c}}const{lookup:t,extrinsic:n,pallets:s}=e;return{version:14,lookup:t,pallets:s.map(r=>({...r,calls:r.calls!=null?{type:r.calls}:void 0,events:r.events!=null?{type:r.events}:void 0,errors:r.errors!=null?{type:r.errors}:void 0,viewFns:[],associatedTypes:[]})),extrinsic:{...n,version:[n.version]},apis:[]}},_e={bare:0,0:"bare",general:1,1:"general",signed:2,2:"signed"},Vt=oe(A,({version:e,type:t})=>e+(_e[t]<<6),e=>{const t=e&63,n=e>>6;if(t===4&&(n===_e.bare||n===_e.signed))return{version:t,type:_e[n]};if(t===5&&(n===_e.bare||n===_e.general))return{version:t,type:_e[n]};throw new Error(`ExtrinsicFormat ${e} not valid`)}),Vo={dkLen:32},Je=e=>ot(e,Vo),Co={dkLen:16},Ct=e=>ot(e,Co),Ir=e=>N([Ct(e),e]),$o={dkLen:32},Ne=e=>Zs(e,$o),Po=e=>N([Ne(e),e]),kr=e=>e,Se=(e,t,n,s)=>new DataView(new Uint16Array([e,t,n,s]).buffer).getBigUint64(0,!0),$t=2n**64n-1n,F=(e,t)=>e<<t&$t|e>>64n-t,U=(e,t)=>e*t&$t,$=(e,t)=>e+t&$t,P=11400714785074694791n,G=14029467366897019727n,Br=1609587929392839161n,Qe=9650029242287828579n,Ar=2870177450012600261n;function Ee(e,t=0n){let n=$($(t,P),G),s=$(t,G),r=t,o=t-P,c=e.length,i=0,u=null;(function(){let h=0,p=h+c;if(c){if(u=new Uint8Array(32),c<32){u.set(e.subarray(0,c),i),i+=c;return}if(h<=p-32){const f=p-32;do{let m;m=Se(e[h+1]<<8|e[h],e[h+3]<<8|e[h+2],e[h+5]<<8|e[h+4],e[h+7]<<8|e[h+6]),n=U(F($(n,U(m,G)),31n),P),h+=8,m=Se(e[h+1]<<8|e[h],e[h+3]<<8|e[h+2],e[h+5]<<8|e[h+4],e[h+7]<<8|e[h+6]),s=U(F($(s,U(m,G)),31n),P),h+=8,m=Se(e[h+1]<<8|e[h],e[h+3]<<8|e[h+2],e[h+5]<<8|e[h+4],e[h+7]<<8|e[h+6]),r=U(F($(r,U(m,G)),31n),P),h+=8,m=Se(e[h+1]<<8|e[h],e[h+3]<<8|e[h+2],e[h+5]<<8|e[h+4],e[h+7]<<8|e[h+6]),o=U(F($(o,U(m,G)),31n),P),h+=8}while(h<=f)}h<p&&(u.set(e.subarray(h,p),i),i=p-h)}})(),e=u||e;let a,d=0;for(c>=32?(a=F(n,1n),a=$(a,F(s,7n)),a=$(a,F(r,12n)),a=$(a,F(o,18n)),n=U(F(U(n,G),31n),P),a=a^n,a=$(U(a,P),Qe),s=U(F(U(s,G),31n),P),a=a^s,a=$(U(a,P),Qe),r=U(F(U(r,G),31n),P),a=a^r,a=$(U(a,P),Qe),o=U(F(U(o,G),31n),P),a=a^o,a=$(U(a,P),Qe)):a=$(t,Ar),a=$(a,BigInt(c));d<=i-8;){let l=Se(e[d+1]<<8|e[d],e[d+3]<<8|e[d+2],e[d+5]<<8|e[d+4],e[d+7]<<8|e[d+6]);l=U(F(U(l,G),31n),P),a=$(U(F(a^l,27n),P),Qe),d+=8}if(d+4<=i){let l=U(Se(e[d+1]<<8|e[d],e[d+3]<<8|e[d+2],0,0),P);a=$(U(F(a^l,23n),G),Br),d+=4}for(;d<i;){const l=U(Se(e[d++],0,0,0),Ar);a=U(F(a^l,11n),P)}let y=a>>33n;return a=U(a^y,G),y=a>>29n,a=U(a^y,Br),y=a>>32n,a^=y,a}const ft=e=>{const t=new Uint8Array(16),n=new DataView(t.buffer);return n.setBigUint64(0,Ee(e),!0),n.setBigUint64(8,Ee(e,1n),!0),t},Ur=e=>{const t=new Uint8Array(32),n=new DataView(t.buffer);return n.setBigUint64(0,Ee(e),!0),n.setBigUint64(8,Ee(e,1n),!0),n.setBigUint64(16,Ee(e,2n),!0),n.setBigUint64(24,Ee(e,3n),!0),t},Or=e=>N([Re.enc(Ee(e)),e]),_r=new TextEncoder,No=new Map([[kr,0],[Or,8],[Ir,16],[Ct,-16],[Je,-32],[ft,-16],[Ur,-32]]),Sr=e=>{const t=ft(_r.encode(e));return(n,...s)=>{const r=N([t,ft(_r.encode(n))]),o=re(r),c=a=>{if(!a.startsWith(o))throw new Error(`key does not match this storage (${e}.${n})`);if(s.length===0)return[];const d=Me(a.slice(o.length)),y=new Array(s.length);for(let l=0,h=0;l<s.length;l++){const[p,f]=s[l],m=No.get(f);if(m==null)throw new Error("Unknown hasher");if(m<0){const x=m*-1;y[l]=re(d.slice(h,h+x)),h+=x}else h+=m,y[l]=p.dec(d.slice(h)),h+=p.enc(y[l]).length}return y},i=s.map(([{enc:a},d])=>y=>d(a(y)));return{enc:(...a)=>re(N([r,...a.map((d,y)=>i[y](d))])),dec:c}}},Ro=Xe.fromText("modlpy/utilisuba").asBytes(),Fo=({threshold:e,signatories:t})=>{const n=Tr(t),s=N([Ro,D.enc(n.length),...n,ie.enc(e)]);return Je(s)},Tr=e=>e.slice().sort((t,n)=>{for(let s=0;;s++){const r=s>=t.length,o=s>=n.length;if(r&&o)return 0;if(r)return-1;if(o)return 1;if(t[s]!==n[s])return t[s]>n[s]?1:-1}}),Ie={Leaf:"Leaf",Branch:"Branch",BranchWithVal:"BranchWithVal",LeafWithHash:"LeafWithHash",BranchWithHash:"BranchWithHash",Empty:"Empty",Reserved:"Reserved"},Dr=j().dec,qo=j(1/0).dec,jo=j(32).dec,Lr=A.dec,Wo=e=>{const t=Lr(e);let n=6;const s=t>>n,r=s?s===1?Ie.Leaf:s===2?Ie.Branch:Ie.BranchWithVal:t>>--n?Ie.LeafWithHash:t>>--n?Ie.BranchWithHash:t?Ie.Reserved:Ie.Empty;let o=t&255>>8-n;if(o===2**n-1){let c;do o+=c=Lr(e);while(c===255)}return{type:r,partialKey:j(Math.ceil(o/2)).dec(e).slice(o%2?3:2)}},Hr=Be(e=>{const t=Wo(e),{type:n}=t;if(n==="Empty"||n==="Reserved")return t;if(n==="Leaf"||n==="LeafWithHash")return{...t,value:qo(e)};const s=ie.dec(e),r=[];for(let i=0;i<16;i++)s>>i&1&&r.push(i.toString(16));let o=null;n==="BranchWithVal"&&(o=Dr(e)),n==="BranchWithHash"&&(o=jo(e));const c={...t,children:Object.fromEntries(r.map(i=>[i,Dr(e)]))};return o!==null&&(c.value=o),c}),Mr=e=>Be(t=>{const n=re(e(new Uint8Array(t.buffer)));try{return{hash:n,...Hr(t)}}catch{return{type:"Raw",hash:n,value:""}}});var Vr=Object.freeze({__proto__:null,AccountId:ct,Bin:ze,Binary:Xe,BitSeq:ht,Blake2128:Ct,Blake2128Concat:Ir,Blake2256:Je,Blake3256:Ne,Blake3256Concat:Po,Bytes:H,Enum:Bt,FixedSizeBinary:Fn,Hex:j,Identity:kr,Keccak256:ir,Option:$e,Result:ut,ScaleEnum:Oe,Self:Jn,Storage:Sr,Struct:R,TrieNodeHeaders:Ie,TrieNodeWithHash:Mr,Tuple:de,Twox128:ft,Twox256:Ur,Twox64Concat:Or,Variant:Ce,Vector:W,_Enum:Qs,_void:v,bitSequence:zs,blockHeader:ho,bool:cn,char:Ys,compact:D,compactBn:Wn,compactNumber:w,createCodec:_,createDecoder:Be,decAnyMetadata:Ht,enhanceCodec:oe,enhanceDecoder:wt,enhanceEncoder:mt,ethAccount:lr,extrinsicFormat:Vt,fixedStr:Js,fromBufferToBase58:Pn,getMultisigAccountId:Fo,getSs58AddressInfo:$n,h64:Ee,i128:tn,i16:Yt,i256:on,i32:Gt,i64:Jt,i8:zt,metadata:Ge,selfDecoder:Gn,selfEncoder:Yn,sortMultisigSignatories:Tr,str:k,trieNodeDec:Hr,u128:en,u16:ie,u256:sn,u32:Z,u64:Re,u8:A,unifyMetadata:Mt,v14:wr,v14Lookup:dt,v15:br,v16:xr,validateProofs:(e,t=Je)=>{const n=e.map(Mr(t)),s=Object.fromEntries(n.map(i=>[i.hash,i])),r=n.map(i=>i.hash),o=new Set(r),c=i=>{if(i.value)return;const u=e[r.indexOf(i.hash)];i.value=typeof u=="string"?u:re(u)};return n.forEach(i=>{if("children"in i&&Object.values(i.children).forEach(u=>{const a=s[u];a&&(a.parent=i.hash,o.delete(u))}),i.type==="BranchWithHash"||i.type==="LeafWithHash"){const u=i.value,a=s[u];if(!a)return;o.delete(u),a.type!=="Raw"&&(Object.keys(a).forEach(d=>delete a[d]),a.type="Raw",a.hash=u),a.parent=i.hash,c(a)}i.type==="Raw"&&c(i)}),o.size===1?{rootHash:o.values().next().value,proofs:s}:null}});const Cr=(e,t)=>e.type==="array"&&e.len===t&&e.value.type==="primitive"&&e.value.value==="u8",ke={type:"void"},Ko=(e,t=()=>null)=>{const n=new Map,s=new Set,r=d=>y=>{let l=n.get(y);if(l)return l;if(s.has(y)){const p={id:y};return n.set(y,p),p}s.add(y);const h=d(y);return l=n.get(y),l?Object.assign(l,h):(l={id:y,...h},n.set(y,l)),s.delete(y),l};let o=!0,c=!0;const i=r(d=>{const y=t(e[d]);if(y)return y;const{def:l,path:h,params:p}=e[d];if(l.tag==="composite"){if(l.value.length===0)return ke;if(l.value.length===1){const f=i(l.value[0].type);return o&&h.at(-1)==="AccountId32"&&Cr(f,32)?(o=!1,{type:"AccountId32"}):c&&h.at(-1)==="AccountId20"&&Cr(f,20)?(c=!1,{type:"AccountId20"}):f}return u(l.value)}if(l.tag==="variant"){if(h.length===1&&h[0]==="Option"&&p.length===1&&p[0].name==="T"){const x=i(p[0].type);return x.type==="void"?{type:"primitive",value:"bool"}:{type:"option",value:x}}if(h.length===1&&h[0]==="Result"&&p.length===2&&p[0].name==="T"&&p[1].name==="E")return{type:"result",value:{ok:i(p[0].type),ko:i(p[1].type)}};if(l.value.length===0)return ke;const f={},m={};return l.value.forEach(x=>{const B=x.name;if(m[B]=x.docs,x.fields.length===0){f[B]={...ke,idx:x.index};return}if(x.fields.length===1&&!x.fields[0].name){f[B]={type:"lookupEntry",value:i(x.fields[0].type),idx:x.index};return}f[B]={...u(x.fields),idx:x.index}}),{type:"enum",value:f,innerDocs:m}}if(l.tag==="sequence")return{type:"sequence",value:i(l.value)};if(l.tag==="array"){const{len:f}=l.value,m=i(l.value.type);return!f||m.type==="void"?ke:f>1?{type:"array",value:m,len:l.value.len}:m}if(l.tag==="tuple")return l.value.length===0?ke:l.value.length>1?a(l.value.map(f=>i(f)),l.value.map(f=>e[f].docs)):i(l.value[0]);if(l.tag==="primitive")return{type:"primitive",value:l.value.tag};if(l.tag==="compact"){const f=i(l.value);return f.type==="void"?ke:{type:"compact",isBig:Number(f.value.slice(1))>32,size:f.value}}return{type:l.tag,isLSB:(e[l.value.bitOrderType].path.at(-1)??"LSB").toUpperCase().startsWith("LSB")}}),u=d=>{let y=!0;const l={},h={};return d.forEach((p,f)=>{y=y&&!!p.name;const m=p.name||f,x=i(p.type);x.type!=="void"&&(l[m]=x,h[m]=p.docs)}),y?{type:"struct",value:l,innerDocs:h}:a(Object.values(l),Object.values(h))},a=(d,y)=>{if(d.every(l=>l.id===d[0].id)&&y.every(l=>!l.length)){const[l]=d;return l.type==="void"?ke:{type:"array",value:d[0],len:d.length}}return{type:"tuple",value:d,innerDocs:y}};return i},$r=e=>{const t=Ko(e.lookup,({def:r})=>{if(r.tag==="composite"){const o=n(r);if(o)return{type:"enum",innerDocs:{},value:Object.fromEntries(e.pallets.map(c=>[c.name,c.errors==null?{...ke,idx:c.index}:{type:"lookupEntry",value:t(c.errors.type),idx:c.index}])),byteLength:o}}return null});function n(r){if(!(r.value.length===2&&r.value[0].name==="index"&&r.value[1].name==="error"))return null;const c=t(r.value[0].type),i=t(r.value[1].type);return c.type==="primitive"&&c.value==="u8"&&i.type==="array"&&i.value.type==="primitive"&&i.value.value==="u8"?1+i.len:null}return Object.assign(t,{metadata:e,call:"call"in e.extrinsic?e.extrinsic.call:e.lookup[e.extrinsic.type]?.params.find(c=>c.name==="Call")?.type??null})},Xo=(e,t,n)=>(s,r,o,...c)=>{const{id:i}=s;if(r.has(i))return r.get(i);if(o.has(i)){const a=t(()=>r.get(i),s,...c);return r.set(i,a),a}o.add(i);let u=e(s,r,o,...c);return o.delete(i),r.has(i)&&(u=n(u,r.get(i),s,...c)),r.set(i,u),u},zo=ze(),Pr=Xo((e,t,n,s)=>{if(e.type==="primitive")return Vr[e.value];if(e.type==="void")return v;if(e.type==="AccountId32")return s;if(e.type==="AccountId20")return lr;if(e.type==="compact")return e.isBig?Wn:w;if(e.type==="bitSequence")return ht(e.isLSB);const r=h=>Pr(h,t,n,s),o=(h,p)=>{const f=r(h);return p?W(f,p):W(f)},c=h=>de(...h.map(r)),i=h=>{const p=Object.fromEntries(Object.entries(h).map(([f,m])=>[f,r(m)]));return R(p)};if(e.type==="sequence"&&e.value.type==="primitive"&&e.value.value==="u8")return zo;if(e.type==="array")return e.value.type==="primitive"&&e.value.value==="u8"?ze(e.len):o(e.value,e.len);if(e.type==="sequence")return o(e.value);if(e.type==="tuple")return c(e.value);if(e.type==="struct")return i(e.value);if(e.type==="option")return $e(r(e.value));if(e.type==="result")return ut(r(e.value.ok),r(e.value.ko));const u=Object.values(e.value).map(h=>{switch(h.type){case"void":return v;case"lookupEntry":return r(h.value);case"tuple":return c(h.value);case"struct":return i(h.value);case"array":return o(h.value,h.len)}}),a=Object.fromEntries(Object.keys(e.value).map((h,p)=>[h,u[p]])),d=Object.values(e.value).map(h=>h.idx),l=d.every((h,p)=>h===p)?Ce(a):Ce(a,d);return e.byteLength?Yo(l,e.byteLength):l},Jn,e=>e),Nr=(e,t=ct())=>{const n=new Map,s=r=>Pr(e(r),n,new Set,t);return r=>s(r)},Yo=(e,t)=>{const n=H(t);return _(s=>n.enc(e.enc(s)),s=>e.dec(n.dec(s)))},Go=oe(v,()=>{},()=>null),Jo=e=>{const{metadata:t}=e;let n=Nr(e);const s=t.pallets.find(l=>l.name==="System")?.constants.find(l=>l.name==="SS58Prefix");let r;if(s)try{const l=n(s.type).dec(s.value);typeof l=="number"&&(r=l,n=Nr(e,ct(l)))}catch{}const o=new Map,c=(l,h)=>{let p=o.get(l);p||o.set(l,p=Sr(l));const f=t.pallets.find(V=>V.name===l).storage.items.find(V=>V.name===h),m=V=>V===v?Go:V,x=(V,Te,...et)=>{const O=p(...et),[,...E]=et;return{args:de(...E.map(([C])=>C)),keys:O,value:Te,len:V,fallback:f.modifier===1?Te.dec(f.fallback):void 0}};if(f.type.tag==="plain")return x(0,m(n(f.type.value)),h);const{key:B,value:S,hashers:T}=f.type.value,J=m(n(S)),ne=T.map(V=>Vr[V.tag]),pe=(()=>{if(ne.length===1)return[[n(B),ne[0]]];const V=e(B);switch(V.type){case"array":return ne.map(Te=>[n(V.value.id),Te]);case"tuple":return V.value.map((Te,et)=>[n(Te.id),ne[et]]);default:throw new Error("Invalid key type")}})();return x(ne.length,J,h,...pe)},i=l=>{switch(l.type){case"void":return v;case"lookupEntry":return n(l.value.id);case"tuple":return de(...Object.values(l.value).map(h=>n(h.id)));case"struct":return R(gt(l.value,h=>n(h.id)));case"array":return W(n(l.value.id),l.len)}},u=(l,h)=>{const p=t.pallets.find(f=>f.name===l).constants.find(f=>f.name===h);return n(p.type)},a=l=>(h,p)=>{const f=t.pallets.find(B=>B.name===h),m=e(f[l].type);if(m.type!=="enum")throw null;const x=m.value[p];return{location:[f.index,x.idx],codec:i(m.value[p])}},d=(l,h)=>{const p=t.pallets.find(f=>f.name===l)?.viewFns.find(f=>f.name===h);if(!p)throw null;return{args:de(...p.inputs.map(f=>n(f.type))),value:n(p.output)}},y=(l,h)=>{const p=t.apis.find(f=>f.name===l)?.methods.find(f=>f.name===h);if(!p)throw null;return{args:de(...p.inputs.map(f=>n(f.type))),value:n(p.output)}};return{buildDefinition:n,buildStorage:c,buildEvent:a("events"),buildError:a("errors"),buildViewFn:d,buildRuntimeCall:y,buildCall:a("calls"),buildConstant:u,ss58Prefix:r}},Pt=()=>new Error("Unkown signer"),Qo=e=>{const{extrinsic:t}=e,n=$r(e);let s,r;if("address"in t)s=n(t.address),r=n(t.signature);else{const o=Object.fromEntries(e.lookup[t.type].params.filter(c=>c.type!=null).map(c=>[c.name,n(c.type)]));if(s=o.Address,r=o.Signature,!s||!r)throw Pt()}if(s.type==="AccountId20"&&r.type==="array"&&r.len===65&&r.value.type==="primitive"&&r.value.value==="u8")return[1,[]];if(r.type!=="enum"||["Ecdsa","Ed25519","Sr25519"].some(o=>!(o in r.value)))throw Pt();if(s.type==="enum"){const o=s.value.Id;if(o.type==="lookupEntry"&&o.value.type==="AccountId32")return[0,[o.idx]]}else if(s.type==="AccountId32")return[0,[]];throw Pt()},Zo={Ed25519:0,Sr25519:1,Ecdsa:2},ec=(e,t,n,s,r,o)=>{const[c,i]=Qo(e),u=N([Vt.enc({version:4,type:"signed"}),c===1?t:new Uint8Array([...i,...t]),c===1||!o?n:new Uint8Array([Zo[o],...n]),...s,r]);return N([D.enc(u.length),u])},[pt,Ze]=["<Bytes>","</Bytes>"].map(e=>Xe.fromText(e).asBytes()),tc=e=>async t=>{let n=!0,s;for(s=0;n&&s<pt.length;s++)n=pt[s]===t[s];n=n&&s===pt.length;const r=t.length-Ze.length;for(s=0;n&&s<Ze.length;s++)n=Ze[s]===t[r+s];return n=n&&s===Ze.length,e(n?t:N([pt,t,Ze]))},Rr={specVersion:Z,specName:k,base58Prefix:ie,decimals:A,tokenSymbol:k},Fr=R(Rr),Nt=H(32),nc=Oe({V0:v,V1:R({typeInformationTreeRoot:Nt,extrinsicMetadataHash:Nt,...Rr})});Oe({bool:v,char:v,str:v,u8:v,u16:v,u32:v,u64:v,u128:v,u256:v,i8:v,i16:v,i32:v,i64:v,i128:v,i256:v});const fe=Oe({bool:v,char:v,str:v,u8:v,u16:v,u32:v,u64:v,u128:v,u256:v,i8:v,i16:v,i32:v,i64:v,i128:v,i256:v,compactU8:v,compactU16:v,compactU32:v,compactU64:v,compactU128:v,compactU256:v,void:v,perId:w}),qr=R({name:$e(k),ty:fe,typeName:$e(k)}),rc=Oe({composite:W(qr),enumeration:R({name:k,fields:W(qr),index:w}),sequence:fe,array:R({len:Z,typeParam:fe}),tuple:W(fe),bitSequence:R({numBytes:A,leastSignificantBitFirst:cn})}),jr=R({path:W(k),typeDef:rc,typeId:w}),sc=W(jr),Rt=R({version:A,addressTy:fe,callTy:fe,signatureTy:fe,signedExtensions:W(R({identifier:k,includedInExtrinsic:fe,includedInSignedData:fe}))}),oc=de.dec(D[1],Vt[1],H(1/0)[1]);R({leaves:sc,leafIdxs:W(Z),proofs:W(Nt),extrinsic:Rt,info:Fr});const cc=(e,t)=>{const n=new Set,s=o=>{if(n.has(o))return;const{tag:c,value:i}=t.get(o).def;switch(c){case"composite":if(!i.length)break;n.add(o),i.forEach(({type:u})=>{s(u)});break;case"variant":if(!i.length)break;n.add(o),i.forEach(({fields:u})=>{u.forEach(({type:a})=>{s(a)})});break;case"tuple":if(!i.length)break;n.add(o),i.forEach(s);break;case"sequence":n.add(o),s(i);break;case"array":n.add(o),s(i.type);break;case"bitSequence":n.add(o)}};s(e.extrinsic.call),s(e.extrinsic.address),s(e.extrinsic.signature),e.extrinsic.signedExtensions.forEach(({type:o,additionalSigned:c})=>{s(o),s(c)});const r=[...n].sort((o,c)=>o-c);return new Map(r.map((o,c)=>[o,c]))},ic={u8:1,u16:2,u32:4,u64:8},ac=(e,t,n,s)=>{const{def:{tag:r,value:o}}=e.get(s);switch(r){case"composite":return[{tag:r,value:o.map(c=>({name:c.name,typeName:c.typeName,ty:t(c.type)}))}];case"variant":return o.map(c=>({tag:"enumeration",value:{name:c.name,index:c.index,fields:c.fields.map(i=>({name:i.name,typeName:i.typeName,ty:t(i.type)}))}}));case"sequence":return[{tag:r,value:t(o)}];case"array":return[{tag:r,value:{len:o.len,typeParam:t(o.type)}}];case"tuple":return[{tag:r,value:o.map(t)}];case"bitSequence":{const c=n(o.bitStoreType),i=ic[c];if(!i)throw new Error("Invalid primitive for BitSequence");const u=e.get(o.bitOrderType).path,a=u.includes("Lsb0");if(!a&&!u.includes("Msb0"))throw new Error("BitOrderType not recognized");return[{tag:"bitSequence",value:{numBytes:i,leastSignificantBitFirst:a}}]}}throw new Error(`FrameId(${s}) should have been filtered out`)},lc=(e,t,n,s)=>{const r=[];return[...t.entries()].forEach(([o,c])=>{const{path:i}=e.get(o);ac(e,n,s,o).forEach(u=>{r.push({path:i,typeId:c,typeDef:u})})}),r.sort((o,c)=>{if(o.typeId!==c.typeId)return o.typeId-c.typeId;if(o.typeDef.tag!=="enumeration"||c.typeDef.tag!=="enumeration")throw new Error("Found two types with same id");return o.typeDef.value.index-c.typeDef.value.index}),r},uc=e=>{try{const t=Mt(Ht(e));if(t.version<=14)throw new Error("Wrong metadata version");return t}catch(t){throw t||new Error("Unable to decode metadata")}},Wr=e=>typeof e=="string"?Me(e):e,hc={null:"void",u8:"compactU8",u16:"compactU16",u32:"compactU32",u64:"compactU64",u128:"compactU128",u256:"compactU256"},dc={bool:A,char:A,str:k,u8:A,u16:ie,u32:Z,u64:Re,u128:en,u256:sn,i8:zt,i16:Yt,i32:Gt,i64:Jt,i128:tn,i256:on,void:v,compactU8:D,compactU16:D,compactU32:D,compactU64:D,compactU128:D,compactU256:D},Kr=(e,t,n,s,r)=>{if(t.tag!=="perId"){dc[t.tag][1](e);return}const o=a=>{Kr(e,a,n,s,r)},c=n.get(t.value),[i]=c,u=s[i];switch(c.length===1&&r.add(i),u.typeDef.tag){case"enumeration":{const a=A.dec(e),[d,y]=c.map(l=>[s[l].typeDef,l]).find(([l])=>l.value.index===a);r.add(y),d.value.fields.forEach(({ty:l})=>{o(l)});break}case"sequence":{const a=D.dec(e);for(let d=0;d<a;d++)o(u.typeDef.value);break}case"array":{for(let a=0;a<u.typeDef.value.len;a++)o(u.typeDef.value.typeParam);break}case"composite":{u.typeDef.value.forEach(a=>{o(a.ty)});break}case"tuple":{u.typeDef.value.forEach(o);break}case"bitSequence":throw new Error("bitSequence is not supported")}},Xr=(e,t,n)=>{let s=new Uint8Array;Be(c=>{s=c})(e);const r=new Map;n.forEach((c,i)=>{const u=r.get(c.typeId);u?u.push(i):r.set(c.typeId,[i])});const o=new Set;return t.forEach(c=>{Kr(s,c,r,n,o)}),[...o].sort((c,i)=>c-i)},Ft=e=>Math.log2(e+1)|0,fc=(e,t)=>(e+1>>t)-1;function pc(e,t){const n=t.map(u=>e[u]),s=e.length-1,r=t.map(u=>s+u),o=[];if(r.length){const u=Ft(r.at(-1)),a=Math.pow(2,u)-1,d=r.findIndex(y=>y>=a);d>0&&(r.unshift(...r.splice(d)),n.unshift(...n.splice(d)))}let c=0;const i=u=>{if(c===r.length){o.push(u);return}const a=r[c];if(a===u){++c;return}const d=Ft(u),y=Ft(a);if(u!==fc(a,y-d)){o.push(u);return}const l=2*u+1;i(l),i(l+1)};return i(0),{leaves:n,leafIdxs:r,proofIdxs:o}}const qt=(e,t,n)=>{if(n!=null&&n!==t)throw new Error(`${e} not expected. Received ${n} expected ${t}`)},yc=(e,{decimals:t,tokenSymbol:n,...s})=>{const r=uc(e),o=r.extrinsic.version.includes(4)?4:null;if(o==null)throw new Error("Only extrinsic v4 is supported");const{ss58Prefix:c,buildDefinition:i}=Jo($r(r));if(c==null)throw new Error("SS58 prefix not found in metadata");qt("SS58 prefix",c,s.base58Prefix);const u=r.pallets.find(O=>O.name==="System")?.constants.find(O=>O.name==="Version");if(u==null)throw new Error("System.Version constant not found");const{spec_name:a,spec_version:d}=i(u.type).dec(u.value);if(typeof a!="string"||typeof d!="number")throw new Error("Spec name or spec version not found");qt("Spec name",a,s.specName),qt("Spec version",d,s.specVersion);const y={decimals:t,tokenSymbol:n,specVersion:d,specName:a,base58Prefix:c},l=new Map(r.lookup.map(O=>[O.id,O])),h=cc(r,l),p=O=>{const{def:{tag:E,value:C}}=l.get(O);if(E==="primitive")return C.tag;if(E!=="composite"&&E!=="tuple"||C.length>1)throw new Error("The provided definition doesn't map to a primitive");return C.length===0?null:p(E==="tuple"?C[0]:C[0].type)},f=O=>{const{def:E}=l.get(O);if(E.tag==="primitive")return{tag:E.value.tag,value:void 0};if(E.tag==="compact"){const C=p(E.value),ye=hc[C];if(!ye)throw new Error("Invalid primitive for Compact");return{tag:ye,value:void 0}}return h.has(O)?{tag:"perId",value:h.get(O)}:{tag:"void",value:void 0}},m={version:o,addressTy:f(r.extrinsic.address),callTy:f(r.extrinsic.call),signatureTy:f(r.extrinsic.signature),signedExtensions:r.extrinsic.signedExtensions.map(O=>({identifier:O.identifier,includedInExtrinsic:f(O.type),includedInSignedData:f(O.additionalSigned)}))},x=lc(l,h,f,p),B=x.map(jr.enc);let S;const T=()=>{if(S)return S;if(!B.length)return S=[new Uint8Array(32).fill(0)];S=new Array(B.length*2-1);let O=B.length-1;for(let E=0;E<B.length;E++)S[O+E]=Ne(B[E]);for(let E=S.length-2;E>0;E-=2)S[(E-1)/2]=Ne(N([S[E],S[E+1]]));return S};let J;const ne=()=>{if(J)return J;const E={tag:"V1",value:{typeInformationTreeRoot:T()[0],extrinsicMetadataHash:Ne(Rt.enc(m)),...y}};return J=Ne(nc.enc(E))},pe=O=>{const E=pc(B,O),C=T(),ye=E.proofIdxs.map(De=>C[De]);return N([D.enc(E.leaves.length),...E.leaves,D.enc(E.leafIdxs.length),...E.leafIdxs.map(De=>Z.enc(De)),D.enc(ye.length),...ye,Rt.enc(m),Fr.enc(y)])},V=O=>{const E=[m.callTy,...m.signedExtensions.map(C=>C.includedInExtrinsic),...m.signedExtensions.map(C=>C.includedInSignedData)];return pe(Xr(O,E,x))};return{digest:ne,getProofForExtrinsic:(O,E)=>{let[,{version:C,type:ye},De]=oc(O);if(C!==m.version)throw new Error("Incorrect extrinsic version");const Yr=ye==="signed"?[m.addressTy,m.signatureTy,...m.signedExtensions.map(Wt=>Wt.includedInExtrinsic),m.callTy]:[m.callTy];return E&&(De=N([De,Wr(E)]),Yr.push(...m.signedExtensions.map(Wt=>Wt.includedInSignedData))),pe(Xr(De,Yr,x))},getProofForExtrinsicParts:(O,E,C)=>{const ye=N([O,E,C].map(Wr));return V(ye)},getProofForExtrinsicPayload:V}};function gc(e,t,n){return{publicKey:e,signTx:async(r,o,c,i,u=Je)=>{const a=Mt(Ht(c)),d=[],y=[];a.extrinsic.signedExtensions.map(({identifier:p})=>{const f=o[p];if(!f)throw new Error(`Missing ${p} signed extension`);d.push(f.value),y.push(f.additionalSigned)});const l=N([r,...d,...y]),h=await n(l.length>256?u(l):l);return ec(a,e,h,d,r,t)},signBytes:tc(n)}}const jt="CheckMetadataHash",zr=Uint8Array.from([1]),vc=(e,t)=>({...t,signTx:async(n,s,r,...o)=>t.signTx(n,s[jt]?{...s,[jt]:{identifier:jt,value:zr,additionalSigned:N([zr,yc(r,e).digest()])}}:s,r,...o)});Le.getPolkadotSigner=gc,Le.withMetadataHash=vc}));
