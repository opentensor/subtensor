(function(R,h){typeof exports=="object"&&typeof module<"u"?h(exports):typeof define=="function"&&define.amd?define(["exports"],h):(R=typeof globalThis<"u"?globalThis:R||self,h(R.papiWsProvider={}))})(this,(function(R){"use strict";var h=(n=>(n[n.CONNECTING=0]="CONNECTING",n[n.CONNECTED=1]="CONNECTED",n[n.ERROR=2]="ERROR",n[n.CLOSE=3]="CLOSE",n))(h||{});const T=n=>JSON.stringify({jsonrpc:"2.0",...n});let J=0;const I=()=>`proxyOpaque${J++}`,M=()=>`___proxyInternalId__${I()}`,j=n=>{let e={type:1,activeBroadcasts:new Map,pending:[]};const a=s=>{let i=!0;if(e.type===0){const o=JSON.parse(s);if("id"in o){const{id:r}=o;if(e.pendingBroadcasts.has(r)){const d=e.pendingBroadcasts.get(r),c=o.result;e.pendingBroadcasts.delete(r),e.activeBroadcasts.get(d)?e.activeBroadcasts.get(d).upToken=c:e.connection.send(T({id:M(),method:"transaction_v1_stop",params:[c]}));return}i=e.onGoingRequests.has(r),"result"in o&&e.onGoingRequests.get(r)?.type===0&&e.activeChainHeads.add(o.result),e.onGoingRequests.delete(o.id)}else if("params"in o){const{subscription:r,result:d}=o.params;d?.event==="stop"&&e.activeChainHeads.delete(r)}}i&&e.type!==2&&n(s)},l=s=>{if(e.type===2)return;const i=JSON.parse(s);if("id"in i){const{method:o,id:r,params:d}=i,[c,,p]=o.split("_");if(c==="transaction"){if(p==="stop"){const[t]=d,u=e.activeBroadcasts.get(t);e.activeBroadcasts.delete(t),n(T({id:r,result:null})),e.type===0&&u&&u.upToken&&e.connection.send(T({id:r,method:o,params:[u.upToken]}));return}if(p==="broadcast"){const t=I();e.activeBroadcasts.set(t,{tx:d[0],synToken:t}),e.type===0&&(e.pendingBroadcasts.set(r,t),e.connection.send(s)),n(T({id:r,result:t}));return}}}if(e.type===1){e.pending.push(s);return}if(i.method==="chainHead_v1_unfollow"&&e.activeChainHeads.delete(i.params[0]),"id"in i){const{method:o,id:r}=i,[d,,c]=o.split("_"),p=d==="chainHead"?c==="follow"?{type:0,msg:s}:{type:1,id:r}:{type:2,msg:s};e.onGoingRequests.set(r,p)}e.connection.send(s)};return{send:l,disconnect:()=>{e.type!==2&&(e.type===0&&e.connection.disconnect(),e={type:2})},connect:s=>{if(e.type!==1)throw new Error("Nonesense");const{pending:i,activeBroadcasts:o}=e,r=new Map,d=new Set;e={type:0,connection:s(a,()=>{const p=e.type!==2?e.activeBroadcasts:new Map;p.forEach(t=>t.upToken=void 0),e={type:1,activeBroadcasts:p,pending:[]},d.forEach(t=>{a(T({params:{subscription:t,result:{event:"stop",internal:!0}}}))}),d.clear();for(const t of r.values())t.type===1?a(T({id:t.id,error:{code:-32603,message:"Internal error"},internal:!0})):l(t.msg);r.clear()}),activeBroadcasts:o,pendingBroadcasts:new Map,onGoingRequests:r,activeChainHeads:d},o.forEach(p=>{if(e.type===0){const t=M();e.pendingBroadcasts.set(t,p.synToken),l(T({id:t,method:"transaction_v1_broadcast",params:[p.tx]}))}}),i.forEach(l)}}},z=n=>e=>{let a=j(e);const l=()=>{n().then(s=>{if(a)a.connect((i,o)=>s(i,()=>{o(),l()}));else try{s(()=>{},()=>{}).disconnect()}catch{}},()=>{a&&setTimeout(l,0)})};return l(),{send:s=>{a?.send(s)},disconnect:()=>{a?.disconnect(),a=null}}},L={};["v1","unstable"].forEach(n=>{L[`chainHead_${n}_follow`]="follow",L[`chainHead_${n}_unfollow`]="unfollow"});const G=()=>({latest:Date.now(),count:0}),A=(n,e)=>{const a=new Set,l=new Map,s=new Set;let i,o=G();return Object.assign(d=>{const{send:c,disconnect:p}=n(t=>{const u=JSON.parse(t);if("id"in u){const{id:m,result:v}=u;if(m===i&&(i=void 0,v&&!v.methods.some(y=>{const[f,,b]=y.split("_");return f==="chainHead"&&b==="follow"}))){d(t),e();return}const g=l.get(m);if(g){if(l.delete(m),a.has(v)){a.delete(v);return}s.add(v);const y=s.size+l.size;if(y>2)console.warn(`Too many chainHead follow subscriptions (${y})`);else if(u.error){console.warn(`chainHead follow failed on the ${y} sub`),e(),l.set(m,g),c(g);return}}}else{const{subscription:m,result:v}=u.params;if(v?.event==="stop"){const g=Date.now()-o.latest;o.latest+=g,o.count=g<1e3?o.count+1:1,s.has(m)?s.delete(m):a.add(m)}}d(t),o.count>2&&(o=G(),e())});return{send(t){const u=JSON.parse(t);u.method==="rpc_methods"&&(i=u.id);const m=L[u.method];m==="follow"?l.set(u.id,t):m==="unfollow"&&s.delete(u.params[0]),c(t)},disconnect:p}},{cleanup:()=>{a.clear(),l.clear(),s.clear()}})},$={type:h.ERROR,event:{type:"timeout"}},_=()=>{},D={onStatusChanged:_,innerEnhancer:n=>n,timeout:5e3,heartbeatTimeout:4e4},P=n=>n.map(e=>typeof e=="string"?[e]:[e.uri,e.protocol]),F=(n,e)=>{const{onStatusChanged:a,innerEnhancer:l,timeout:s,heartbeatTimeout:i}={...D,...e},o=P(Array.isArray(n)?n:[n]),r=e?.websocketClass??globalThis.WebSocket;if(!r)throw new Error("Missing WebSocket class");let d=0,c,p=null,t=_,u=_;const m=A(z(async()=>{const[g,y]=p||o[d++%n.length];p=null;const f=new r(g,y),b=()=>{try{f.addEventListener("error",_,{once:!0}),f.close()}catch{}};a(c={type:h.CONNECTING,uri:g,protocols:y}),await new Promise((k,S)=>{const C=()=>{N(),k()},E=w=>{N(),w==null&&b(),console.error(`Unable to connect to ${g}${y?", protocols: "+y:""}`),a(c={type:w?h.ERROR:h.CLOSE,event:w}),setTimeout(S,w?300:0,w)},B=s!==1/0?setTimeout(()=>{N(),b(),a(c=$),S($.event)},s):void 0,N=()=>{clearTimeout(B),f.removeEventListener("error",E),f.removeEventListener("open",C)};f.addEventListener("open",C),f.addEventListener("error",E),t=()=>{E(null)}}),a(c={type:h.CONNECTED,uri:g,protocols:y});let q;const U=l(k=>(q=k,{send:S=>{f.send(S)},disconnect:()=>{t()}}));return(k,S)=>{let C;const E=()=>{clearTimeout(C),C=setTimeout(()=>{console.warn("Terminate: heartbeat timeout"),t(!0)},i)};E();const B=U(k),N=O=>{E(),typeof O.data=="string"&&q(O.data)},w=O=>W=>{clearTimeout(C),console.warn(`WS halt (${O})`),a(c={type:O,event:W}),S()},x=w(h.ERROR),H=w(h.CLOSE);return f.addEventListener("ping",E),f.addEventListener("message",N),f.addEventListener("error",x),f.addEventListener("close",H),t=O=>{clearTimeout(C),u(),t=_,f.removeEventListener("ping",E),f.removeEventListener("message",N),f.removeEventListener("error",x),f.removeEventListener("close",H),b(),O&&H({}),B.disconnect()},B}}),()=>{v()});u=m.cleanup,delete m.cleanup;const v=(...g)=>{c.type!==h.CLOSE&&(g.length&&(p=g),c.type!==h.ERROR&&t(!0))};return Object.assign(m,{switch:v,getStatus:()=>c})};R.WsEvent=h,R.getWsProvider=F}));
