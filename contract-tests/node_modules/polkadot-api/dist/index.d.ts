import { JsonRpcProvider } from '@polkadot-api/json-rpc-provider';
import { HexString, OpaqueKeyHash, Binary, SS58String, Enum, BlockHeader, Codec, FixedSizeBinary, ResultPayload } from '@polkadot-api/substrate-bindings';
export { AccountId, Binary, BlockHeader, Codec, Enum, EnumVariant, FixedSizeBinary, GetEnum, HexString, ResultPayload, SS58AddressInfo, SS58String, _Enum, getSs58AddressInfo } from '@polkadot-api/substrate-bindings';
import { BlockInfo, SystemEvent as SystemEvent$1 } from '@polkadot-api/observable-client';
export { BlockInfo, BlockNotPinnedError } from '@polkadot-api/observable-client';
import { ChainSpecData } from '@polkadot-api/substrate-client';
import { Observable } from 'rxjs';
import { CompatibilityLevel } from '@polkadot-api/metadata-compatibility';
export { CompatibilityLevel } from '@polkadot-api/metadata-compatibility';
import { DescriptorValues } from '@polkadot-api/codegen';
export { DescriptorValues } from '@polkadot-api/codegen';
import { PolkadotSigner } from '@polkadot-api/polkadot-signer';
export { PolkadotSigner } from '@polkadot-api/polkadot-signer';

type PlainDescriptor<T> = {
    _type?: T;
};
type StorageDescriptor<Args extends Array<any>, T, Optional extends true | false, Opaque extends string> = {
    _type: T;
    _args: Args;
    _optional: Optional;
    _Opaque: Opaque;
};
type TxDescriptor<Args extends {} | undefined> = {
    ___: Args;
};
type RuntimeDescriptor<Args extends Array<any>, T> = [Args, T];
type DescriptorEntry<T> = Record<string, Record<string, T>>;
type PalletsTypedef<St extends DescriptorEntry<StorageDescriptor<any, any, any, any>>, Tx extends DescriptorEntry<TxDescriptor<any>>, Ev extends DescriptorEntry<PlainDescriptor<any>>, Err extends DescriptorEntry<PlainDescriptor<any>>, Ct extends DescriptorEntry<PlainDescriptor<any>>, Vw extends DescriptorEntry<RuntimeDescriptor<any, any>>> = {
    __storage: St;
    __tx: Tx;
    __event: Ev;
    __error: Err;
    __const: Ct;
    __view: Vw;
};
type ApisTypedef<T extends DescriptorEntry<RuntimeDescriptor<any, any>>> = T;

type ChainDefinition = {
    descriptors: Promise<DescriptorValues> & {
        pallets: PalletsTypedef<any, any, any, any, any, any>;
        apis: ApisTypedef<any>;
    };
    asset: PlainDescriptor<any>;
    metadataTypes: Promise<Uint8Array>;
    getMetadata: () => Promise<Uint8Array>;
    genesis: HexString | undefined;
};
type BuildTuple<L extends number, E, R extends Array<E>> = R["length"] extends L ? R : BuildTuple<L, E, [E, ...R]>;
type UnwrapFixedSizeArray<T extends Array<any>> = T extends [] | [any, ...any[]] ? T : T extends FixedSizeArray<infer L, infer E> ? number extends L ? T : BuildTuple<L, E, []> : T;
type ApplyOpaque<Key extends Array<any>, Opaque> = {
    [K in keyof Key]: K extends Opaque ? OpaqueKeyHash : Key[K];
};
type ExtractStorage<T extends DescriptorEntry<StorageDescriptor<any, any, any, any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends StorageDescriptor<infer Key, infer Value, infer Optional, infer Opaque> ? {
            KeyArgs: UnwrapFixedSizeArray<Key>;
            KeyArgsOut: ApplyOpaque<UnwrapFixedSizeArray<Key>, Opaque>;
            Value: Value;
            IsOptional: Optional;
        } : unknown;
    };
};
type ExtractTx<T extends DescriptorEntry<TxDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends TxDescriptor<infer Args> ? Args : unknown;
    };
};
type ExtractPlain<T extends DescriptorEntry<PlainDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends PlainDescriptor<infer Value> ? Value : unknown;
    };
};
type ExtractRuntime<T extends DescriptorEntry<RuntimeDescriptor<any, any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends RuntimeDescriptor<infer Args, infer Value> ? {
            Args: Args;
            Value: Value;
        } : unknown;
    };
};
type ApisFromDef<T extends DescriptorEntry<RuntimeDescriptor<any, any>>> = ExtractRuntime<T>;
type QueryFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any, any>> = ExtractStorage<T["__storage"]>;
type TxFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any, any>> = ExtractTx<T["__tx"]>;
type EventsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any, any>> = ExtractPlain<T["__event"]>;
type ErrorsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any, any>> = ExtractPlain<T["__error"]>;
type ConstFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any, any>> = ExtractPlain<T["__const"]>;
type ViewFnsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any, any>> = ExtractRuntime<T["__view"]>;

declare class RuntimeToken<D = unknown> {
    private constructor();
    protected _runtime(value: D): void;
}
declare class CompatibilityToken<D = unknown> {
    private constructor();
    protected _compatibility(value: D): void;
}
interface CompatibilityFunctions<D> {
    /**
     * Returns the `CompatibilityLevel` for this call comparing the descriptors
     * generated on dev time with the current live metadata.
     */
    getCompatibilityLevel(): Promise<CompatibilityLevel>;
    /**
     * Returns the `CompatibilityLevel` for this call comparing the descriptors
     * generated on dev time with the current live metadata.
     *
     * @param compatibilityToken  CompatibilityToken awaited from
     *                            typedApi.compatibilityToken.
     */
    getCompatibilityLevel(compatibilityToken: CompatibilityToken<D>): CompatibilityLevel;
    /**
     * Returns whether this call is compatible based on the CompatibilityLevel
     * threshold.
     *
     * @param threshold  CompatibilityLevel threshold to use, inclusive.
     */
    isCompatible(threshold: CompatibilityLevel): Promise<boolean>;
    /**
     * Returns whether this call is compatible based on the CompatibilityLevel
     * threshold.
     *
     * @param threshold           CompatibilityLevel threshold to use,
     *                            inclusive.
     * @param compatibilityToken  CompatibilityToken awaited from
     *                            typedApi.compatibilityToken.
     */
    isCompatible(threshold: CompatibilityLevel, compatibilityToken: CompatibilityToken<D>): boolean;
}

type ConstantEntry<Unsafe, D, T> = Unsafe extends true ? {
    /**
     * Constants are simple key-value structures found in the runtime
     * metadata.
     *
     * @returns Promise that will resolve in the value of the constant.
     */
    (): Promise<T>;
    /**
     * @param runtimeToken  Token from got with `await
     *                      typedApi.runtimeToken`
     * @returns Synchronously returns value of the constant.
     */
    (runtimeToken: RuntimeToken): T;
} : {
    /**
     * Constants are simple key-value structures found in the runtime
     * metadata.
     *
     * @returns Promise that will resolve in the value of the constant.
     */
    (): Promise<T>;
    /**
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Synchronously returns value of the constant.
     */
    (compatibilityToken: CompatibilityToken): T;
} & CompatibilityFunctions<D>;

type EventPhase = {
    type: "ApplyExtrinsic";
    value: number;
} | {
    type: "Finalization";
} | {
    type: "Initialization";
};
type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{
    meta: {
        block: BlockInfo;
        phase: EventPhase;
    };
    payload: T;
}>;
type EvPull<T> = () => Promise<Array<{
    meta: {
        block: BlockInfo;
        phase: EventPhase;
    };
    payload: T;
}>>;
type EvFilter<T> = (collection: SystemEvent["event"][]) => Array<T>;
type EvClient<Unsafe, D, T> = {
    /**
     * Multicast and stateful Observable watching for new events (matching the
     * event kind chosen) in the latest known `finalized` block.
     *
     * @param filter  Optional filter function to only emit events complying
     *                with the function.
     */
    watch: EvWatch<T>;
    /**
     * Fetch (Promise-based) all events (matching the event kind chosen) available
     * in the latest known `finalized` block.
     */
    pull: EvPull<T>;
    /**
     * Filter a bunch of `SystemEvent` and return the decoded `payload` of every
     * of them.
     *
     * @param collection  Array of `SystemEvent` to filter.
     */
    filter: EvFilter<T>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);
type SystemEvent = {
    phase: EventPhase;
    event: {
        type: string;
        value: {
            type: string;
            value: any;
        };
    };
    topics: Array<any>;
};

type WithCallOptions$2<Args extends Array<any>> = Args["length"] extends 0 ? [options?: PullOptions] : [...args: Args, options?: PullOptions];
type RuntimeCall<Unsafe, D, Args extends Array<any>, Payload> = {
    /**
     * Get `Payload` (Promise-based) for the runtime call.
     *
     * @param args  All keys needed for that runtime call.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    (...args: WithCallOptions$2<Args>): Promise<Payload>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);

type WithCallOptions$1<Args extends Array<any>> = [
    ...args: Args,
    options?: PullOptions
];
type WithWatchOptions<Args extends Array<any>> = [
    ...args: Args,
    options?: {
        at: "best";
    }
];
type PossibleParents<A extends Array<any>> = A extends [...infer Left, any] ? Left | PossibleParents<Left> : ArrayPossibleParents<A>;
type AllPermutations<A extends Array<any>> = PossibleParents<A> | A;
type ArrayPossibleParents<A extends Array<any>, Count extends Array<any> = [], R = []> = A extends Array<infer T> & {
    length: infer L;
} ? number extends L ? Array<T> : L extends Count["length"] ? R : ArrayPossibleParents<A, [...Count, T], R | Count> : never;
type GetKey<Args extends Array<any>, Unsafe> = Unsafe extends true ? {
    /**
     * Get the storage-key for this storage entry.
     *
     * @param args  All keys needed for that storage entry.
     * @returns Promise that will resolve the hexadecimal value of the
     *          storage key.
     */
    (...args: AllPermutations<Args>): Promise<HexString>;
    /**
     * Get the storage-key for this storage entry.
     *
     * @param ...args       All keys needed for that storage entry.
     * @param runtimeToken  Token from got with `await
     *                      typedApi.runtimeToken`
     * @returns Synchronously returns the hexadecimal value of the
     *          storage key.
     */
    (...args: [...AllPermutations<Args>, runtimeToken: RuntimeToken]): HexString;
} : {
    /**
     * Get the storage-key for this storage entry.
     *
     * @param args  All keys needed for that storage entry.
     * @returns Promise that will resolve the hexadecimal value of the
     *          storage key.
     */
    (...args: AllPermutations<Args>): Promise<HexString>;
    /**
     * Get the storage-key for this storage entry.
     *
     * @param ...args             All keys needed for that storage entry.
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Synchronously returns the hexadecimal value of the
     *          storage key.
     */
    (...args: [
        ...AllPermutations<Args>,
        compatibilityToken: CompatibilityToken
    ]): HexString;
};
type StorageEntryWithoutKeys<Unsafe, D, Payload> = {
    /**
     * Get `Payload` (Promise-based) for the storage entry.
     *
     * @param options  Optionally set which block to target (latest known
     *                 finalized is the default) and an AbortSignal.
     */
    getValue: (options?: PullOptions) => Promise<Payload>;
    /**
     * Watch changes in `Payload` (observable-based) for the storage entry.
     *
     * @param bestOrFinalized  Optionally choose which block to query and watch
     *                         changes, `best` or `finalized` (default)
     */
    watchValue: (bestOrFinalized?: "best" | "finalized") => Observable<Payload>;
    getKey: GetKey<[], Unsafe>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);
type StorageEntryWithKeys<Unsafe, D, Args extends Array<any>, Payload, ArgsOut extends Array<any>> = {
    /**
     * Get `Payload` (Promise-based) for the storage entry with a specific set of
     * `Args`.
     *
     * @param args  All keys needed for that storage entry.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    getValue: (...args: [...WithCallOptions$1<Args>]) => Promise<Payload>;
    /**
     * Watch changes in `Payload` (observable-based) for the storage entry.
     *
     * @param args  All keys needed for that storage entry.
     *              At the end, optionally choose which block to query and
     *              watch changes, `best` or `finalized` (default)
     */
    watchValue: (...args: [...Args, bestOrFinalized?: "best" | "finalized"]) => Observable<Payload>;
    /**
     * Get an Array of `Payload` (Promise-based) for the storage entry with
     * several sets of `Args`.
     *
     * @param keys     Array of sets of keys needed for the storage entry.
     * @param options  Optionally set which block to target (latest known
     *                 finalized is the default) and an AbortSignal.
     */
    getValues: (keys: Array<[...Args]>, options?: PullOptions) => Promise<Array<Payload>>;
    /**
     * Get an Array of `Payload` (Promise-based) for the storage entry with a
     * subset of `Args`.
     *
     * @param args  Subset of keys needed for the storage entry.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     * @example
     *
     *   // this is a query with 3 keys
     *   typedApi.query.Pallet.Query.getEntries({ at: "best" }) // no keys
     *   typedApi.query.Pallet.Query.getEntries(arg1, { at: "finalized" }) // 1/3 keys
     *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: "0x12345678" }) // 2/3 keys
     *
     */
    getEntries: (...args: WithCallOptions$1<PossibleParents<Args>>) => Promise<Array<{
        keyArgs: ArgsOut;
        value: NonNullable<Payload>;
    }>>;
    /**
     * Watch changes (Observable-based) for the storage entries with a subset of
     * `Args`.
     *
     * @param args  Subset of keys needed for the storage entry.
     *              At the end, optionally set whether to watch against the
     *              `best` block.
     *              By default watches changes against the finalized block.
     *              When watching changes against the "best" block, this API
     *              gratiously handles the re-orgs and provides the deltas
     *              based on the latest emission.
     *              The observed value contains the following properties:
     *              - `block`: the block in where the `deltas` took place -
     *              `deltas`: `null` indicates that nothing has changed from
     *              the latest emission.
     *              If the value is not `null` then the `deleted` and `upsrted`
     *              properties indicate the entries that have changed.
     *              - `entries`: it's an immutable data-structure with the
     *              latest entries.
     * @example
     *
     *   typedApi.query.Staking.Nominators.watchEntries()
     *   typedApi.query.Staking.Nominators.watchEntries({ at: "best" })
     *
     */
    watchEntries: (...args: WithWatchOptions<PossibleParents<Args>>) => Observable<{
        block: BlockInfo;
        deltas: null | {
            deleted: Array<{
                args: ArgsOut;
                value: NonNullable<Payload>;
            }>;
            upserted: Array<{
                args: ArgsOut;
                value: NonNullable<Payload>;
            }>;
        };
        entries: Array<{
            args: ArgsOut;
            value: NonNullable<Payload>;
        }>;
    }>;
    getKey: GetKey<Args, Unsafe>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);
type StorageEntry<Unsafe, D, Args extends Array<any>, ArgsOut extends Array<any>, Payload> = Args extends [] ? StorageEntryWithoutKeys<Unsafe, D, Payload> : StorageEntryWithKeys<Unsafe, D, Args, Payload, ArgsOut>;

type TxEvent = TxSigned | TxBroadcasted | TxBestBlocksState | TxFinalized;
type TxBroadcastEvent = TxSigned | TxBroadcasted | TxBestBlocksState | TxFinalized;
type TxSigned = {
    type: "signed";
    txHash: HexString;
};
type TxBroadcasted = {
    type: "broadcasted";
    txHash: HexString;
};
type TxBestBlocksState = {
    type: "txBestBlocksState";
    txHash: HexString;
} & (TxInBestBlocksNotFound | TxInBestBlocksFound);
type TxInBestBlocksNotFound = {
    found: false;
    isValid: boolean;
};
type TxInBestBlocksFound = {
    found: true;
} & TxEventsPayload;
type EventWithTopics = SystemEvent$1["event"] & {
    topics: SystemEvent$1["topics"];
};
type TxEventsPayload = {
    /**
     * Verify if extrinsic was successful, i.e. check if `System.ExtrinsicSuccess`
     * is found.
     */
    ok: boolean;
    /**
     * Array of all events emitted by the tx. Ordered as they are emitted
     * on-chain.
     */
    events: Array<EventWithTopics>;
    /**
     * Block information where the tx is found. `hash` of the block, `number` of
     * the block, `index` of the tx in the block.
     */
    block: {
        hash: string;
        number: number;
        index: number;
    };
} & ({
    ok: true;
    /**
     * Dispatch Error found at `System.ExtrinsicFailed` event.
     */
    dispatchError?: undefined;
} | {
    ok: false;
    /**
     * Dispatch Error found at `System.ExtrinsicFailed` event.
     */
    dispatchError: {
        type: string;
        value: unknown;
    };
});
type TxFinalized = {
    type: "finalized";
    txHash: HexString;
} & TxEventsPayload;
type TxFinalizedPayload = {
    txHash: HexString;
} & TxEventsPayload;
type CustomSignedExtensionValues = {
    value: any;
    additionalSigned: any;
} | {
    value: any;
} | {
    additionalSigned: any;
};
type TxOptions<Asset> = Partial<void extends Asset ? {
    /**
     * Block to target the transaction against. Default: `"finalized"`
     */
    at: HexString | "best" | "finalized";
    /**
     * Tip in fundamental units. Default: `0`
     */
    tip: bigint;
    /**
     * Mortality of the transaction. Default: `{ mortal: true, period: 64 }`
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
    };
    /**
     * Custom nonce for the transaction. Default: retrieve from latest known
     * finalized block.
     */
    nonce: number;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the
     * value is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using
     * its dynamic codecs. At least one of the 2 values must be included
     * into the signed-extension Object.
     */
    customSignedExtensions: Record<string, CustomSignedExtensionValues>;
} : {
    /**
     * Block to target the transaction against. Default: `"finalized"`
     */
    at: HexString | "best" | "finalized";
    /**
     * Tip in fundamental units. Default: `0n`
     */
    tip: bigint;
    /**
     * Mortality of the transaction. Default: `{ mortal: true, period: 64 }`
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
    };
    /**
     * Custom nonce for the transaction. Default: retrieve from latest known
     * finalized block.
     */
    nonce: number;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the
     * value is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using
     * its dynamic codecs. At least one of the 2 values must be included
     * into the signed-extension Object.
     */
    customSignedExtensions: Record<string, CustomSignedExtensionValues>;
    /**
     * Asset information to pay fees, tip, etc. By default it'll use the
     * native token of the chain.
     */
    asset?: Asset;
}>;
type OfflineTxExtensions<Asset> = void extends Asset ? {
    /**
     * Nonce for the signer of the transaction.
     */
    nonce: number;
    /**
     * Mortality of the transaction.
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
        startAtBlock: {
            height: number;
            hash: HexString;
        };
    };
    /**
     * Tip in fundamental units. Default: `0n`
     */
    tip?: bigint;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the value
     * is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using its
     * dynamic codecs. At least one of the 2 values must be included into the
     * signed-extension Object.
     */
    customSignedExtensions?: Record<string, CustomSignedExtensionValues>;
} : {
    /**
     * Nonce for the signer of the transaction.
     */
    nonce: number;
    /**
     * Mortality of the transaction.
     */
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
        startAtBlock: {
            height: number;
            hash: HexString;
        };
    };
    /**
     * Tip in fundamental units. Default: `0n`
     */
    tip?: bigint;
    /**
     * Custom values for chains that have custom signed-extensions.
     * The key of the Object should be the signed-extension name and the value
     * is an Object that accepts 2 possible keys: one for `value`
     * and the other one for `additionallySigned`. They both receive either
     * the encoded value as a `Uint8Array` that should be used for the
     * signed-extension, or the decoded value that PAPI will encode using its
     * dynamic codecs. At least one of the 2 values must be included into the
     * signed-extension Object.
     */
    customSignedExtensions?: Record<string, CustomSignedExtensionValues>;
    /**
     * Asset information to pay fees, tip, etc. By default it'll use the
     * native token of the chain.
     */
    asset?: Asset;
};
type TxPromise<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Promise<TxFinalizedPayload>;
type TxObservable<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Observable<TxEvent>;
interface TxCall {
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @returns Promise resolving in the encoded data.
     */
    (): Promise<Binary>;
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Synchronously returns encoded data.
     */
    (compatibilityToken: CompatibilityToken): Binary;
}
interface UnsafeTxCall {
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @returns Promise resolving in the encoded data.
     */
    (): Promise<Binary>;
    /**
     * SCALE-encoded callData of the transaction.
     *
     * @param runtimeToken  Token from got with `await typedApi.runtimeToken`
     * @returns Synchronously returns encoded data.
     */
    (runtimeToken: RuntimeToken): Binary;
}
type TxSignFn<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Promise<HexString>;
type PaymentInfo = {
    weight: {
        ref_time: bigint;
        proof_size: bigint;
    };
    class: Enum<{
        Normal: undefined;
        Operational: undefined;
        Mandatory: undefined;
    }>;
    partial_fee: bigint;
};
type InnerTransaction<Unsafe, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = {
    /**
     * Pack the transaction, sends it to the signer, and return the signature
     * asynchronously. If the signer fails (or the user cancels the signature)
     * it'll throw an error.
     *
     * @param from       `PolkadotSigner`-compliant signer.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Encoded `SignedExtrinsic` ready for broadcasting.
     */
    sign: TxSignFn<Asset>;
    /**
     * Observable-based all-in-one transaction submitting. It will sign,
     * broadcast, and track the transaction. The observable is singlecast, i.e.
     * it will sign, broadcast, etc at every subscription. It will complete once
     * the transaction is found in a `finalizedBlock`.
     *
     * @param from       `PolkadotSigner`-compliant signer.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Observable to the transaction.
     */
    signSubmitAndWatch: TxObservable<Asset>;
    /**
     * Pack the transaction, sends it to the signer, broadcast, and track the
     * transaction. The promise will resolve as soon as the transaction in found
     * in a `finalizedBlock`. If the signer fails (or the user cancels the
     * signature), or the transaction becomes invalid it'll throw an error.
     *
     * @param from       `PolkadotSigner`-compliant signer.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Finalized transaction information.
     */
    signAndSubmit: TxPromise<Asset>;
    /**
     * SCALE-encoded callData of the transaction.
     */
    getEncodedData: Unsafe extends true ? UnsafeTxCall : TxCall;
    /**
     * Estimate fees against the latest known `finalizedBlock`
     *
     * @param from       Public key or address from the potencial sender.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns Fees in fundamental units.
     */
    getEstimatedFees: (from: Uint8Array | SS58String, txOptions?: TxOptions<Asset>) => Promise<bigint>;
    /**
     * Payment info against the latest known `finalizedBlock`
     *
     * @param from       Public key or address from the potencial sender.
     * @param txOptions  Optionally pass any number of txOptions.
     * @returns PaymentInfo for the given transaction (weight, estimated fees
     *          and class).
     */
    getPaymentInfo: (from: Uint8Array | SS58String, txOptions?: TxOptions<Asset>) => Promise<PaymentInfo>;
    /**
     * PAPI way of expressing an extrinsic with arguments.
     * It's useful to pass as a parameter to extrinsics that accept calls.
     */
    decodedCall: Enum<{
        [P in Pallet]: Enum<{
            [N in Name]: Arg;
        }>;
    }>;
};
type Transaction<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTransaction<false, Arg, Pallet, Name, Asset>;
type UnsafeTransaction<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTransaction<true, Arg, Pallet, Name, Asset>;
type InnerTxEntry<Unsafe, D, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = Unsafe extends true ? {
    /**
     * Synchronously create the transaction object ready to sign, submit,
     * estimate fees, etc.
     *
     * @param args  All parameters required by the transaction.
     * @returns Transaction object.
     */
    (...args: Arg extends undefined ? [] : [data: Arg]): UnsafeTransaction<Arg, Pallet, Name, Asset>;
} : {
    /**
     * Synchronously create the transaction object ready to sign, submit,
     * estimate fees, etc.
     *
     * @param args  All parameters required by the transaction.
     * @returns Transaction object.
     */
    (...args: Arg extends undefined ? [] : [data: Arg]): Transaction<Arg, Pallet, Name, Asset>;
} & CompatibilityFunctions<D>;
type OfflineTxEntry<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = (input: Arg) => {
    /**
     * Pack the transaction, sends it to the signer, and return the signature
     * asynchronously. If the signer fails (or the user cancels the signature)
     * it'll throw an error.
     *
     * @param from        `PolkadotSigner`-compliant signer.
     * @param extensions  Information needed for the transaction extensions
     *                    that will be signed.
     * @returns Encoded `SignedExtrinsic` ready for broadcasting.
     */
    sign: (from: PolkadotSigner, extensions: OfflineTxExtensions<Asset>) => Promise<HexString>;
    /**
     * SCALE-encoded callData of the transaction.
     */
    encodedData: Binary;
    /**
     * PAPI way of expressing an extrinsic with arguments.
     * It's useful to pass as a parameter to extrinsics that accept calls.
     */
    decodedCall: Enum<{
        [P in Pallet]: Enum<{
            [N in Name]: Arg;
        }>;
    }>;
};
type TxEntry<D, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTxEntry<false, D, Arg, Pallet, Name, Asset>;
type UnsafeTxEntry<D, Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = InnerTxEntry<true, D, Arg, Pallet, Name, Asset>;
type TxFromBinary<Unsafe, Asset> = Unsafe extends true ? {
    /**
     * Asynchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData  SCALE-encoded call data.
     * @returns Transaction object.
     */
    (callData: Binary): Promise<UnsafeTransaction<any, string, string, Asset>>;
    /**
     * Synchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData      SCALE-encoded call data.
     * @param runtimeToken  Token from got with `await
     *                      typedApi.runtimeToken`
     * @returns Transaction object.
     */
    (callData: Binary, runtimeToken: RuntimeToken): UnsafeTransaction<any, string, string, Asset>;
} : {
    /**
     * Asynchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData  SCALE-encoded call data.
     * @returns Transaction object.
     */
    (callData: Binary): Promise<Transaction<any, string, string, Asset>>;
    /**
     * Synchronously create the transaction object from a binary call data
     * ready to sign, submit, estimate fees, etc.
     *
     * @param callData            SCALE-encoded call data.
     * @param compatibilityToken  Token from got with `await
     *                            typedApi.compatibilityToken`
     * @returns Transaction object.
     */
    (callData: Binary, compatibilityToken: CompatibilityToken): Transaction<any, string, string, Asset>;
};

declare class InvalidTxError extends Error {
    error: any;
    constructor(e: any);
}

type WithCallOptions<Args extends Array<any>> = Args["length"] extends 0 ? [options?: PullOptions] : [...args: Args, options?: PullOptions];
type ViewFn<Unsafe, D, Args extends Array<any>, Payload> = {
    /**
     * Get `Payload` (Promise-based) for the view function.
     *
     * @param args  All keys needed for that runtime call.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    (...args: WithCallOptions<Args>): Promise<Payload>;
} & (Unsafe extends true ? {} : CompatibilityFunctions<D>);

type StorageApi<Unsafe, D, A extends Record<string, Record<string, {
    KeyArgs: Array<any>;
    KeyArgsOut: Array<any>;
    Value: any;
    IsOptional: false | true;
} | unknown>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {
            KeyArgs: Array<any>;
            KeyArgsOut: Array<any>;
            Value: any;
            IsOptional: false | true;
        } ? StorageEntry<Unsafe, D, A[K][KK]["KeyArgs"], A[K][KK]["KeyArgsOut"], A[K][KK]["IsOptional"] extends true ? A[K][KK]["Value"] | undefined : A[K][KK]["Value"]> : unknown;
    };
};
type RuntimeCallsApi<Unsafe, D, A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {
            Args: Array<any>;
            Value: any;
        } ? RuntimeCall<Unsafe, D, A[K][KK]["Args"], A[K][KK]["Value"]> : unknown;
    };
};
type ViewFnApi<Unsafe, D, A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {
            Args: Array<any>;
            Value: any;
        } ? ViewFn<Unsafe, D, A[K][KK]["Args"], A[K][KK]["Value"]> : unknown;
    };
};
type TxApi<Unsafe, D, A extends Record<string, Record<string, any>>, Asset> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {} | undefined ? InnerTxEntry<Unsafe, D, A[K][KK], K & string, KK & string, Asset> : unknown;
    };
};
type OfflineTxApi<A extends Record<string, Record<string, any>>, Asset> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {} | undefined ? OfflineTxEntry<A[K][KK], K & string, KK & string, Asset> : unknown;
    };
};
type EvApi<Unsafe, D, A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: EvClient<Unsafe, D, A[K][KK]>;
    };
};
type ConstApi<Unsafe, D, A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: ConstantEntry<Unsafe, D, A[K][KK]>;
    };
};
type OfflineConstApi<A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK];
    };
};
type UnsafeEntry<T> = Record<string, Record<string, T>>;
type AnyApi<Unsafe extends true | false, D> = D extends ChainDefinition ? {
    query: StorageApi<Unsafe, D, QueryFromPalletsDef<D["descriptors"]["pallets"]>>;
    tx: TxApi<Unsafe, D, TxFromPalletsDef<D["descriptors"]["pallets"]>, D["asset"]["_type"]>;
    txFromCallData: TxFromBinary<Unsafe, D["asset"]["_type"]>;
    event: EvApi<Unsafe, D, EventsFromPalletsDef<D["descriptors"]["pallets"]>>;
    apis: RuntimeCallsApi<Unsafe, D, ApisFromDef<D["descriptors"]["apis"]>>;
    constants: ConstApi<Unsafe, D, ConstFromPalletsDef<D["descriptors"]["pallets"]>>;
    view: ViewFnApi<Unsafe, D, ViewFnsFromPalletsDef<D["descriptors"]["pallets"]>>;
} : {
    query: UnsafeEntry<StorageEntryWithKeys<true, D, any, any, any>>;
    tx: UnsafeEntry<UnsafeTxEntry<D, any, string, string, any>>;
    txFromCallData: TxFromBinary<Unsafe, any>;
    event: UnsafeEntry<EvClient<true, D, any>>;
    apis: UnsafeEntry<RuntimeCall<true, D, any, any>>;
    constants: UnsafeEntry<ConstantEntry<true, D, any>>;
    view: UnsafeEntry<ViewFn<true, D, any, any>>;
};
type TypedApi<D extends ChainDefinition> = AnyApi<false, D> & {
    compatibilityToken: Promise<CompatibilityToken<D>>;
};
type OfflineApi<D extends ChainDefinition> = {
    constants: OfflineConstApi<ConstFromPalletsDef<D["descriptors"]["pallets"]>>;
    tx: OfflineTxApi<TxFromPalletsDef<D["descriptors"]["pallets"]>, D["asset"]["_type"]>;
};
type UnsafeApi<D> = AnyApi<true, D> & {
    runtimeToken: Promise<RuntimeToken<D>>;
};
type TransactionValidityError<D extends ChainDefinition> = (D["descriptors"]["apis"]["TaggedTransactionQueue"]["validate_transaction"][1] & {
    success: false;
})["value"];
interface PolkadotClient {
    /**
     * Retrieve the ChainSpecData as it comes from the [JSON-RPC
     * spec](https://paritytech.github.io/json-rpc-interface-spec/api/chainSpec.html)
     */
    getChainSpecData: () => Promise<ChainSpecData>;
    /**
     * Retrieves the most modern stable version of the metadata for a given block.
     *
     * @param atBlock  The block-hash of the block.
     * @returns Observable that emits the most modern stable version of the
     *          metadata, and immediately completes.
     */
    getMetadata$: (atBlock: HexString) => Observable<Uint8Array>;
    /**
     * Retrieves the most modern stable version of the metadata for a given block.
     *
     * @param atBlock  The block-hash of the block.
     * @returns An abortable Promise that resolves into the most modern
     *          stable version of the metadata.
     */
    getMetadata: (atBlock: HexString, signal?: AbortSignal) => Promise<Uint8Array>;
    /**
     * Observable that emits `BlockInfo` for every new finalized block. It's a
     * multicast and stateful observable, that will synchronously replay its
     * latest known state.
     */
    finalizedBlock$: Observable<BlockInfo>;
    /**
     * @returns Latest known finalized block.
     */
    getFinalizedBlock: () => Promise<BlockInfo>;
    /**
     * Observable that emits an Array of `BlockInfo`, being the first element the
     * latest known best block, and the last element the latest known finalized
     * block. It's a multicast and stateful observable, that will synchronously
     * replay its latest known state. This array is an immutable data structure;
     * i.e. a new array is emitted at every event but the reference to its
     * children are stable if the children didn't change.
     *
     * Note that some blocks might not get reported, e.g. if they become finalized
     * immediately without being part of the best block chain.
     */
    bestBlocks$: Observable<BlockInfo[]>;
    /**
     * @returns Array of `BlockInfo`, being the first element the latest
     *          known best block, and the last element the latest known
     *          finalized block.
     */
    getBestBlocks: () => Promise<BlockInfo[]>;
    /**
     * Observable of new blocks that have been discovered by the client.
     */
    blocks$: Observable<BlockInfo>;
    /**
     * Ensures that a block stays available, even after it has been finalized and
     * no operations are running for that block.
     *
     * @returns A callback function to release the block.
     */
    hodlBlock: (blockHash: HexString) => () => void;
    /**
     * Observable to watch Block Body.
     *
     * @param hash  It can be a block hash, `"finalized"`, or `"best"`
     * @returns Observable to watch a block body. There'll be just one event
     *          with the payload and the observable will complete.
     */
    watchBlockBody: (hash: string) => Observable<HexString[]>;
    /**
     * Get Block Body (Promise-based)
     *
     * @param hash  It can be a block hash, `"finalized"`, or `"best"`
     * @returns Block body.
     */
    getBlockBody: (hash: string) => Promise<HexString[]>;
    /**
     * Get Block Header (Promise-based)
     *
     * @param hash  It can be a block hash, `"finalized"` (default), or
     *              `"best"`
     * @returns Block hash.
     */
    getBlockHeader: (hash?: string) => Promise<BlockHeader>;
    /**
     * Broadcasts a transaction (Promise-based). The promise will resolve when the
     * transaction is found in a finalized block; and will reject if the
     * transaction is invalid and can't be broadcasted, or if it is deemed invalid
     * later on.
     *
     * @param transaction  SCALE-encoded tx to broadcast.
     * @param at           It can be a block hash, `"finalized"`, or `"best"`.
     *                     That block will be used to verify the validity of
     *                     the tx.
     */
    submit: (transaction: HexString, at?: HexString) => Promise<TxFinalizedPayload>;
    /**
     * Broadcasts a transaction and returns an Observable. The observable will
     * complete as soon as the transaction is in a finalized block. See
     * https://papi.how/typed/tx#signsubmitandwatch to learn about all possible
     * events.
     *
     * @param transaction  SCALE-encoded tx to broadcast.
     * @param at           It can be a block hash, `"finalized"`, or `"best"`.
     *                     That block will be used to verify the validity of
     *                     the tx.
     */
    submitAndWatch: (transaction: HexString, at?: HexString) => Observable<TxBroadcastEvent>;
    /**
     * Returns an instance of a `TypedApi`.
     *
     * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`
     *                     generated by `papi` CLI.
     */
    getTypedApi: <D extends ChainDefinition>(descriptors: D) => TypedApi<D>;
    /**
     * Returns an instance of a `UnsafeApi`.
     *
     * Note that this method is only meant for advanced users that really know
     * what are they doing. This API does not provide any runtime compatibility
     * checks protection and the consumer should implement them on their own.
     */
    getUnsafeApi: <D>() => UnsafeApi<D>;
    /**
     * Returns a Promise that resolves into the encoded value of a storage entry
     * or `null` if the key doesn't have a corresponding value.
     *
     * @param storageKey  Either one of the well-known substrate storage keys
     *                    or an hexadecimal storage key.
     */
    rawQuery: (storageKey: HexString | string, options?: PullOptions) => Promise<HexString | null>;
    /**
     * This will `unfollow` the provider, disconnect and error every subscription.
     * After calling it nothing can be done with the client.
     */
    destroy: () => void;
    /**
     * This API is meant as an "escape hatch" to allow access to debug endpoints
     * such as `system_version`, and other useful endpoints that are not spec
     * compliant.
     *
     * @example
     *
     *   const systemVersion = await client._request<string>("system_version", [])
     *   const myFancyThhing = await client._request<
     *     { value: string },
     *     [id: number]
     *   >("very_fancy", [1714])
     *
     */
    _request: <Reply = any, Params extends Array<any> = any[]>(method: string, params: Params) => Promise<Reply>;
}
type FixedSizeArray<L extends number, T> = Array<T> & {
    length: L;
};
type TxCallData = {
    type: string;
    value: {
        type: string;
        value: any;
    };
};
type PullOptions = Partial<{
    /**
     * `at` could be a block-hash, `best`, or `finalized` (default)
     */
    at: "best" | "finalized" | ({} & string);
    /**
     * `signal` allows you to abort an ongoing Promise. See [MDN
     * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for
     * more information
     */
    signal: AbortSignal;
}>;

type CreateClientOptions = Partial<{
    getMetadata: (codeHash: HexString) => Promise<Uint8Array | null>;
    setMetadata: (codeHash: HexString, metadata: Uint8Array) => void;
}>;
/**
 * This is the top-level export for `polkadot-api`.
 *
 * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC
 *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),
 *                  which must support the `chainHead`, `transaction` and
 *                  `chainSpec` groups.
 * @param options   - *(Optional)* An object that allows customization of
 *                  metadata handling.
 *                  You can supply functions to retrieve and/or persist the
 *                  metadata associated with runtime `codeHash` values:
 *
 *                  - `getMetadata`: A function that, given a `codeHash` (the
 *                  `:code:` hash),
 *                  returns a `Promise` resolving to a `Uint8Array`
 *                  representing the metadata,
 *                  or `null` if unavailable.
 *                  - `setMetadata`: A function that accepts a `codeHash` and
 *                  its associated `Uint8Array` metadata,
 *                  allowing you to persist the metadata (e.g., in a cache or
 *                  local store).
 * @example
 *
 *   import { getMetadata } from "@polkadot-api/descriptors"
 *   import { createClient } from "polkadot-api"
 *   import { getSmProvider } from "polkadot-api/sm-provider"
 *   import { chainSpec } from "polkadot-api/chains/polkadot"
 *   import { start } from "polkadot-api/smoldot"
 *
 *   const smoldot = start()
 *   const chain = await smoldot.addChain({ chainSpec })
 *
 *   // Connect to the polkadot relay chain.
 *   const client = createClient(getSmProvider(chain), { getMetadata })
 *
 */
declare function createClient(provider: JsonRpcProvider, { getMetadata, setMetadata }?: CreateClientOptions): PolkadotClient;

/**
 * Asynchronously create an instance of `OfflineApi`.
 * OfflineApi allows to create and sign transactions and access chain constants.
 *
 * @param chainDefinition  Pass descriptors from `@polkadot-api/descriptors`
 *                         generated by `papi` CLI.
 */
declare const getOfflineApi: <D extends ChainDefinition>(chainDefinition: D) => Promise<OfflineApi<D>>;

type Tuple<T> = [T, ...T[]];
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type UndoEnum<T> = UnionToIntersection<T extends {
    type: string;
    value: unknown;
} ? {
    [K in T["type"]]: (T & {
        type: K;
    })["value"];
} : T>;
type _Inner<T> = T extends void ? {} : undefined extends T ? {
    inner: ShapedCodec<Exclude<T, undefined>>;
} : T extends string | number | bigint | boolean | void | undefined | null | symbol | Uint8Array | Binary | FixedSizeBinary<any> ? {} : T extends Tuple<any> ? {
    inner: {
        [K in keyof T]: ShapedCodec<T[K]>;
    };
} : T extends Array<infer R> ? {
    inner: ShapedCodec<R>;
} : T extends ResultPayload<infer OK, infer KO> ? {
    inner: {
        ok: ShapedCodec<OK>;
        ko: ShapedCodec<KO>;
    };
} : {
    inner: {
        [K in keyof T]: ShapedCodec<T[K]>;
    };
};
type Inner<T> = _Inner<UndoEnum<T>>;
type ShapedCodec<T> = Codec<T> & Inner<T>;

type StorageCodecs<Args extends Array<any>, T> = {
    args: ShapedCodec<Args>;
    value: ShapedCodec<T>;
};
type ExtractStorageCodec<T extends DescriptorEntry<StorageDescriptor<any, any, any, any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends StorageDescriptor<infer Key, infer Value, any, any> ? StorageCodecs<Key, Value> : unknown;
    };
};
type ExtractTxCodec<T extends DescriptorEntry<TxDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends TxDescriptor<infer Args> ? ShapedCodec<Args> : unknown;
    };
};
type ExtractRuntimeCodec<T extends DescriptorEntry<RuntimeDescriptor<any, any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends RuntimeDescriptor<infer Args, infer Value> ? {
            args: ShapedCodec<Args>;
            value: ShapedCodec<Value>;
        } : unknown;
    };
};
type ExtractPlainCodec<T extends DescriptorEntry<PlainDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends PlainDescriptor<infer Value> ? ShapedCodec<Value> : unknown;
    };
};
type TypedCodecs<T extends ChainDefinition> = {
    query: ExtractStorageCodec<T["descriptors"]["pallets"]["__storage"]>;
    tx: ExtractTxCodec<T["descriptors"]["pallets"]["__tx"]>;
    event: ExtractPlainCodec<T["descriptors"]["pallets"]["__event"]>;
    apis: ExtractRuntimeCodec<T["descriptors"]["apis"]>;
    constants: ExtractPlainCodec<T["descriptors"]["pallets"]["__const"]>;
    view: ExtractRuntimeCodec<T["descriptors"]["pallets"]["__view"]>;
};

/**
 * It provides access the codecs of all possible on-chain interactions.
 *
 * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`
 *                     generated by `papi` CLI.
 */
declare const getTypedCodecs: <D extends ChainDefinition>(descriptors: D) => Promise<TypedCodecs<D>>;

export { CompatibilityToken, InvalidTxError, RuntimeToken, createClient, getOfflineApi, getTypedCodecs };
export type { ApisFromDef, ApisTypedef, ChainDefinition, ConstFromPalletsDef, CreateClientOptions, DescriptorEntry, ErrorsFromPalletsDef, EventPhase, EventsFromPalletsDef, FixedSizeArray, PalletsTypedef, PlainDescriptor, PolkadotClient, QueryFromPalletsDef, RuntimeDescriptor, StorageDescriptor, Transaction, TransactionValidityError, TxBestBlocksState, TxBroadcastEvent, TxBroadcasted, TxCall, TxCallData, TxDescriptor, TxEntry, TxEvent, TxEventsPayload, TxFinalized, TxFinalizedPayload, TxFromPalletsDef, TxInBestBlocksFound, TxInBestBlocksNotFound, TxObservable, TxOptions, TxPromise, TxSignFn, TxSigned, TypedApi, UnsafeApi, UnsafeTransaction, UnsafeTxCall, UnsafeTxEntry, ViewFnsFromPalletsDef };
