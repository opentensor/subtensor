'use strict';

var metadataCompatibility = require('@polkadot-api/metadata-compatibility');
var observableClient = require('@polkadot-api/observable-client');
var substrateBindings = require('@polkadot-api/substrate-bindings');
var substrateClient = require('@polkadot-api/substrate-client');
var rxjs = require('rxjs');
var utils = require('@polkadot-api/utils');
var operators = require('rxjs/operators');
var signer = require('@polkadot-api/signer');
var core = require('@rx-state/core');
var metadataBuilders = require('@polkadot-api/metadata-builders');

class RuntimeToken {
  constructor() {
  }
  // @ts-ignore
  _runtime(value) {
  }
}
class CompatibilityToken {
  constructor() {
  }
  // @ts-ignore
  _compatibility(value) {
  }
}
const compatibilityTokenApi = /* @__PURE__ */ new WeakMap();
const runtimeTokenApi = /* @__PURE__ */ new WeakMap();
const getCompatibilityApi = (token) => token instanceof RuntimeToken ? runtimeTokenApi.get(token) : compatibilityTokenApi.get(token);
var OpType = /* @__PURE__ */ ((OpType2) => {
  OpType2["Storage"] = "storage";
  OpType2["Tx"] = "tx";
  OpType2["Event"] = "events";
  OpType2["Const"] = "constants";
  OpType2["ViewFns"] = "viewFns";
  OpType2["Api"] = "apis";
  return OpType2;
})(OpType || {});
const EntryPointsCodec = substrateBindings.Vector(metadataCompatibility.EntryPointCodec);
const TypedefsCodec = substrateBindings.Vector(metadataCompatibility.TypedefCodec);
const TypesCodec = substrateBindings.Tuple(EntryPointsCodec, TypedefsCodec);
const createCompatibilityToken = (chainDefinition, chainHead) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead.runtime$.pipe(rxjs.filter((v) => v != null));
    let latest = await rxjs.firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = Promise.all([
    chainDefinition.metadataTypes.then(TypesCodec.dec),
    chainDefinition.descriptors,
    awaitedRuntime
  ]).then(([[entryPoints, typedefNodes], descriptors, runtime]) => {
    const token = new CompatibilityToken();
    compatibilityTokenApi.set(token, {
      runtime,
      getEntryPoint(opType, pallet, name) {
        const idx = descriptors[opType]?.[pallet]?.[name];
        if (idx == null)
          throw new Error(
            `Descriptor for ${opType} ${pallet}.${name} does not exist`
          );
        return entryPoints[idx];
      },
      typedefNodes
    });
    return token;
  });
  return promise;
};
const createRuntimeToken = (chainHead) => {
  const awaitedRuntime = new Promise(async (resolve) => {
    const loadedRuntime$ = chainHead.runtime$.pipe(rxjs.filter((v) => v != null));
    let latest = await rxjs.firstValueFrom(loadedRuntime$);
    loadedRuntime$.subscribe((v) => latest = v);
    resolve(() => latest);
  });
  const promise = awaitedRuntime.then((runtime) => {
    const token = new RuntimeToken();
    runtimeTokenApi.set(token, {
      runtime
    });
    return token;
  });
  return promise;
};
const metadataCache = /* @__PURE__ */ new WeakMap();
const getMetadataCache = (ctx) => {
  if (!metadataCache.has(ctx.metadataRaw)) {
    metadataCache.set(ctx.metadataRaw, {
      compat: /* @__PURE__ */ new Map(),
      lookup: ctx.lookup,
      typeNodes: []
    });
  }
  return metadataCache.get(ctx.metadataRaw);
};
const compatibilityHelper = (descriptors, getDescriptorEntryPoint, getRuntimeEntryPoint) => {
  const getRuntimeTypedef = (ctx, id) => {
    var _a;
    const cache = getMetadataCache(ctx);
    return (_a = cache.typeNodes)[id] || (_a[id] = metadataCompatibility.mapLookupToTypedef(cache.lookup(id)));
  };
  function getCompatibilityLevels(descriptors2, ctx) {
    if (descriptors2 instanceof RuntimeToken) {
      return {
        args: metadataCompatibility.CompatibilityLevel.Identical,
        values: metadataCompatibility.CompatibilityLevel.Identical
      };
    }
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    ctx || (ctx = compatibilityApi.runtime());
    const runtimeEntryPoint = getRuntimeEntryPoint(ctx);
    if (runtimeEntryPoint == null)
      return {
        args: metadataCompatibility.CompatibilityLevel.Incompatible,
        values: metadataCompatibility.CompatibilityLevel.Incompatible
      };
    const descriptorNodes = compatibilityApi.typedefNodes;
    const cache = getMetadataCache(ctx);
    const descriptorEntryPoint = getDescriptorEntryPoint(compatibilityApi);
    const result = metadataCompatibility.entryPointsAreCompatible(
      descriptorEntryPoint,
      (id) => descriptorNodes[id],
      runtimeEntryPoint,
      (id) => getRuntimeTypedef(ctx, id),
      cache.compat
    );
    return {
      args: result.args.level,
      values: result.values.level
    };
  }
  const getCompatibilityLevel = withOptionalToken(
    descriptors,
    (runtime) => minCompatLevel(getCompatibilityLevels(runtime))
  );
  const isCompatible = withOptionalToken(
    descriptors,
    (threshold, runtime) => getCompatibilityLevel(runtime) >= threshold
  );
  const compatibleRuntime$ = (chainHead, hash) => rxjs.combineLatest([descriptors, chainHead.getRuntimeContext$(hash)]);
  const withCompatibleRuntime = (chainHead, mapper) => (source$) => rxjs.combineLatest([
    source$.pipe(chainHead.withRuntime(mapper)),
    descriptors
  ]).pipe(rxjs.map(([[x, ctx], descriptors2]) => [x, descriptors2, ctx]));
  const argsAreCompatible = (descriptors2, ctx, args) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const levels = getCompatibilityLevels(descriptors2, ctx);
    if (levels.args === metadataCompatibility.CompatibilityLevel.Incompatible) return false;
    if (levels.args > metadataCompatibility.CompatibilityLevel.Partial) return true;
    if (levels.values === metadataCompatibility.CompatibilityLevel.Incompatible) return false;
    const entryPoint = getRuntimeEntryPoint(ctx);
    if (entryPoint == null) return false;
    return metadataCompatibility.valueIsCompatibleWithDest(
      entryPoint.args,
      (id) => getRuntimeTypedef(ctx, id),
      args
    );
  };
  const valuesAreCompatible = (descriptors2, ctx, values) => {
    if (descriptors2 instanceof RuntimeToken) return true;
    const level = getCompatibilityLevels(descriptors2, ctx).values;
    if (level === metadataCompatibility.CompatibilityLevel.Incompatible) return false;
    if (level > metadataCompatibility.CompatibilityLevel.Partial) return true;
    const compatibilityApi = compatibilityTokenApi.get(descriptors2);
    const entryPoint = getDescriptorEntryPoint(compatibilityApi);
    return metadataCompatibility.valueIsCompatibleWithDest(
      entryPoint.values,
      (id) => compatibilityApi.typedefNodes[id],
      values
    );
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getCompatibilityLevels,
    descriptors,
    withCompatibleRuntime,
    compatibleRuntime$,
    argsAreCompatible,
    valuesAreCompatible,
    getRuntimeTypedef
  };
};
const minCompatLevel = (levels) => Math.min(levels.args, levels.values);
const withOptionalToken = (compatibilityToken, fn) => (...args) => {
  const lastElement = args.at(-1);
  if (lastElement instanceof CompatibilityToken || lastElement instanceof RuntimeToken) {
    return fn(...args);
  }
  return compatibilityToken.then((token) => fn(...args, token));
};

const createConstantEntry = (palletName, name, {
  valuesAreCompatible,
  descriptors,
  isCompatible,
  getCompatibilityLevel
}) => {
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.lookup.metadata.pallets.find(
      (p) => p.name === palletName
    );
    const constant = pallet?.constants.find((c) => c.name === name);
    if (constant == null)
      throw new Error(`Runtime entry Constant(${palletName}.${name}) not found`);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (token) => {
    if (token) {
      const ctx = getCompatibilityApi(token).runtime();
      const value = getValueWithContext(ctx);
      if (!valuesAreCompatible(token, ctx, value))
        throw new Error(
          `Incompatible runtime entry Constant(${palletName}.${name})`
        );
      return value;
    }
    return descriptors.then(fn);
  };
  return Object.assign(fn, { isCompatible, getCompatibilityLevel });
};

const shareLatest = rxjs.share({
  connector: () => new rxjs.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription?.unsubscribe();
      reject(new utils.AbortError());
    } : rxjs.noop;
    subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        subscription?.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e);
        isDone = true;
      },
      complete: () => {
        signal?.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
        isDone = true;
      }
    });
    if (!isDone) signal?.addEventListener("abort", onAbort);
  });
}

const EMPTY_VALUE = Symbol("EMPTY_VALUE");
const lossLessExhaustMap = (mapper) => (source$) => new rxjs.Observable((observer) => {
  let idx = 0;
  let innerSubscription = null;
  let queuedValue = EMPTY_VALUE;
  let isOutterDone = false;
  const setInnerSubscription = () => {
    const observable = mapper(queuedValue, idx++);
    queuedValue = EMPTY_VALUE;
    innerSubscription = observable.subscribe({
      next(vv) {
        observer.next(vv);
      },
      error(ee) {
        observer.error(ee);
      },
      complete() {
        if (queuedValue !== EMPTY_VALUE) setInnerSubscription();
        else {
          innerSubscription = null;
          if (isOutterDone) observer.complete();
        }
      }
    });
  };
  const subscription = source$.subscribe({
    next(v) {
      queuedValue = v;
      if (!innerSubscription) setInnerSubscription();
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (!innerSubscription) observer.complete();
      isOutterDone = true;
    }
  });
  return () => {
    innerSubscription?.unsubscribe();
    subscription.unsubscribe();
  };
});

let NOTIN = {};
const continueWith = (mapper) => (source) => new rxjs.Observable((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN) observer.complete();
      else subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

const isOptionalArg = (lastArg) => typeof lastArg === "object" && lastArg !== null && Object.entries(lastArg).every(
  ([k, v]) => k === "at" && (v === void 0 || typeof v === "string") || k === "signal" && (v === void 0 || v instanceof AbortSignal)
);

const selfDependent = () => {
  const activeSubject = new rxjs.BehaviorSubject(
    new rxjs.Subject()
  );
  return [
    activeSubject.pipe(operators.switchAll()),
    () => operators.tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new rxjs.Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new rxjs.Subject());
      }
    })
  ];
};

const createEventEntry = (pallet, name, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  withCompatibleRuntime,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead.finalized$.pipe(
    withCompatibleRuntime(chainHead, (x) => x.hash),
    rxjs.map(([block, runtime, ctx]) => {
      const eventsIdx = ctx.lookup.metadata.pallets.find(
        (p) => p.name === pallet
      )?.events?.type;
      if (eventsIdx == null || ctx.lookup.metadata.lookup[eventsIdx].def.tag !== "variant" || ctx.lookup.metadata.lookup[eventsIdx].def.value.find(
        (ev) => ev.name === name
      ) == null)
        throw new Error(`Runtime entry Event(${pallet}.${name}) not found`);
      if (!argsAreCompatible(runtime, ctx, null)) throw compatibilityError();
      return [block, runtime, ctx];
    }),
    observableClient.concatMapEager(
      ([block, runtime, ctx]) => chainHead.eventsAt$(block.hash).pipe(
        rxjs.map((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            if (!valuesAreCompatible(runtime, ctx, x.event.value.value))
              throw compatibilityError();
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe(rxjs.mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => rxjs.firstValueFrom(shared$);
  const filter = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter, getCompatibilityLevel, isCompatible };
};

const createRuntimeCallEntry = (api, method, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const callName = `${api}_${method}`;
  const compatibilityError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at).pipe(
      rxjs.mergeMap(([runtime, ctx]) => {
        let codecs;
        try {
          codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        } catch {
          throw new Error(`Runtime entry RuntimeCall(${callName}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        return chainHead.call$(at, callName, utils.toHex(codecs.args.enc(args))).pipe(
          rxjs.map(codecs.value.dec),
          rxjs.map((value) => {
            if (!valuesAreCompatible(runtime, ctx, value))
              throw compatibilityError();
            return value;
          })
        );
      }),
      chainHead.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible });
};

const toMapped = rxjs.map((x) => x.mapped);
const createStorageEntry = (pallet, name, chainHead, getWatchEntries, {
  isCompatible,
  getCompatibilityLevel,
  getCompatibilityLevels,
  descriptors: descriptorsPromise,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const isBlockHash = pallet === "System" && name === "BlockHash";
  const sysNumberMapper$ = chainHead.runtime$.pipe(
    rxjs.filter(Boolean),
    rxjs.take(1),
    rxjs.map(
      ({ dynamicBuilder }) => typeof dynamicBuilder.buildStorage("System", "Number").value.dec(new Uint8Array(32)) === "bigint" ? BigInt : rxjs.identity
    ),
    rxjs.shareReplay()
  );
  const bigIntOrNumber = rxjs.pipe(
    rxjs.combineLatestWith(sysNumberMapper$),
    rxjs.map(([input, mapper]) => mapper(input))
  );
  const incompatibleError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const getCodec = (ctx) => {
    try {
      return ctx.dynamicBuilder.buildStorage(pallet, name);
    } catch (e) {
      throw new Error(`Runtime entry Storage(${pallet}.${name}) not found`);
    }
  };
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const isBest = target === "best";
    const actualArgs = isBest || target === "finalized" ? args.slice(0, -1) : args;
    return chainHead[isBest ? "best$" : "finalized$"].pipe(
      lossLessExhaustMap(
        () => getRawValue$(...actualArgs, isBest ? { at: "best" } : {})
      ),
      rxjs.distinctUntilChanged((a, b) => a.raw === b.raw),
      toMapped
    );
  };
  const getRawValue$ = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = rxjs.from(descriptorsPromise).pipe(
      rxjs.mergeMap(
        (descriptors) => chainHead.storage$(
          at,
          "value",
          (ctx) => {
            const codecs = getCodec(ctx);
            const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
            if (args !== actualArgs && !isLastArgOptional)
              throw invalidArgs(args);
            if (!argsAreCompatible(descriptors, ctx, actualArgs))
              throw incompatibleError();
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (data, ctx) => {
            const codecs = getCodec(ctx);
            const mapped = data === null ? codecs.fallback : codecs.value.dec(data);
            if (!valuesAreCompatible(descriptors, ctx, mapped))
              throw incompatibleError();
            return { raw: data, mapped };
          }
        )
      ),
      chainHead.withHodl(at)
    );
    if (isSystemNumber)
      return chainHead.pinnedBlocks$.pipe(
        rxjs.map((blocks) => {
          const hash = at === "finalized" || !at ? blocks.finalized : at === "best" ? blocks.best : at;
          const block = blocks.blocks.get(hash);
          if (!block) {
            throw new observableClient.BlockNotPinnedError(hash, "System.Number");
          }
          return block.number;
        }),
        rxjs.distinctUntilChanged(),
        bigIntOrNumber,
        rxjs.map((mapped) => ({ raw: mapped.toString(), mapped })),
        rxjs.catchError((e) => {
          if (e instanceof observableClient.BlockNotPinnedError) return result$;
          throw e;
        })
      );
    return isBlockHash && Number(args[0]) === 0 ? chainHead.genesis$.pipe(
      rxjs.map((raw) => ({ raw, mapped: substrateBindings.FixedSizeBinary.fromHex(raw) }))
    ) : result$;
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal } = isLastArgOptional ? lastArg : {};
    return firstValueFromWithSignal(
      getRawValue$(...args).pipe(toMapped),
      signal
    );
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = rxjs.from(descriptorsPromise).pipe(
      rxjs.mergeMap(
        (descriptors) => chainHead.storage$(
          at,
          "descendantsValues",
          (ctx) => {
            const codecs = getCodec(ctx);
            if (minCompatLevel(getCompatibilityLevels(descriptors, ctx)) === metadataCompatibility.CompatibilityLevel.Incompatible)
              throw incompatibleError();
            if (args.length > codecs.len) throw invalidArgs(args);
            const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
            if (args.length === codecs.len && actualArgs === args)
              throw invalidArgs(args);
            return codecs.keys.enc(...actualArgs);
          },
          null,
          (values, ctx) => {
            const codecs = getCodec(ctx);
            const decodedValues = values.map(({ key, value }) => ({
              keyArgs: codecs.keys.dec(key),
              value: codecs.value.dec(value)
            }));
            if (decodedValues.some(
              ({ value }) => !valuesAreCompatible(descriptors, ctx, value)
            ))
              throw incompatibleError();
            return decodedValues;
          }
        )
      ),
      chainHead.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  const watchEntries = (...args) => {
    const lastArg = args.at(-1);
    const isLastArgOptional = isOptionalArg(lastArg);
    return getWatchEntries(
      pallet,
      name,
      isLastArgOptional ? args.slice(0, -1) : args,
      isLastArgOptional && lastArg.at === "best"
    );
  };
  const getKey = (...args) => {
    const token = args.at(-1);
    if (token instanceof CompatibilityToken || token instanceof RuntimeToken) {
      const actualArgs = args.slice(0, -1);
      const ctx = getCompatibilityApi(token).runtime();
      if (!argsAreCompatible(token, ctx, actualArgs)) throw incompatibleError();
      return getCodec(ctx).keys.enc(...actualArgs);
    }
    return descriptorsPromise.then((x) => getKey(...args, x));
  };
  return {
    isCompatible,
    getCompatibilityLevel,
    getKey,
    getValue,
    getValues,
    getEntries,
    watchValue,
    watchEntries
  };
};

const getSystemVersionStruct = (lookupFn, dynamicBuilder) => {
  const constant = lookupFn.metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct") throw new Error("not a struct");
  return systemVersionDec(constant.value);
};

function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
const nextPower = (n) => 1 << Math.ceil(Math.log2(n));
const mortal = substrateBindings.enhanceEncoder(
  substrateBindings.Bytes(2)[0],
  (value) => {
    const period = Math.min(Math.max(nextPower(value.period), 4), 1 << 16);
    const phase = value.startAtBlock % period;
    const factor = Math.max(period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(period) - 1, 1), 15);
    const right = phase / factor << 4;
    return substrateBindings.u16[0](left | right);
  }
);

const [ChargeAssetTxPaymentEnc] = substrateBindings.Struct({
  tip: substrateBindings.compact,
  asset: substrateBindings.Option(substrateBindings.Bytes(Infinity))
});

const empty = new Uint8Array();
const zero = Uint8Array.from([0]);
const value = (value2) => ({
  value: value2,
  additionalSigned: empty
});
const additionalSigned = (additionalSigned2) => ({
  value: empty,
  additionalSigned: additionalSigned2
});
const both = (value2, additionalSigned2) => ({
  value: value2,
  additionalSigned: additionalSigned2
});
const getSignExtensionsCreator = (genesis, lookupFn, dynamicBuilder) => {
  const signedExtensionsEncoders = {};
  lookupFn.metadata.extrinsic.signedExtensions.forEach(
    ({ identifier, type, additionalSigned: additionalSigned2 }) => {
      signedExtensionsEncoders[identifier] = [type, additionalSigned2].map(
        (x) => dynamicBuilder.buildDefinition(x)[0]
      );
    }
  );
  return ({
    mortality,
    tip = 0n,
    nonce,
    customSignedExtensions = {},
    ...rest
  }) => {
    const invalidKeys = [];
    const systemVersion = getSystemVersionStruct(lookupFn, dynamicBuilder);
    const getFromCustomEntry = (key) => {
      const [valueEnc, additionalEnc] = signedExtensionsEncoders[key];
      const customEntry = customSignedExtensions[key];
      try {
        return utils.mapObject(
          {
            value: valueEnc,
            additionalSigned: additionalEnc
          },
          (encoder, key2) => {
            const input = customEntry?.[key2];
            return input instanceof Uint8Array ? input : encoder(input);
          }
        );
      } catch {
        invalidKeys.push(key);
        return null;
      }
    };
    const result = utils.mapObject(
      signedExtensionsEncoders,
      ([valueEnc, additionalEnc], key) => {
        if (customSignedExtensions[key]) return getFromCustomEntry(key);
        switch (key) {
          case "CheckNonce":
            return value(valueEnc(nonce));
          case "CheckMortality":
            return mortality.mortal ? both(
              mortal({
                period: mortality.period,
                startAtBlock: mortality.startAtBlock.height
              }),
              utils.fromHex(mortality.startAtBlock.hash)
            ) : both(zero, genesis);
          case "ChargeTransactionPayment":
            return value(valueEnc(tip));
          case "ChargeAssetTxPayment":
            return value(
              ChargeAssetTxPaymentEnc({
                tip,
                asset: rest.asset
              })
            );
          case "CheckGenesis":
            return additionalSigned(genesis);
          case "CheckMetadataHash":
            return both(zero, zero);
          case "CheckSpecVersion":
            return additionalSigned(
              additionalEnc(systemVersion["spec_version"])
            );
          case "CheckTxVersion":
            return additionalSigned(
              additionalEnc(systemVersion["transaction_version"])
            );
          default:
            return getFromCustomEntry(key);
        }
      }
    );
    invalidKeys.forEach((key) => {
      delete result[key];
    });
    return utils.mapObject(result, (x, identifier) => ({ ...x, identifier }));
  };
};

const NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
const lenToDecoder = {
  1: substrateBindings.u8.dec,
  2: substrateBindings.u16.dec,
  4: substrateBindings.u32.dec,
  8: substrateBindings.u64.dec
};
const getNonceAtBlock$ = (call$, from, at) => call$(at, NONCE_RUNTIME_CALL, from).pipe(
  rxjs.map((result) => {
    const bytes = utils.fromHex(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return decoder(bytes);
  })
);
const createTx = (chainHead, signer, callData, atBlock, customSignedExtensions, hinted = {}) => rxjs.combineLatest([
  hinted.nonce ? rxjs.of(hinted.nonce) : getNonce$(chainHead, utils.toHex(signer.publicKey)),
  chainHead.getRuntimeContext$(atBlock.hash),
  chainHead.genesis$
]).pipe(
  rxjs.take(1),
  rxjs.mergeMap(([nonce, ctx, genesis]) => {
    const signExtCreator = getSignExtensionsCreator(
      utils.fromHex(genesis),
      ctx.lookup,
      ctx.dynamicBuilder
    );
    const mortality = hinted.mortality ?? { period: 64, mortal: true };
    const signExtensions = signExtCreator({
      nonce,
      tip: hinted.tip ?? 0n,
      mortality: mortality.mortal ? {
        mortal: true,
        period: mortality.period,
        startAtBlock: {
          height: atBlock.number,
          hash: atBlock.hash
        }
      } : { mortal: false },
      customSignedExtensions,
      asset: hinted.asset
    });
    return signer.signTx(
      callData,
      signExtensions,
      ctx.metadataRaw,
      atBlock.number
    );
  })
);
const getNonce$ = (chainHead, from) => {
  const followHead$ = (head) => chainHead.newBlocks$.pipe(
    rxjs.scan((acc, block) => block.parent === acc ? block.hash : acc, head),
    rxjs.startWith(head),
    rxjs.distinctUntilChanged()
  );
  const followNonce$ = (head) => followHead$(head).pipe(
    rxjs.take(2),
    rxjs.switchMap((hash) => getNonceAtBlock$(chainHead.call$, from, hash))
  );
  const getHeadsNonce$ = (heads) => rxjs.combineLatest(
    heads.map(
      (head) => followNonce$(head).pipe(
        rxjs.map((value) => ({
          success: true,
          value
        })),
        rxjs.catchError(
          (err) => rxjs.of({
            success: false,
            value: err
          })
        )
      )
    )
  ).pipe(rxjs.take(1));
  return chainHead.pinnedBlocks$.pipe(
    rxjs.filter((v) => !v.recovering && v.blocks.size > 0),
    rxjs.take(1),
    rxjs.map(({ blocks, best }) => {
      const bestBlock = blocks.get(best);
      return [...blocks.values()].filter(
        (v) => !v.unpinnable && v.children.size === 0 && v.number >= bestBlock.number
      ).map((v) => v.hash);
    }),
    rxjs.switchMap(getHeadsNonce$),
    rxjs.map((result) => {
      const winner = result.reduce(
        (acc, v) => v.success ? v.value >= (acc ?? 0) ? v.value : acc : acc,
        null
      );
      if (winner == null) {
        throw result[0].value;
      }
      return winner;
    })
  );
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, key + "" , value);
const computeState = (analized$, blocks$) => new rxjs.Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    let analyzedNumber = pinnedBlocks.blocks.get(current).number;
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block) break;
      analyzed = analyzedBlocks.get(current = block.parent);
      analyzedNumber--;
    }
    if (!analyzed) return;
    const isFinalized = analyzedNumber <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && latestState?.found && latestState.hash === analyzed.hash) {
      if (isFinalized) observer.complete();
      return;
    }
    observer.next(
      latestState = analyzed.found.type ? {
        found,
        hash: analyzed.hash,
        number: analyzedNumber,
        index: analyzed.found.index,
        events: analyzed.found.events
      } : {
        found,
        validity: analyzed.found.validity
      }
    );
    if (isFinalized) {
      if (found) observer.complete();
      else if (analyzed.found.validity?.success === false)
        observer.error(new InvalidTxError(analyzed.found.validity.value));
    }
  };
  const subscription = blocks$.pipe(
    rxjs.distinctUntilChanged(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0) return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(rxjs.distinctUntilChanged((a, b) => a === b));
const getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => ({ ...x.event, topics: x.topics }));
  const lastEvent = events[events.length - 1];
  if (lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicFailed") {
    return {
      ok: false,
      events,
      dispatchError: lastEvent.value.value.dispatch_error
    };
  }
  return { ok: true, events };
};
class InvalidTxError extends Error {
  // likely to be a `TransactionValidityError`
  constructor(e) {
    super(
      JSON.stringify(
        e,
        (_, value) => {
          if (typeof value === "bigint") return value.toString();
          return value instanceof substrateBindings.Binary ? value.asHex() : value;
        },
        2
      )
    );
    __publicField(this, "error");
    this.name = "InvalidTxError";
    this.error = e;
  }
}
const submit$ = (chainHead, broadcastTx$, tx, emitSign = false) => chainHead.hasher$.pipe(
  rxjs.mergeMap((hasher) => {
    const txHash = utils.toHex(hasher(utils.fromHex(tx)));
    const getTxEvent = (type, rest) => ({
      type,
      txHash,
      ...rest
    });
    const pinnedBlocks = chainHead.pinnedBlocks$.state;
    const getHeightFromMortality = (mortality) => {
      if (!mortality.mortal) return 0;
      const { phase, period } = mortality;
      const topNumber = pinnedBlocks.blocks.get(pinnedBlocks.best).number;
      return Math.floor((Math.max(topNumber, phase) - phase) / period) * period + phase;
    };
    const getTipsFromHeight = (height) => {
      let tips = [...pinnedBlocks.blocks.values()].filter(
        (block) => !block.unpinnable && !block.children.size
      );
      const higherTip = Math.max(...tips.map(({ number }) => number));
      tips = tips.filter(({ number }) => number >= higherTip - 1);
      const finalized = pinnedBlocks.blocks.get(pinnedBlocks.finalized);
      tips = finalized.children ? [finalized, ...tips] : tips;
      return tips.filter((x) => x.number >= height);
    };
    const validateTxAt$ = ({ hash }) => chainHead.validateTx$(hash, tx);
    const validate$ = rxjs.defer(
      () => pinnedBlocks.finalizedRuntime.runtime.pipe(
        rxjs.map((r) => r.getMortalityFromTx(tx)),
        rxjs.map(getHeightFromMortality),
        rxjs.map(getTipsFromHeight),
        rxjs.mergeMap((blocksToValidate) => {
          let err;
          return rxjs.merge(
            ...blocksToValidate.map(
              (b) => rxjs.race(
                validateTxAt$(b),
                chainHead.finalized$.pipe(
                  rxjs.takeWhile((finalized) => {
                    if (finalized.number < b.number) return true;
                    let curr = finalized;
                    while (curr.number > b.number) {
                      const parent = pinnedBlocks.blocks.get(curr.parent);
                      if (!parent) return false;
                      curr = parent;
                    }
                    return curr.hash === finalized.hash;
                  }),
                  rxjs.ignoreElements(),
                  rxjs.endWith({ success: null })
                )
              )
            )
          ).pipe(
            rxjs.filter((v, idx) => {
              if (v.success === false) err ?? (err = new InvalidTxError(v.value));
              if (v.success) return true;
              if (idx === blocksToValidate.length - 1 && err) throw err;
              return false;
            }),
            rxjs.take(1)
          );
        }),
        rxjs.ignoreElements()
      )
    );
    const track$ = new rxjs.Observable((observer) => {
      const subscription = chainHead.trackTx$(tx).subscribe(observer);
      subscription.add(
        broadcastTx$(tx).subscribe({
          error(e) {
            observer.error(e);
          }
        })
      );
      return subscription;
    });
    const bestBlockState$ = computeState(
      track$,
      chainHead.pinnedBlocks$
    ).pipe(
      rxjs.map((x) => {
        if (!x.found)
          return getTxEvent("txBestBlocksState", {
            found: false,
            isValid: x.validity?.success !== false
          });
        return getTxEvent("txBestBlocksState", {
          found: true,
          block: {
            index: x.index,
            number: x.number,
            hash: x.hash
          },
          ...getTxSuccessFromSystemEvents(x.events, x.index)
        });
      })
    );
    return rxjs.concat(
      emitSign ? rxjs.of(getTxEvent("signed", {})) : rxjs.EMPTY,
      validate$,
      rxjs.of(getTxEvent("broadcasted", {})),
      bestBlockState$.pipe(
        continueWith(
          ({ found, type, ...rest }) => found ? rxjs.of(getTxEvent("finalized", rest)) : rxjs.EMPTY
        )
      )
    );
  })
);
const submit = async (chainHead, broadcastTx$, transaction, _at) => rxjs.lastValueFrom(submit$(chainHead, broadcastTx$, transaction)).then((x) => {
  if (x.type !== "finalized") throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

const accountIdEnc = substrateBindings.AccountId().enc;
const fakeSignature = new Uint8Array(64);
const fakeSignatureEth = new Uint8Array(65);
const getFakeSignature = (isEth) => () => isEth ? fakeSignatureEth : fakeSignature;
const [, queryInfoDecFallback] = substrateBindings.Struct({
  weight: substrateBindings.Struct({
    ref_time: substrateBindings.compactBn,
    proof_size: substrateBindings.compactBn
  }),
  class: substrateBindings.Variant({
    Normal: substrateBindings._void,
    Operational: substrateBindings._void,
    Mandatory: substrateBindings._void
  }),
  partial_fee: substrateBindings.u128
});
const createTxEntry = (pallet, name, chainHead, broadcast, {
  isCompatible: isCompatibleHelper,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  getRuntimeTypedef
}, checkCompatibility) => {
  const fn = (arg) => {
    const getCallDataWithContext = (runtime, arg2, txOptions = {}) => {
      const ctx = getCompatibilityApi(runtime).runtime();
      const { dynamicBuilder, assetId, lookup } = ctx;
      let codecs;
      try {
        codecs = dynamicBuilder.buildCall(pallet, name);
      } catch {
        throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
      }
      if (checkCompatibility && !argsAreCompatible(runtime, ctx, arg2))
        throw new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetId == null || !metadataCompatibility.isCompatible(
          txOptions.asset,
          metadataCompatibility.mapLookupToTypedef(lookup(assetId)),
          (id) => getRuntimeTypedef(ctx, id)
        ))
          throw new Error(`Incompatible runtime asset`);
        returnOptions = {
          ...txOptions,
          asset: dynamicBuilder.buildDefinition(assetId).enc(txOptions.asset)
        };
      }
      const { location, codec } = codecs;
      return {
        callData: substrateBindings.Binary.fromBytes(
          utils.mergeUint8([new Uint8Array(location), codec.enc(arg2)])
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead, null).pipe(
      rxjs.map(([runtime]) => getCallDataWithContext(runtime, arg2, options))
    );
    const getEncodedData = (token) => {
      if (!token)
        return rxjs.firstValueFrom(getCallData$(arg).pipe(rxjs.map((x) => x.callData)));
      return getCallDataWithContext(token, arg).callData;
    };
    const sign$ = (from, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      rxjs.mergeMap(
        ({ callData, options }) => createTx(
          chainHead,
          from,
          callData.asBytes(),
          atBlock,
          _options.customSignedExtensions || {},
          options
        )
      )
    );
    const _sign = (from, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead.finalized$ : at === "best" ? chainHead.best$ : chainHead.bestBlocks$.pipe(
        rxjs.map((x) => x.find((b) => b.hash === at))
      )).pipe(
        rxjs.take(1),
        rxjs.mergeMap(
          (atBlock) => atBlock ? sign$(from, _options, atBlock).pipe(
            rxjs.map((signed) => ({
              tx: utils.toHex(signed),
              block: atBlock
            }))
          ) : rxjs.throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from, options) => rxjs.firstValueFrom(_sign(from, options)).then((x) => x.tx);
    const signAndSubmit = (from, _options) => rxjs.firstValueFrom(_sign(from, _options)).then(
      ({ tx, block }) => submit(chainHead, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from, _options) => _sign(from, _options).pipe(
      rxjs.mergeMap(({ tx }) => submit$(chainHead, broadcast, tx, true))
    );
    const getPaymentInfo = async (from, _options) => {
      if (typeof from === "string")
        from = from.startsWith("0x") ? utils.fromHex(from) : accountIdEnc(from);
      const isEth = from.length === 20;
      const fakeSigner = signer.getPolkadotSigner(
        from,
        isEth ? "Ecdsa" : "Sr25519",
        getFakeSignature(isEth)
      );
      const encoded = utils.fromHex(await sign(fakeSigner, _options));
      const args = utils.toHex(utils.mergeUint8([encoded, substrateBindings.u32.enc(encoded.length)]));
      const decoder$ = chainHead.getRuntimeContext$(null).pipe(
        rxjs.map((ctx) => {
          try {
            return ctx.dynamicBuilder.buildRuntimeCall(
              "TransactionPaymentApi",
              "query_info"
            ).value[1];
          } catch {
            return queryInfoDecFallback;
          }
        })
      );
      const call$ = chainHead.call$(
        null,
        "TransactionPaymentApi_query_info",
        args
      );
      return rxjs.firstValueFrom(
        rxjs.combineLatest([call$, decoder$]).pipe(
          rxjs.map(([result, decoder]) => decoder(result))
        )
      );
    };
    const getEstimatedFees = async (from, _options) => (await getPaymentInfo(from, _options)).partial_fee;
    return {
      getPaymentInfo,
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: substrateBindings.Enum(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, {
    getCompatibilityLevel,
    isCompatible: isCompatibleHelper
  });
};

const getDiff = (_prev, _current, patch) => {
  const current = new Map(_current.map((x) => [x.key, x]));
  const prev = new Map(_prev.map((x) => [x.key, x]));
  const upserted = /* @__PURE__ */ new Map();
  const deleted = [];
  _current.forEach((value) => {
    const { key } = value;
    const prevVal = prev.get(key);
    if (!prevVal || prevVal.value !== value.value)
      upserted.set(key, patch(value));
  });
  _prev.forEach((x) => {
    if (!current.has(x.key)) deleted.push(x);
  });
  return {
    deltas: {
      deleted,
      upserted: [...upserted.values()]
    },
    entries: _current.map(({ key }) => upserted.get(key) ?? prev.get(key))
  };
};
const findPrevious = (start, state2, pinned, includeStart = false) => {
  try {
    let target = includeStart ? start : pinned.blocks.get(start).parent;
    while (target && !state2[target]) target = pinned.blocks.get(target).parent;
    if (!target) return null;
    return state2[target];
  } catch {
    return null;
  }
};
const getPatcherFromRuntime = (pallet, entry) => (runtime) => {
  const { keys, value } = runtime.dynamicBuilder.buildStorage(pallet, entry);
  return (x) => {
    x.dec = {
      value: value.dec(x.value),
      args: keys.dec(x.key)
    };
    return x;
  };
};
const createWatchEntries = (blocks$, storage, withRuntime) => {
  const getMemoryBlocks$ = core.state(
    (pallet, entry, storageKey) => {
      const getPatcher = getPatcherFromRuntime(pallet, entry);
      const getNextMemoryBlock$ = (prev, block) => {
        const isNotCanonical$ = observableClient.isBestOrFinalizedBlock(
          blocks$,
          block.hash
        ).pipe(
          rxjs.filter((x) => !x),
          rxjs.take(1)
        );
        return storage(
          block.hash,
          "closestDescendantMerkleValue",
          () => storageKey
        ).pipe(
          rxjs.mergeMap((rootHash) => {
            if (rootHash === prev?.rootHash)
              return rxjs.of({
                ...prev,
                block,
                deltas: null,
                prev: prev.block.hash
              });
            return storage(
              block.hash,
              "descendantsValues",
              () => storageKey
            ).pipe(
              withRuntime(() => block.hash),
              rxjs.map(
                ([entries, runtimeCtx]) => [entries, getPatcher(runtimeCtx)]
              ),
              rxjs.map(
                ([entries, patcher]) => ({
                  prev: prev && prev.block.hash,
                  rootHash,
                  block,
                  ...getDiff(
                    prev?.entries ?? [],
                    entries,
                    patcher
                  )
                })
              )
            );
          }),
          rxjs.takeUntil(isNotCanonical$),
          rxjs.catchError(
            (e) => e instanceof observableClient.BlockNotPinnedError ? rxjs.EMPTY : rxjs.throwError(() => e)
          )
        );
      };
      const initial$ = blocks$.pipe(
        rxjs.distinctUntilChanged((a, b) => a.finalized === b.finalized),
        lossLessExhaustMap(
          ({ blocks, finalized }) => getNextMemoryBlock$(null, blocks.get(finalized))
        ),
        rxjs.take(1),
        rxjs.map(
          (x) => ({
            blocks: { [x.block.hash]: x },
            finalized: x.block.hash
          })
        )
      );
      const [_memoryBlocks$, connectMemoryBlocks] = selfDependent();
      const updates$ = blocks$.pipe(
        rxjs.distinctUntilChanged((a, b) => a.best === b.best),
        rxjs.withLatestFrom(_memoryBlocks$),
        lossLessExhaustMap(([pinned, memoryBlocks]) => {
          const { best } = pinned;
          const { blocks } = memoryBlocks;
          let target = !blocks[best] ? best : null;
          if (!target) return rxjs.EMPTY;
          const previous = findPrevious(target, blocks, pinned);
          if (previous)
            return getNextMemoryBlock$(
              previous,
              pinned.blocks.get(target)
            ).pipe(
              rxjs.map((x) => {
                blocks[target] = x;
                return memoryBlocks;
              })
            );
          target = pinned.finalized;
          return getNextMemoryBlock$(
            blocks[memoryBlocks.finalized],
            pinned.blocks.get(target)
          ).pipe(
            rxjs.map((x) => {
              x.prev = null;
              return {
                blocks: { [target]: x },
                finalized: target
              };
            })
          );
        })
      );
      return rxjs.merge(initial$, updates$).pipe(connectMemoryBlocks());
    }
  );
  const getBestOrFinalized = (isFinalized) => (pallet, entry, storageKey) => {
    const memoryBlocks$ = getMemoryBlocks$(pallet, entry, storageKey);
    const getPatcher = getPatcherFromRuntime(pallet, entry);
    const prop = isFinalized ? "finalized" : "best";
    return rxjs.combineLatest([
      memoryBlocks$.pipe(rxjs.delay(0)),
      blocks$.pipe(rxjs.distinctUntilChanged((a, b) => a[prop] === b[prop]))
    ]).pipe(
      rxjs.map(
        ([state2, blocks]) => findPrevious(blocks[prop], state2.blocks, blocks, true)
      ),
      rxjs.filter(Boolean),
      rxjs.distinctUntilChanged(),
      rxjs.startWith(null),
      rxjs.pairwise(),
      rxjs.withLatestFrom(memoryBlocks$),
      withRuntime(([[, _latest]]) => _latest.block.hash),
      rxjs.map(
        ([[[prevUpdate, latest], memoryBlocks], runtimeCtx]) => [
          prevUpdate,
          latest,
          memoryBlocks,
          getPatcher(runtimeCtx)
        ]
      ),
      rxjs.mergeMap(([prevUpdate, latest, memoryBlocks, patcher]) => {
        if (!prevUpdate) return [latest];
        let ancestor = latest;
        const updates = [];
        while (ancestor && ancestor.block.number > prevUpdate.block.number) {
          updates.unshift(ancestor);
          ancestor = ancestor.prev ? memoryBlocks.blocks[ancestor.prev] : null;
        }
        if (isFinalized) {
          memoryBlocks.finalized = latest.block.hash;
          if (updates.length) {
            const { blocks } = memoryBlocks;
            Object.keys(blocks).forEach((key) => {
              if (blocks[key].block.number < updates[0].block.number)
                delete blocks[key];
            });
          }
        }
        if (prevUpdate === ancestor) return updates;
        return [
          {
            ...latest,
            ...prevUpdate.rootHash === latest.rootHash ? {
              entries: prevUpdate.entries,
              deltas: null
            } : getDiff(prevUpdate.entries, latest.entries, patcher)
          }
        ];
      })
    );
  };
  const getFinalized$ = core.state(getBestOrFinalized(true));
  const getBest$ = core.state(getBestOrFinalized(false));
  return (pallet, entry, args, atBest) => {
    const fn = atBest ? getBest$ : getFinalized$;
    const storageKey$ = blocks$.pipe(
      rxjs.take(1),
      rxjs.mergeMap(
        (b) => b.runtimes[b.blocks.get(b[atBest ? "best" : "finalized"]).runtime].runtime
      ),
      rxjs.map(
        (runtime) => runtime.dynamicBuilder.buildStorage(pallet, entry).keys.enc(...args)
      )
    );
    return storageKey$.pipe(
      rxjs.take(1),
      rxjs.mergeMap((storageKey) => fn(pallet, entry, storageKey)),
      rxjs.map(({ block: { hash, number, parent }, deltas, entries }, idx) => {
        const actualDeltas = idx > 0 ? deltas : { deleted: [], upserted: entries };
        return {
          block: { hash, number, parent },
          entries: entries.map(toDec),
          deltas: actualDeltas && {
            deleted: actualDeltas.deleted.map(toDec),
            upserted: actualDeltas.upserted.map(toDec)
          }
        };
      })
    );
  };
};
const toDec = (x) => x.dec;

const RUNTIME_NAMESPACE = "RuntimeViewFunction";
const RUNTIME_METHOD = "execute_view_function";
const RUNTIME_CALL_NAME = RUNTIME_NAMESPACE + "_" + RUNTIME_METHOD;
const createViewFnEntry = (pallet, entry, chainHead, {
  isCompatible,
  getCompatibilityLevel,
  compatibleRuntime$,
  argsAreCompatible,
  valuesAreCompatible
}) => {
  const compatibilityError = () => new Error(`Incompatible runtime entry ViewFn(${pallet}.${entry})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at).pipe(
      rxjs.mergeMap(([runtime, ctx]) => {
        let apiCodec;
        try {
          apiCodec = ctx.dynamicBuilder.buildRuntimeCall(
            RUNTIME_NAMESPACE,
            RUNTIME_METHOD
          );
        } catch {
          throw new Error(
            `Runtime entry RuntimeCall(${RUNTIME_CALL_NAME}) not found`
          );
        }
        let viewCodec;
        try {
          viewCodec = ctx.dynamicBuilder.buildViewFn(pallet, entry);
        } catch {
          throw new Error(`Runtime entry ViewFn(${pallet}.${entry}) not found`);
        }
        if (!argsAreCompatible(runtime, ctx, args)) throw compatibilityError();
        const viewArgs = viewCodec.args.enc(args);
        const arg = utils.mergeUint8([
          utils.fromHex(
            ctx.lookup.metadata.pallets.find(({ name }) => name === pallet).viewFns.find(({ name }) => name === entry).id
          ),
          substrateBindings.compactNumber.enc(viewArgs.length),
          viewArgs
        ]);
        return chainHead.call$(at, RUNTIME_CALL_NAME, utils.toHex(arg)).pipe(
          rxjs.map((v) => {
            try {
              const decoded = apiCodec.value.dec(v);
              if (!("success" in decoded && "value" in decoded) || !("type" in decoded.value) && !("asBytes" in decoded.value))
                throw null;
              return decoded;
            } catch {
              throw new Error(
                `Unexpected RuntimeCall(${RUNTIME_CALL_NAME}) type`
              );
            }
          }),
          rxjs.map(({ success, value }) => {
            if (!success) throw new Error(`ViewFn API Error: ${value.type}`);
            const decoded = viewCodec.value.dec(value.asBytes());
            if (!valuesAreCompatible(runtime, ctx, decoded))
              throw compatibilityError();
            return decoded;
          })
        );
      }),
      chainHead.withHodl(at)
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { getCompatibilityLevel, isCompatible });
};

const HEX_REGEX = /^(?:0x)?((?:[0-9a-fA-F][0-9a-fA-F])+)$/;
const createApi = (compatibilityToken, chainHead, broadcast$) => {
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const getPallet = (ctx, name) => ctx.lookup.metadata.pallets.find((p) => p.name === name);
  const getWatchEntries = createWatchEntries(
    chainHead.pinnedBlocks$,
    chainHead.storage$,
    chainHead.withRuntime
  );
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead,
      getWatchEntries,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Storage, pallet, name),
        // TODO this is way sub-optimal. Needs some rethought - maybe a builder for entry points?.
        (ctx) => {
          const item = getPallet(ctx, pallet)?.storage?.items.find(
            (s) => s.name === name
          );
          return item == null ? null : metadataCompatibility.storageEntryPoint(item);
        }
      )
    )
  );
  const getEnumEntry = (ctx, side, id, name) => {
    if (id == null) return null;
    const entry = ctx.lookup(id);
    if (entry.type !== "enum") throw new Error("Expected enum");
    if (entry.value[name] == null) return null;
    const node = metadataCompatibility.enumValueEntryPointNode(entry.value[name]);
    return {
      args: side === "args" ? node : metadataCompatibility.voidEntryPointNode,
      values: side === "args" ? metadataCompatibility.voidEntryPointNode : node
    };
  };
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainHead,
      broadcast$,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Tx, pallet, name),
        (ctx) => getEnumEntry(ctx, "args", getPallet(ctx, pallet)?.calls?.type, name)
      ),
      true
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Event, pallet, name),
        (ctx) => getEnumEntry(
          ctx,
          "values",
          getPallet(ctx, pallet)?.events?.type,
          name
        )
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Const, pallet, name),
        (ctx) => {
          const item = getPallet(ctx, pallet)?.constants.find(
            (c) => c.name === name
          )?.type;
          return item == null ? null : metadataCompatibility.singleValueEntryPoint(item);
        }
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.Api, api, method),
        (ctx) => metadataCompatibility.runtimeCallEntryPoint(
          ctx.lookup.metadata.apis.find((a) => a.name === api).methods.find((m) => m.name === method)
        )
      )
    )
  );
  const view = createProxyPath(
    (pallet, entry) => createViewFnEntry(
      pallet,
      entry,
      chainHead,
      compatibilityHelper(
        compatibilityToken,
        (r) => r.getEntryPoint(OpType.ViewFns, pallet, entry),
        (ctx) => metadataCompatibility.runtimeCallEntryPoint(
          ctx.lookup.metadata.pallets.find((a) => a.name === pallet).viewFns.find((m) => m.name === entry)
        )
      )
    )
  );
  const _callDataTx = (callData, token) => {
    const { lookup, dynamicBuilder } = getCompatibilityApi(token).runtime();
    try {
      const decoded = dynamicBuilder.buildDefinition(lookup.call).dec(callData.asBytes());
      const pallet = decoded.type;
      const call = decoded.value.type;
      const args = decoded.value.value;
      return createTxEntry(
        pallet,
        call,
        chainHead,
        broadcast$,
        compatibilityHelper(
          compatibilityToken,
          (r) => r.getEntryPoint(OpType.Tx, pallet, call),
          (ctx) => getEnumEntry(
            ctx,
            "args",
            getPallet(ctx, pallet)?.calls?.type,
            call
          )
        ),
        false
      )(args);
    } catch {
      throw new Error("createTx: invalid call data");
    }
  };
  return {
    query,
    txFromCallData: (callData, token) => token ? _callDataTx(callData, token) : compatibilityToken.then((t) => _callDataTx(callData, t)),
    tx,
    event,
    apis,
    constants,
    view
  };
};
function createClient(provider, { getMetadata, setMetadata } = {}) {
  const rawClient = substrateClient.createClient(provider);
  const client = observableClient.getObservableClient(rawClient, {
    getMetadata: getMetadata ? (codeHash) => rxjs.from(getMetadata(codeHash)) : void 0,
    setMetadata
  });
  const { getChainSpecData } = rawClient;
  const { genesis$, ..._chainHead } = client.chainHead$();
  const archive = client.archive(_chainHead.getRuntime$);
  const chainHead = {
    ..._chainHead,
    genesis$: rxjs.defer(getChainSpecData).pipe(
      rxjs.map(({ genesisHash }) => genesisHash),
      rxjs.catchError(() => genesis$),
      rxjs.shareReplay(1)
    ),
    storage$: observableClient.withArchive(_chainHead.storage$, archive.storage$),
    body$: observableClient.withArchive(_chainHead.body$, archive.body$),
    call$: observableClient.withArchive(_chainHead.call$, archive.call$),
    header$: observableClient.withArchive(_chainHead.header$, archive.header$),
    eventsAt$: observableClient.withArchive(_chainHead.eventsAt$, archive.eventsAt$),
    storageQueries$: observableClient.withArchive(
      _chainHead.storageQueries$,
      archive.storageQueries$
    ),
    getRuntimeContext$: observableClient.withArchive(
      _chainHead.getRuntimeContext$,
      archive.getRuntimeContext$
    )
  };
  const _request = rawClient.request;
  let runtimeToken;
  const compatibilityToken = /* @__PURE__ */ new WeakMap();
  const getChainToken = (chainDefinition) => {
    const result2 = compatibilityToken.get(chainDefinition) || createCompatibilityToken(chainDefinition, chainHead);
    compatibilityToken.set(chainDefinition, result2);
    return result2;
  };
  const getRuntimeToken = () => runtimeToken ?? (runtimeToken = createRuntimeToken(chainHead));
  const { broadcastTx$ } = client;
  const getMetadata$ = (at) => chainHead.getRuntimeContext$(at).pipe(rxjs.map((ctx) => ctx.metadataRaw));
  const result = {
    getChainSpecData,
    getMetadata$,
    getMetadata: (atBlock, signal) => firstValueFromWithSignal(getMetadata$(atBlock), signal),
    blocks$: chainHead.newBlocks$,
    hodlBlock: (block) => chainHead.holdBlock(block, true),
    finalizedBlock$: chainHead.finalized$,
    getFinalizedBlock: () => rxjs.firstValueFrom(chainHead.finalized$),
    bestBlocks$: chainHead.bestBlocks$,
    getBestBlocks: () => rxjs.firstValueFrom(chainHead.bestBlocks$),
    watchBlockBody: chainHead.body$,
    getBlockBody: (hash) => rxjs.firstValueFrom(chainHead.body$(hash)),
    getBlockHeader: (hash) => rxjs.firstValueFrom(chainHead.header$(hash ?? null)),
    submit: (...args) => submit(chainHead, broadcastTx$, ...args),
    submitAndWatch: (tx) => submit$(chainHead, broadcastTx$, tx),
    getTypedApi: (chainDefinition) => {
      const token = getChainToken(chainDefinition);
      return Object.assign(
        createApi(token, chainHead, broadcastTx$),
        { compatibilityToken: token }
      );
    },
    getUnsafeApi: () => {
      const token = getRuntimeToken();
      return Object.assign(createApi(token, chainHead, broadcastTx$), {
        runtimeToken: token
      });
    },
    rawQuery: (key, { at, signal } = {}) => firstValueFromWithSignal(
      chainHead.storage$(at ?? null, "value", () => {
        const hex = key.match(HEX_REGEX)?.[1];
        return hex ? `0x${hex}` : substrateBindings.Binary.fromText(key).asHex();
      }),
      signal
    ),
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    _request
  };
  result.___INTERNAL_DO_NOT_USE = chainHead;
  return result;
}

const createOfflineTxEntry = (pallet, name, metadataRaw, dynamicBuilder, signExtensionCreator) => {
  let codecs;
  try {
    codecs = dynamicBuilder.buildCall(pallet, name);
  } catch {
    throw new Error(`Runtime entry Tx(${pallet}.${name}) not found`);
  }
  const { location, codec } = codecs;
  const locationBytes = new Uint8Array(location);
  return (arg) => {
    const encodedData = substrateBindings.Binary.fromBytes(
      utils.mergeUint8([locationBytes, codec.enc(arg)])
    );
    return {
      encodedData,
      decodedCall: substrateBindings.Enum(pallet, substrateBindings.Enum(name, arg)),
      sign: async (from, extensions) => utils.toHex(
        await from.signTx(
          encodedData.asBytes(),
          signExtensionCreator(extensions),
          metadataRaw,
          extensions.mortality.mortal ? extensions.mortality.startAtBlock.height : 0
        )
      )
    };
  };
};
const getOfflineApi = async ({ genesis: genesisHex, getMetadata }) => {
  if (!genesisHex) throw new Error("Missing genesis hash");
  const genesis = utils.fromHex(genesisHex);
  const metadataRaw = await getMetadata();
  const metadata = substrateBindings.unifyMetadata(substrateBindings.metadata.dec(metadataRaw));
  const lookupFn = metadataBuilders.getLookupFn(metadata);
  const dynamicBuilder = metadataBuilders.getDynamicBuilder(lookupFn);
  const signExtensionCreator = getSignExtensionsCreator(
    genesis,
    lookupFn,
    dynamicBuilder
  );
  const getPallet = (name) => metadata.pallets.find((p) => p.name === name);
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const constants = createProxyPath((pallet, name) => {
    const constant = getPallet(pallet)?.constants.find((c) => c.name === name);
    if (!constant)
      throw new Error(`Runtime entry Constant(${pallet}.${name}) not found`);
    return dynamicBuilder.buildConstant(pallet, name).dec(constant.value);
  });
  const tx = createProxyPath(
    (pallet, name) => createOfflineTxEntry(
      pallet,
      name,
      metadataRaw,
      dynamicBuilder,
      signExtensionCreator
    )
  );
  return { constants, tx };
};

const withError = (builder, errName) => (pallet, name) => {
  try {
    return builder(pallet, name);
  } catch {
    throw new Error(`Runtime entry ${errName}(${pallet}.${name}) not found`);
  }
};
const getTypedCodecs = async (descriptors) => {
  const metadata = substrateBindings.unifyMetadata(
    substrateBindings.decAnyMetadata(await descriptors.getMetadata())
  );
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a]) cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b]) cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const lookup = metadataBuilders.getLookupFn(metadata);
  const {
    buildRuntimeCall,
    buildStorage,
    buildConstant,
    buildCall,
    buildEvent,
    buildViewFn
  } = metadataBuilders.getDynamicBuilder(lookup);
  return {
    query: createProxyPath((...a) => {
      const { value, args } = withError(buildStorage, "Storage")(...a);
      return { value, args };
    }),
    tx: createProxyPath((...a) => withError(buildCall, "Call")(...a).codec),
    event: createProxyPath(
      (...args) => withError(buildEvent, "Event")(...args).codec
    ),
    apis: createProxyPath(withError(buildRuntimeCall, "Runtime API")),
    constants: createProxyPath(withError(buildConstant, "Constant")),
    view: createProxyPath(withError(buildViewFn, "ViewFn"))
  };
};

Object.defineProperty(exports, "CompatibilityLevel", {
  enumerable: true,
  get: function () { return metadataCompatibility.CompatibilityLevel; }
});
Object.defineProperty(exports, "BlockNotPinnedError", {
  enumerable: true,
  get: function () { return observableClient.BlockNotPinnedError; }
});
Object.defineProperty(exports, "AccountId", {
  enumerable: true,
  get: function () { return substrateBindings.AccountId; }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function () { return substrateBindings.Binary; }
});
Object.defineProperty(exports, "Enum", {
  enumerable: true,
  get: function () { return substrateBindings.Enum; }
});
Object.defineProperty(exports, "FixedSizeBinary", {
  enumerable: true,
  get: function () { return substrateBindings.FixedSizeBinary; }
});
Object.defineProperty(exports, "_Enum", {
  enumerable: true,
  get: function () { return substrateBindings._Enum; }
});
Object.defineProperty(exports, "getSs58AddressInfo", {
  enumerable: true,
  get: function () { return substrateBindings.getSs58AddressInfo; }
});
exports.InvalidTxError = InvalidTxError;
exports.createClient = createClient;
exports.getOfflineApi = getOfflineApi;
exports.getTypedCodecs = getTypedCodecs;
//# sourceMappingURL=index.js.map
